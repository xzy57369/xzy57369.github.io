<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Raft论文阅读笔记]]></title>
    <url>%2Fpost%2Fa9d2d8fb.html</url>
    <content type="text"><![CDATA[Raft是一种一致性算法，与Paxos一样高效，但是更易理解。为了做到更易理解这点，Raft将一些关键元素分离，比如领导人选举，日志复制以及安全性。Raft也提供了新的机制，用于管理集群成员的变化，使用重叠的多数来保证安全。 Raft与许多现存的一致性算法类似，但是有几个新feature： 强leader：Raft使用强leader，例如日志只从leader向follower流动，简化日志复制并且使Raft更易理解 领导人选举：Raft使用随机的计时器选举leader。只在心跳机制上增加了一点点改动，轻松快速地解决了冲突 成员变动：Raft使用joint consensus机制，也就是使新旧配置上的majorities重叠，使集群在配置变动时能够正常工作 复制状态机一致性算法起源于复制状态机的概念，通常使用复制日志实现。如图一所示，每一个服务器存储包括一系列指令的日志，每个日志包含相同顺序的相同命令。因为命令是确定性的，所以每个状态机的输出序列都是相同的。 一致性算法就是用于保持日志的一致性的。一致性模块接受客户端的命令，与其他一致性模块交互，确保它们最终都以相同顺序包含相同的命令。一旦日志被正确复制，状态机就可以执行对应的命令，给客户端返回结果。最终，一组服务器表现为单一的、高可用的状态机。 一致性算法通常有以下性质： 在非拜占庭条件下保证安全性（不返回错误的结果），包括网络延迟，分区，丢包，重复，失序等。 在大多数节点可用的情况下保证可用性。比如，5个节点的集群可以容忍2个节点的错误。 不依赖于时间来保证一致性。错误的时钟和极端的消息延迟最坏也只可能导致可用性问题。 通常情况下，一条命令再大多数节点相应RPC时即可完成，小部分慢节点不会拖累整个系统的性能 5. Raft一致性算法 图二总结了Raft算法，图三是Raft算法的一些关键特性。Raft首先通过选举leader来实现一致性，leader全权负责日志的复制。leader接受客户端的请求，复制日志给其他服务器并告诉它们何时可以应用这些日志，这简化了日志复制的管理。leader可能会fail，此时需要选举新的leader。 用选举leader的方法，Raft将一致性问题分为几个小问题： 领导人选举：当前leader故障时，必须选择新的leader 日志复制：leader接受客户端的请求，复制日志给集群中其他成员，并使其强制认同leader的日志 安全性：如果任何服务器已将特定的日志条目应用于其状态机，则其他服务器都不能对同一索引位置的日志应用不同的命令。 5.1 Raft基础Raft集群包含一些服务器，比如5台，可以容忍2台的故障。在任意时刻，每一台机器都在三个状态之一：leader、follower、candidate。通常情况下只有一个leader，其他的全是follower。follower是被动的，他们不发起自己的请求，只回应leader和candidate的请求。leader处理客户端的请求（如果客户端联系follower，follower会转发给leader）。candidate是在领导人选举时使用的。图四描述了状态间的变化 Raft把时间分为任意长度的任期，任期用连续的数字表示。如图五所示。以领导人选举开始，如果某个candidate胜出，则它在当前任期中作为leader。在某些情况下票数会被平分，该任期也就没有leader，很快会开启新一轮选举。Raft协议确保一个任期只有一个leader。 不同的服务器可能会在不同的时间观察到任期的转换，某些情况下在整个任期内都不会观察到选举。任期作为逻辑时钟，使服务器可以检测过期的信息。每个服务器维护当前任期的值，随着时间单调增长。任期通过服务器之间的交互更新。如果一个服务器的任期小于其他的，它把当前任期更新为更大的值。如果一个candidate或者leader发现它的任期以及过期了，则立即转为follower模式。如果一个服务器接收到了过期term的请求，则拒绝之。 5.2 领导人选举Raft使用心跳机制来触发领导人选举。server启动时为follower状态，并且在收到合法的RPC时保持follower状态。Leader定期的发送心跳包来维持它的地位。如果follower在一定时期内没有收到消息，则开启一轮选举。开启一轮选举时，follower增加它的当前任期，转为candidate模式，给自己投票，然后并行发送请求投票RPC给其他服务器。保持candidate模式直到三件事情之一发生：(a)选举获胜、(b)另一个服务器确立自己为领导者、(c)没有获胜者，超时。 当candidate获得大多数的投票时，它获的选举胜利。每个服务器依据先到先得的原则，只给一个candidate投票。majority规则确保最多只有一个candidate可以获胜。candidate获胜后变为leader，给其他服务器发送心跳，确立自己为leader，防止新的选举。等待投票时，candidate可能从声明自己为leader的服务器收到AppendEntriesRPC，如果该leader的任期至少等于candidate的任期，candidate认为该leader是合法的，并且转为follower状态。如果小于，则拒绝该RPC，保持candidate状态。 第三种情况是candidate既没有赢，也没有输。如果许多follower同时转为candidate状态，票数可能会被平分，没有candidate可以获得大多数票。Raft使用随机选举超时时间来降低平分票数的概率，并快速解决。选举超时时间被随机设置为150ms-300ms之间。绝大多数情况下只有一个服务器会先超时，发起选举并在其他服务器超时前获胜。解决平分票数也用了此机制。服务器转为candidate模式时重置超时时间，降低了下一轮选举时平分的概率。 5.3 日志复制领导人选举完成后，就开始处理客户端的请求。每一条客户端的请求包含一条复制状态机要执行的命令。leader以新条目追加此命令到日志中，然后并行发送AppendEntries RPC至其他服务器。当这个条目被成功复制（后文描述），leader应用此命令至状态机，返回结果给客户端。如果follower崩溃或运行缓慢，或者网络发生丢包，leader会不断的发AppendEntries RPC，直到所有follower都保存了所有的日志。 Log的组织如图六。每一个log条目保存了一个命令，以及对应的任期。任期用于检测不一致性以及满足图三的各种性质。Leader决定何时应用log至状态机是安全的，当leader创建日志条目，并且复制至大多数服务器时被commited。Leader维护已commited的日志的最大索引，在将来的AppendEntries RPCs中发送。其他服务器发现一个log条目commited时，它也应用该条目至状态机。Raft维持以下性质，共同组成了图三中的Log Matching性质 如果两个logs中的不同条目有相同的任期及索引，那么它们保存相同的命令 如果两个logs中的不同条目有相同的任期及索引，那么所有之前的条目都是相同的 第一个性质是由于一个leader在一个任期内，同一个索引位置上最多创建一个日志条目，并且日志条目永不改变位置。第二个性质是由于AppendEntries的验证。当发送AppendEntries RPC时，leader会同时发送新条目之前一个位置的任期和索引，如果follower没有找到对应的条目，则拒绝该新条目。启动时日志满足Log Matching性质，当日志扩展时维持此性质。所以，当AppendEntries成功时，leader知道，直到新的日志条目，follower的日志是与他相同的。 通常情况下，AppendEntries一致性检查不会失败。但是leader崩溃时会导致日志的不一致，这些不一致会随着一系列leader和follower的崩溃加剧。图七展示了follower与leader可能不一致的情况。follower可能会缺少条目，也可能会多，或者又多又少。日志缺失或多余可能会跨越多个任期。 Raft使follower强制接受leader的log来维持一致性。这代表follower中冲突的条目会被leader覆盖。5.4节将证明添加一些限制后，这是安全的。 为了使follower的日志与leader一致，leader必须找到log出现分歧的条目，删除之后的所有条目，并且发送自己的条目。leader为每一个follower维护一个nextIndex变量，指向下一个leader发向follower的日志条目的位置。当leader掌权时，nextIndex被初始化为最后一个log条目的下一个位置（图七中为11）。AppendEntries RPC失败时，nextIndex减一，最终会到达一个leader与follower一致的位置。然后AppendEntries会成功，follower中冲突条目会被移除，leader中的日志被追加（如果有的话），然后follower的日志就与leader一致了。 5.4 安全性5.5 Follower 和 candidate 崩溃5.6 时间和可用性6. 集群成员变化]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.824 分布式系统 Lab1 MapReduce实现 2020 Spring]]></title>
    <url>%2Fpost%2F3a897789.html</url>
    <content type="text"><![CDATA[Lab的要求：https://pdos.csail.mit.edu/6.824/labs/lab-mr.html 使用git来获取代码git clone git://g.csail.mit.edu/6.824-golabs-2020 6.824 给的代码在src/main/mrsequential.go中提供了串行mapreduce的实现，mrapps/wc.go中给了统计单词的实现。可以通过如下方式使用 12345678910$ cd ~/6.824$ cd src/main$ go build -buildmode=plugin ../mrapps/wc.go$ rm mr-out*$ go run mrsequential.go wc.so pg*.txt$ more mr-out-0A 509ABOUT 2ACT 8... 要做的工作需要做的任务是实现一个分布式的MapReduce，包括两个程序，master和worker。worker通过RPC与master交互。每个worker进程向master索取任务，读取输入数据，进行计算，然后将结果写到文件。master应该有判断worker在一定时间内是否完成工作的能力(这个lab中为10秒)，如果没有完成则分配任务至其他worker main/mrmaster.go 和 main/mrworker.go中提供了一些初始代码，不要修改。自己的实现写在mr/master.go, mr/worker.go, 和 mr/rpc.go中。 程序应该按如下方式运行：先编译wr.go:go build -buildmode=plugin ../mrapps/wc.go在main目录中，启动master，pg-*.txt是输入的文件，每个文件对应一个split，被分给一个Map任务12$ rm mr-out*$ go run mrmaster.go pg-*.txt在其他窗口中，运行worker$ go run mrworker.go wc.so 当workers和master都完成时，查看mr-out-*，排序后结果应该和顺序执行相同。 main/test-mr.sh为用于测试的脚本 忽略可能遇到的Go RPC包的如下错误12019/12/16 13:27:09 rpc.Register: method "Done" has 1 input parameters; needs exactly three 一些规则： map阶段应该分割中间key至nReduce个reduce任务，nReduce是main/mrmaster.go中的参数，且传递给 MakeMaster() worker应该将第x个reduce的输出保存至mr-out-X文件中 mr-out-X文件中，每个reduce函数的输出为一行，应该是Go语言 &quot;%v %v&quot; 格式 worker应该将map的中间输出保存在当前目录中，之后读取为reduce的输入 main/mrmaster.go期望 mr/master.go 实现一个 Done() 函数，在MapReduce任务完成后返回true，然后 mrmaster.go 会退出 当任务完成时，worker退出，一个简单的实现是使用call()的返回值，如果worker连接master失败，可以认为是任务完成，master已退出，因此worker也可以终止。取决于设计，也可以让master给worker一个“请退出”的伪任务。 提示 一个开始的办法是修改mr/worker.go中Worker()方法，向master发送RPC请求任务。然后修改master，回复一个还未开始的map任务的文件名，然后修改worker读取该文件然后调用Map方法。可以参考mrsequential.go 合理的命名中间文件的方法为 mr-X-Y，这里X是Map的编号，Y是reduce的编号 map需要保存中间kv对至文件，然后在reduce时读取，一个可行的办法是使用encoding/json包。123enc := json.NewEncoder(file) for _, kv := ... &#123; err := enc.Encode(&amp;kv) 12345678dec := json.NewDecoder(file) for &#123; var kv KeyValue if err := dec.Decode(&amp;kv); err != nil &#123; break &#125; kva = append(kva, kv) &#125; map的部分可以用worker.go中的ihash(key)方法选择对应的reduce任务 可以从 mrsequential.go 中拷贝部分代码 不要忘了在master中对共享数据加锁 使用 go build -race 和 go run -race来启用go的竞态检测器，test-mr.sh中有相关的注释 worker可能需要等待，比如reduce无法启动，直至map完成。一个办法是worker周期性询问master，使用time.Sleep()睡眠。另一个办法是在master中使用RPC handler，使用 time.Sleep() 或 sync.Cond循环等待。Go会在新线程中处理RPC。 master无法区分worker是崩溃了还是停滞了还是执行过慢了，只能等待10秒，未完成则假设它失败了，重新调度任务至另一个worker。 测试崩溃恢复，可以使用 mrapps/crash.go ，随机在map和reduce中exit 可以使用 ioutil.TempFile 创建一个临时文件然后调用os.Rename原子性的修改文件名 在 mr-tmp中查看中间信息或输出结果 实现因为题目中说了不要公开代码，所以简单的说说思路吧 MapReduce论文中说的是实现Map和Reduce函数，就能方便的使用集群进行计算。但是这个Lab是给了Map和Reduce函数，实现MapReduce的调度。 主要的几个文件如下：mrmaster.go用于启动master，循环调用done()判断任务是否完成。mrworker.go用于启动worker，将Map和Reduce的实现传递给worker。这两个文件不需要改动。 2020 的lab1与往年相比更自由了，因此可以按照自己的想法写，但是也容易让人无从下手。可以按照题目中的提示，修改mr/worker.go中Worker()方法，向master发送RPC请求任务。然后修改master，回复一个还未开始的map任务的文件名，然后修改worker读取该文件然后调用Map方法。 master只有一个实例，需要维护任务的各种信息，在worker请求任务时进行分配。每个任务有每个任务的数据结构 在我的实现里，一个任务有 编号、阶段（MAP、REDUCE、WAIT、EXIT）、文件名的list、状态（NOTASSIGNED、ASSIGNED、FINISHED）、被分配的时间、reduce任务的数量 一个master，维护reduce任务数、map任务的list、reduce任务的list、一个互斥锁。启动master时根据传进的文件名初始化maplist，一个map任务处理一个文件。初始化nreduce个reduce任务加入reducelist worker请求任务时，遍历maplist，选择一个NOTASSIGNED的任务或者已经ASSIGN但是距离上次分配时间超过10秒的任务分配出去，并且设置分配时间。然后把这个任务加入list尾部，这样下一个worker来的时候就不会重复扫描。 worker接收到任务，打开文件，调用map方法，根据key输出到R个文件中。先输出至临时文件最后再重命名，保证在crash的时候文件的拥有合法文件名的内容是正确的。文件名的格式为mr-x-y，x为map任务编号，y为hash(key)%nreduce后的值。最后把这R个文件名传回给master master接收到map任务完成的消息，根据文件名中的y，把文件名加入到对应编号的reduce的文件名列表 反复，直到maplist中任务全都FINISHED worker继续请求任务，扫描maplist列表，判断是否全部FINISHED，否则返回一个WAIT任务，crash的worker执行的任务会超时然后重新分配，因此最后会全都finish master分配reduce任务，逻辑上与分配map任务差不多 worker执行reduce任务，打开文件名列表中的所有文件，收集kv对。然后进行排序，输出至mr-out-y文件，y为reduce的编号 当maplist和reducelist中的任务都为finished时，master的done()函数返回true，master退出。因为done()函数是间隔执行的，在此期间仍可能有worker请求任务，此时返回exit任务，告诉worker可以退出 中间文件共有$M*R$个，最后的输出有$R$个 注意对master中的数据结构加互斥锁]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>6.824</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce论文阅读笔记]]></title>
    <url>%2Fpost%2F72495d0d.html</url>
    <content type="text"><![CDATA[MapReduceMapReduce是用于处理大数据的一个框架，用户通过编写map函数，接收key/value对，输出一系列中间k/v对，redece函数合并具有相同key的中间k/v对。 这样编写的程序可以自动的并行化，运行在普通商用计算机组成的集群上，运行时系统自动的划分输入数据，分发任务，处理错误，管理机器间通信。程序员不需要任何并行化和分布式系统的经验就可以使用大规模的分布式系统。 例子一个统计文档中出现的单词数的例子如下（伪码） 123456789101112map(String key, String value): // key: document name // value: document contents for each word w in value: EmitIntermediate(w, "1"); reduce(String key, Iterator values): // key: a word // values: a list of counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); 更一般的，mapreduce有如下形式 12map (k1,v1) → list(k2,v2) reduce (k2,list(v2)) → list(v2) mapreduce还可以用于分布式的grep、url访问次数统计、倒排索引、分布式排序等 实现使用的硬件： 双核x86处理器，运行Linux系统，2-4GB的内存。 商用网络硬件，在机器层面通常为100Mbps或1Gbps。 一个集群有上百个机器，故障非常普遍。 存储使用不贵的IDE硬盘，直接连接在机器上，使用GFS文件系统。 用户提交任务给调度系统，调度系统将细分的小任务分配给集群中可用的机器 执行过程输入数据会被自动的划分为M片，分配到不同的机器上面Map，数据的划分也可以在不同机器上并行处理。使用Map产生的中间key，使用一个分区函数分成R片，分配至不同的机器进行Reduce。总体过程如下 用户程序中的MapReduce库将输入数据分成M片，每片通常16MB-64MB。然后在集群上启动许多副本 有一个副本比较特殊，称为master，其余副本由master分配工作。有M个map任务和R个reduce需要分配，master会自动选取空闲的worker分配任务。 被分配到map任务的worker读取对应的输入分片，解析k/v对并传递给用户定义的map函数，map函数生成的中间结果缓存在内存中 缓存的k/v对周期性的写入硬盘，通过分区函数划分为R片。结果保存的位置会传回给master，master负责把位置传递给reduce woker 当reduce worker被master通知文件位置时，使用RPC读取文件，当他读取了所有的中间数据，他用key对其进行排序，这样相同的key就会被合并。如果中间数据太大，使用外部排序 reduce worker遍历排序好的中间数据，把key和对应的value set传给用户自定义的Reduce函数，Reduce函数的输出append到一个文件中 当所有map 和 reduce 任务都完成了，master唤醒用户程序。 结束后，mapreduce的输出是R个文件，通常不需要合并为一个文件，因为可能会继续传给其他的mapreduce或者其他可以划分数据的分布式应用使用。 master的数据结构对于每个map任务和reduce任务，master维持他们的状态（空闲，执行中，完成）以及worker机器的身份。 master是map任务传递中间文件位置给reduce任务的管道。对于每个完成的map任务，master维护R个输出文件的位置、大小，当map任务完成时更新。这些信息会被推送给正在执行reduce任务的worker。 容错worker failuremaster周期性的ping worker，如果没有收到回应，就标记该worker 失败，该worker已完成的map任务被重置，因此可以被调度至其他worker运行。同样的，在运行的map或reduce任务也被重置。 已完成的map被再次执行，因为结果保存在本地磁盘上，如果该机器fail了，那么文件也无法访问了。已经完成的reduce任务不需要再次执行，因为结果已经保存在全局的文件系统中。 如果一个map任务由A执行后又由B执行，其他执行reduce任务的worker会得到通知，如果还没有从A读取数据，之后将会从B读取 MapReduce可以抵抗大规模的worker failures，只需要重新执行fail机器上的任务 master failure使master周期性保存上述数据结构很容易。如果master fail了，使用检查点可以重新启动一个master的拷贝。然而，在只有一个master的情况下，fail的概率很小，因此实现时如果master fail，只是终止MapReduce，客户端可以重新运行MapReduce任务。 出现错误时的语义当map 和 reduce 任务是确定性的时，我们的分布式实现产生与无错误顺序执行相同的结果。我们使用map和reduce原子性提交结果来实现这个性质。每个执行中的task将结果写到私有的临时文件中。reduce任务产生一个文件，map任务产生R个。当map任务完成时，worker发送一个包含R个文件名的信息给master，如果master收到已完成map任务的信息，它将忽略此信息，否则，它记录R个文件的名字。 当reduce任务完成时，reduce worker重命名它的临时文件为最终文件。如果有其他worker运行相同的reduce任务，多个重命名请求会被执行。我们利用底层文件系统的重命名原子性，确保最终文件系统状态仅包含一次执行reduce任务所产生的数据。 当map reduce操作时非确定的时，我们提供稍弱但仍合理的语义。这块暂时没懂。 局部性网络带宽是相对比较稀有的资源。master会将map任务分配给保存了那个输入文件的机器，如果失败，尝试分配至就近的机器（例如在一个交换机上）。节省大量的网络带宽。 任务粒度我们将map划分为M片，reduce划分为R片。理想的，M和R将远大于worker数。使每个worker执行许多不同任务提升动态负载均衡性，同样加速worker fail时的恢复。在实践中，我们通常选择M，使得每个任务处理大约16MB-64MB的数据。 备份任务有些时候会出现straggler现象，一个机器在最后几个map或reduce任务上花费了异常大的执行时间。这可能有多个理由，例如，坏的硬盘。其他任务也可能被分配至此机器，由于cpu、内存、网络、硬盘的竞争，使得执行时间更慢了。 我们有全局的机制来缓解这个问题。当MapReduce快要完成时，master调度执行中的任务备份执行，当主或备份执行完成时，该任务完成。 细节分区函数通常情况下我们使用hash(key) mod R来分区，然而在某些情况下可以使用其他分区函数。例如，我们可以使用hahs(Hostname(urlkey))mod R来将具有相同域名的url映射到相同的文件 排序保证我们保证在给定划分时，中间的k/v对以升序被处理。使得输出一个排序的结果文件更容易，在输出文件需要根据key随机查找时效率更高，用户可能也会觉得很方便 结合函数在某些情况下，每个映射任务产生的中间键会大量重复。一个例子是单词统计，可能会产生许多对，这些对都会通过网络发送，我们允许用户定义一个可选的combiner函数。combiner函数在运行map任务的机器上执行，通常combiner和reduce很像，区别是reduce将输出写到最终文件中，combiner将输出写到临时文件，发送给reduce。 输入输出类型MapReduce库提供以不同格式读取数据的支持，例如，text模式将输入每行视作k/v对，k是偏移量，v是该行的内容。用户也可以自定义reader的实现。reader不必只从文件读，也可以从数据库读，或者从内存中读 副作用有些时候用户可能发现输出一些辅助文件很方便，但是需要用户自己来保证原子性及幂等。 跳过坏记录有些时候用户的代码可能有bug，对于特定的records可能导致程序的崩溃。通常的做法是修复bug，然而在某些情况下却并不适用。可能bug是由于第三方库，或者有些时候也可以跳过一两条记录。worker会把错误信息发送给master，当master发现对于一条记录有多个失败时，说明该记录应该被跳过 本地运行想debug Map或 Reduce往往比较困难。为了辅助debug、测试，MapReduce库提供了用于本地调试的选项，然后就可以使用gdb等进行调试 状态信息master运行一个内部的HTTP服务器，提供一些信息给用户。包括进度，输入输出数据量，处理速度等，也提供指向标准错误或标准输出的连接。用户可以监控任务还需要多久，判断是否需要更多资源等。另外，最顶层的状态页展示哪些worker故障了，故障时在执行什么任务等信息 计数MapReduce框架提供计数功能。用户可以创建一个计数器对象，在map或reduce中进行递增操作。计数器值会在master与worker心跳包之间传递。master统计成功执行的map或reduce任务的counter值，并处理重复map、reduce任务以避免两次计数。]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>mapreduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之线程池使用及源码剖析]]></title>
    <url>%2Fpost%2Fad0f555f.html</url>
    <content type="text"><![CDATA[线程池123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize 线程池核心线程数最大值,核心线程默认情况下即使在没有工作时也会保留 maximumPoolSize 线程池最大线程数大小 keepAliveTime 非核心线程空闲的存活时间大小 unit 线程空闲存活时间单位 workQueue 用于存放任务的阻塞队列,核心线程满时新任务先放入阻塞队列，队列满时再创建非核心线程，如果超过最大线程数，则抛出异常 threadFactory线程工厂，主要用来创建线程，比如可以指定线程的名字 handler 当队列和最大线程池都满了之后的饱和策略，主要有四种类型 使用通过execute(Runnable command)方法来向线程池提交任务 1234567891011121314import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123; public static void main(String[] args)&#123; ExecutorService threadPool = Executors.newFixedThreadPool(5); for(int i=0;i&lt;5;i++) threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;); threadPool.shutdown(); &#125;&#125; 常见线程池newCachedThreadPool123456public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory); &#125; corePoolSize =&gt; 0，核心线程池的数量为0 maximumPoolSize =&gt; Integer.MAX_VALUE，线程池最大数量为Integer.MAX_VALUE，可以认为可以无限创建线程 keepAliveTime =&gt; 60L unit =&gt; 秒 workQueue =&gt; SynchronousQueue 因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。 用于并发执行大量短期的小任务 newFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; FixedThreadPool是固定核心线程的线程池，固定核心线程数由用户传入 corePoolSize =&gt; nThreads maximumPoolSize =&gt; nThreads，线程池最大数量为nThreads，即最多只可以创建nThreads个线程 keepAliveTime =&gt; 0L unit =&gt; 毫秒 workQueue =&gt; LinkedBlockingQueue 使用的是LinkedBlockingQueue，在资源有限的时候容易引起OOM异常 FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。 newSingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 核心线程数为1 最大线程数也为1 阻塞队列是LinkedBlockingQueue keepAliveTime为0 适用于串行执行任务的场景，一个任务一个任务地执行。 newScheduledThreadPool12345public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory); &#125; 最大线程数为Integer.MAX_VALUE 阻塞队列是DelayedWorkQueue keepAliveTime为0 scheduleAtFixedRate() ：按某种速率周期执行 scheduleWithFixedDelay()：在某个延迟后执行 周期性执行任务的场景，需要限制线程数量的场景 原理线程池的状态线程池有5种状态 RUNNING，接收新任务，处理缓存的任务 SHUTDOWN，不接受新任务，但处理缓存的任务 STOP，不接受新任务，不处理缓存的任务，中断正在执行的任务 TIDYING，所有线程都已终止，有效线程为0，触发_terminated()_方法 TERMINATED，_terminated()_方法结束 线程池的状态通过一个AtomicInteger来实现，使用3位来代表状态，剩下的位用于统计线程数。线程使用Worker来包装。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * 分三步处理 * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 1. 如果线程数少于corePoolSize，则尝试创建一个新的线程，用传入的command对象作为此线程 * 要首先执行的任务。 addWorker原子性的检查线程池的状态和worker数量，通过返回false防止 * 在不应该创建线程的时候创建线程， * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 2. 如果一个任务被成功的加入队列，仍旧需要二次检查确认是否需要新建一个线程（因为从上一次检 * 查以来可能有线程结束）或者在进入此方法后线程池shutdown。所以我们重新检查状态，如果线程池 * 已关闭则撤回入队操作，或者在没有线程时新建一个线程 * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. * * 3. 如果不能将任务加入队列，那么尝试新建一个线程。如果失败了则拒绝任务。 */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; //工作线程少于核心线程时，添加一个worker来执行任务，true代表使用核心线程 if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //到这里，任务进入了队列 int recheck = ctl.get(); //重新检查，如果线程池不running了，移除并拒绝 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果线程池仍在运行，且在运行的线程数为0，那么开启新的线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //添加任务失败，拒绝 else if (!addWorker(command, false)) reject(command); &#125; 再看addWorker方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * Checks if a new worker can be added with respect to current * pool state and the given bound (either core or maximum). If so, * the worker count is adjusted accordingly, and, if possible, a * new worker is created and started, running firstTask as its * first task. This method returns false if the pool is stopped or * eligible to shut down. It also returns false if the thread * factory fails to create a thread when asked. If the thread * creation fails, either due to the thread factory returning * null, or due to an exception (typically OutOfMemoryError in * Thread.start()), we roll back cleanly. * * 根据线程池的状态以及给的上限（核心线程数或最大线程数）检查是否可以创建新的worker * 如果可以，那么调整worker的数量，如果新的worker被创建和启动，那么运行它的firstTask * 如果线程池已经stopped或者可以shutdown，此方法返回false。如果threadfactory创建 * 线程失败，同样返回false。如果threadfactory创建线程失败，要么是由于它返回了null， * 要么是出现异常，我们回滚并进行清理 * * @param firstTask the task the new thread should run first (or * null if none). Workers are created with an initial first task * (in method execute()) to bypass queuing when there are fewer * than corePoolSize threads (in which case we always start one), * or when the queue is full (in which case we must bypass queue). * Initially idle threads are usually created via * prestartCoreThread or to replace other dying workers. * * @param firstTask 是新创建的线程应该首先执行的任务，如果没有的话为null。worker在创建时 * excute方法中）会被附带上first task，以在线程数少于核心线程数（此时我们永远创建新线程） * 或队列满时（此时我们必须跳过排队）跳过排队。通常空闲线程是由已创建的核心线程创建的，或者用 * 于替换已死线程 * * @param core if true use corePoolSize as bound, else * maximumPoolSize. (A boolean indicator is used here rather than a * value to ensure reads of fresh values after checking other pool * state). * * @param core 为true使用核心线程数做上限，否则使用最大线程数。 * * @return true if successful * @return 如果成功返回true if successful */ private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); /* Check if queue empty only if necessary. * 这里有点复杂，把!分配进括号里展开，逻辑变成以下三个 * 1.rs &gt;= SHUTDOWN &amp;&amp; rs != SHUTDOWN,也就是STOP,TIDYING,TERMINATED状态 * 2.rs &gt;= SHUTDOWN &amp;&amp; firstTask != null * 3.rs &gt;= SHUTDOWN &amp;&amp; workQueue.isEmpty() * 以上三个条件满足则不创建新的worker，因为 * 1.大于等于STOP状态，不再接受新任务，也不处理已缓存任务，自然不能添加worker * 2.到这里必然是SHUTDOWN状态，否则在第1步就已经为true了。此时如果firstTask != null * 说明是创建线程用于执行新任务，当然不允许。注意如果firstTask为null是可以创建的，此时 * worker会从队列中取任务执行，符合SHUTDOWN状态的定义。 * 3.SHUTDOWN且队列已经空了，那么肯定不允许新建worker。注意如果这里非空，那也是允许创建的 * 因为SHUTDOWN状态还要运行缓存的任务。 */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //如果线程数超过了CAPACITY或者给定的上限，那么返回false if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //cas修改线程数，成功跳出外层循环 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl 重新检查状态 if (runStateOf(c) != rs)//如果线程池的状态变化了，那么重新外层循环 continue retry; // 那么cas失败是由于线程数变化，重复内层循环继续cas即可 // else CAS failed due to workerCount change; retry inner loop &#125; &#125; //到这里线程数已经修改完了 boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //创建新的worker w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //必须持有线程池上的锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); //检查线程是可以启动的 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //把worker加入集合中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; //worker成功加入集合 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start();//启动worker中的线程 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; addWorker之后，调用worker中Thread的start方法，start方法又调用worker的run，worker中的run方法又调用runWorker方法，runWorker中最终调用task的run 1234567891011121314151617181920212223242526272829303132333435363738394041424344final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt // 如果线程池正在stopping，确保中断线程，如果没有，确保不中断线程 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task);//这里是留给扩展的 Throwable thrown = null; try &#123; task.run();//终于调用task的run &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown);//这里也是留给扩展的 &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[epoll如此快的关键]]></title>
    <url>%2Fpost%2F7f599158.html</url>
    <content type="text"><![CDATA[在中文网站上找epoll相关资料，都没有找到特别好的。有些讲的太浅，搞不懂其原理以及在内核层面是如何实现的。有些则太深，陷入源码之中，少了一些对整个流程的提炼。在英文网站上找到一篇不错的资料，图文并茂，讲的也很好，在此对其翻译记录一下。尽量翻译，可能有误，有问题时请以原文为准 正文epoll代表event poll，是linux中的一个特殊数据结构。它可以使一个进程同时监控许多文件描述符，并且当io就绪时得到通知。epoll支持边缘触发（edge-trigged）和水平触发（level-trigged）模式，在讲解epoll前，先来看epoll的语法。 epoll的语法与poll不同，epoll不是一个系统调用。它是一个内核数据结构，允许一个线程进行io多路复用。 epoll可以通过三个系统调用来被创建，修改和删除。 epoll_createepoll的实例通过epoll_create系统调用来创建，返回一个epoll结构的文件描述符，epoll_create的函数签名如下 12#include &lt;sys/epoll.h&gt;int epoll_create(int size); size 参数用于通知内核一个进程想要监听有多少文件描述符，从而使内核可以判断epoll结构的大小。从Linux 2.6.8开始，这个参数被忽略，因为采用了红黑树结构来组织文件描述符，因此可以动态的调整大小 epoll_create 系统调用返回新创建的epoll结构的文件描述符，调用它的进程可以使用此文件描述符来添加，删除或修改想要监听的io 还存在另一个 epoll_create1 系统调用 int epoll_create1(int flags); flags字段可以是0 或者 EPOLL_CLOEXEC. 为0时，epoll_create1 和 epoll_create一样。为 EPOLL_CLOEXEC 时，fork当前进程的子进程在exec之前会关闭对应的epoll描述符，子进程不再能够访问该epoll的实例。 值得注意的是与epoll实例关联的文件描述符需要使用close()系统调用来关闭。当使用fork并且没有使用 EPOLL_CLOEXEC 时，对应的子进程会拥有epoll描述符的拷贝，当所有进程都对描述符进行了释放，内核才会删除epoll实例。 epoll_ctl一个进程可以通过epoll_ctl添加希望监听的文件描述符到epoll实例。所有被注册到epoll的文件描述符称为epoll set 或者是 interest list。 上图中，进程483注册了fd1,fd2,fd3,fd4,fd5到epoll实例，这就是该实例对应的epoll set 或 interest list。随后，当任一描述符就绪时，就被认为在ready list中。ready list 是 interest list 的子集。 epoll_ctl函数的签名如下 12#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 各参数的解释如下： epfd——epfd是epoll_create返回的epoll实例的描述符 fd——fd是进程希望添加至 interest list 的描述符 op——op代表对要对给定fd进行的操作，支持三种操作 注册fd到epoll实例(EPOLL_CTL_ADD)，在fd上发生事件时得到通知 从epoll实例删除fd(EPOLL_CTL_DEL)，这意味着在fd上发生事件时进程不再得到通知。当一个文件描述符被关闭时，会从所有它已经注册的epoll实例上被删除 修改fd关心的事件(EPOLL_CTL_MOD) event——一个指向epoll_event的指针，代表在fd上关心的事件 epoll_event 的第一个成员是一个掩码，指示了fd要监听的事件类型 例如，如果fd是一个socket，我们会希望监听有新的数据到达（EPOLLIN），我们也希望使用et模式，那么我们就可以使用（EPOLLIN 位或 EPOLLET）。所有可能的选项可以参考All possible flgs epoll_event的第二个成员是一个union字段 epoll_wait一个线程可以通过epoll_wait系统调用来在interest set中有事件发生时得到通知，在没有事件发生时阻塞。epoll_wait的签名如下 12#include &lt;sys&#x2F;epoll.h&gt;int epoll_wait(int epfd, struct epoll_event *evlist, int maxevents, int timeout); epfd——epoll实例的描述符 evlist——一个epoll_event 的数组，evlist由调用线程分配，当epoll_wait返回时，此数组被修改来指示哪些在interest list中的描述符就绪（即ready list) maxevents——evlist的长度 timeout——指示了epoll_wait会阻塞多长时间 设置为0时，epoll_wait不阻塞，在确认interest list中的哪些描述符就绪后立即返回 设置为-1，epoll_wait永远阻塞，直到1个或更多个interest list中的描述符就绪或者被中断。在阻塞过程中，内核可能会使进程进入睡眠。 设置为非负非零数，epoll_wait会阻塞直到直到1）1个或更多个interest list中的描述符就绪。2）被中断。3）超时 epoll_wait的返回值为 出现错误 (EBADF or EINTR or EFAULT or EINVAL) ，返回-1 超时，返回0 如果1个或更多描述符就绪，返回值为evlist中的描述符数量，通过检查evlist，可以确定在哪个文件描述符上发生了什么事件 epoll的关键要理解epoll，需要先理解文件描述符是怎么工作的。 一个进程通过描述符来引用一个io流，每个进程都维护了一个描述符表，用于记录它需要访问的描述符，表中的每一行有两个字段 flags——控制文件描述符操作的标志（唯一的标志是 close on exec ） 一个指向内核中数据结构的指针 文件描述符要么被显示的创建（open, pipe, socket）等或者是从父进程中继承，通过dup/dup2系统调用也可以复制文件描述符 当以下情况时，描述符被释放： 进程退出 close系统调用 当一个进程fork时，所有的文件描述符被“复制”给子进程，如果这些描述符被标记了close-on-exec，那么在fork之后，exec之前会被关闭。父进程仍可使用这些文件描述符，但是子进程在exec之后则不可用 假设上图A进程中fd3被标记为clos-on-exec。如果A fork了 B，当fork后的一瞬间，A和B是相同的。B可以“访问”fd0，fd1，fd2，fd3。 但是fd3被标记为 close-on-exec，那么在B exec之前，这个描述符会被标记为“不活跃”，因此B也无法访问它 要真正理解这是什么意思，需要理解描述符只是属于各进程的一个指针，指向了内核中的叫做文件描述（ file description）的数据结构（太拗口，后文简称文件好了） 内核维护了一个表用于管理所有打开的文件(file description)，叫做打开文件表(open file table) 假设fd3是通过在fd0上调用dup或者fcntl得到的，那么fd0和fd3都指向内核中同一个文件。如果进程A fork 进程B，并且fd3标记为close-on-exec，那么B会继承A所有的文件描述符但是无法使用fd3。需要注意的是B中的fd0指向了内核中的同一个文件。 现在我们有进程A中的fd0,fd3，和进程B中的fd0，都指向了内核中同一个打开的文件，记住这个，这是理解epoll的关键。其他文件描述符在图中被省略了。 注意-不仅只有父子进程共享文件描述符，如果一个文件描述符通过unix socket被分享给另外一个进程，那么这两个进程也同时拥有指向内核中同一个打开文件的描述符 最终，重要的是要理解file description结构中inode指针字段的作用。 inode是文件系统的数据结构，包含了一个文件系统对象（文件或目录）的信息，包括 文件或目录 块的位置 文件或目录 的属性 其他的元信息，包括访问时间，owner（不知道怎么翻译了），权限等信息 文件系统中每一个文件（和目录）都有一个inode entry，是一个代表文件的数字，也叫inode number。在很多操作系统上，inode的最大数量有上限，也就是文件总数有上限。 在磁盘中有一个inode table，用于维护inode number和实际inode结构的映射。为了知道文件的具体位置或相关信息，内核文件系统必须访问inode table 假设在进程A fork了进程B之后，A又创建了两个文件描述符fd4和fd5，这两个文件描述符没有被B复制。假设fd5是A通过open以读方式打开abc.txt得到的，B则以写方式同样打开abc.txt，返回给B的描述符是fd10。这样，A的fd5和B的fd10指向了打开文件表中的不同文件描述，但是却指向同一个inode（即同一个文件） 这有两个非常重要的信息 A和B中的fd0指向同一个文件描述，意味着共享文件偏移量（file offset），如果A修改了偏移量（通过read(),write(),lseek())，那么偏移量的修改对B也可见。（对fd3来说也是，因为A的fd3和B的fd0指向同一文件描述） 这也适用于一个进程对打开文件状态的修改（O_ASYNC, O_NONBLOCK, O_APPEND）如果B使用fcntl对fd0设置了O_NONBLOCK，那么对于A的fd0，fd3来说会观察到非阻塞的行为。 epoll的核心假设A有两个打开的文件描述符fd0和fd1，在打开文件表中会有两个文件描述，假设这两个文件描述指向不同的inode epoll_create创建一个新的inode entry 和一个新的文件描述，返回给进程一个文件描述符，指向对应的文件描述 当使用epoll_ctl添加文件描述符（比如fd0）到epoll实例的interest list时，我们其实是把fd0的文件描述添加到epoll的interest list（这句不是很看的懂，感觉语法有问题，原文为 we’re actually fd0’s underlying file description to the epoll instance’s interest list.） 因此epoll的实例会自动监视底层的文件描述，而非属于进程的文件描述符。这有几个有趣的提示 如果进程A fork 了子进程B，B继承所有A的描述符，包括了fd9，epoll实例的描述符。然而，B的fd0,fd1,fd9仍然指向同一个内核结构（说的应该是file description），B的epoll实例与A共享interest list 如果A fork之后，创建了新的描述符fd8（没有被B继承），通过epoll_ctl添加至interest list，那么当调用epoll_wait的时候，不止有A收到fd8事件的通知 如果B也调用了epoll_wait,那么B也会收到fd8的通知。这也同样适用于通过dup/dup2或者unix socket共享epoll 描述符的情况。 假设B通过open打开fd8指向的文件，得到新的文件描述符fd15，假设A关闭了fd8。有人可能会认为既然A已经关闭了fd8，那么在调用epoll_wait的时候就不会在收到fd8的消息了。其实不是这样的。因为interest list监听了打开的文件描述(open file description)，既然fd15与fd8指向相同的文件描述，A会收到fd15的通知。只要一个文件描述符被注册到了epoll实例，在底层的文件描述仍然被至少一个其他文件描述符引用的情况下（可以是其他进程）那么这个进程将一直接收到该文件描述符的消息，即使它已经关闭了对应的文件描述符。 为什么epoll比select 和 poll性能更好如之前的文章所述，select/poll的时间复杂度是O(N)，意味着在N很大时，每一次select/poll被调用，即使只有少量的事件发生，内核仍然需要扫描所有的文件描述符 因为epoll监听了底层的文件描述，每次该文件io就绪时，内核将其添加到ready list中，而不需要等待进程调用epoll_wait。当进程调用epoll_wait时，内核不需要做任何额外的工作，只是将其维护的ready list返回即可。 此外，每次调用select/poll时，需要向内核传递我们需要监听的描述符信息（从函数签名就可以看出），内核返回各描述符对应的信息，进程需要扫描所有描述符来判断哪些描述符io就绪。 在epoll中，一旦我们使用epoll_ctl添加了文件描述符到interest list中，在epoll_wait时我们就不必再向内核传输哪些我们关心描述符，内核也只返回就绪的描述符，而不是像select/poll一样返回所有传进来的描述符。 结果就是，epoll的复杂度是O(事件发生的数量)而不是O(监听的描述符数量) 边缘触发默认的，epoll提供水平触发，每一次epoll_wait调用只返回interest list中的一个子集(ready list) 如果我们有四个文件描述符，调用epoll时只有fd2,fd3就绪了，只有这两个描述符的信息会被返回。 值得一提的是在lt模式下，描述符的属性（阻塞或非阻塞）不会影响epoll_wait的结果，因为epoll只在描述符变为就绪时更新ready list 有些时候我们只想知道一个描述符的状态(比如fd1)，而不管它是否就绪。epoll允许我们使用边缘触发。如果我们希望知道从上一次epoll_wait调用（或者从描述符创建以来）以来是否有io活动，我们可以在调用epoll_ctl注册文件描述符时或上EPOLLET标志位。 12345678910111213function Poller:register(fd, r, w) local ev = self.ev[0] ev.events = bit.bor(C.EPOLLET, C.EPOLLERR, C.EPOLLHUP) if r then ev.events = bit.bor(ev.events, C.EPOLLIN) end if w then ev.events = bit.bor(ev.events, C.EPOLLOUT) end ev.data.u64 = fd local rc = C.epoll_ctl(self.fd, C.EPOLL_CTL_ADD, fd, ev) if rc &lt; 0 then errors.get(rc):abort() endend 或许用一个例子来解释会更好。假设一个进程已经注册了4个描述符至epoll，fd3是socket。 假设在t1时刻，fd3对应的socket有数据到达 在t4时刻，进程调用了epoll_wait，如果此时fd2和fd3就绪，那么epoll_wait将报告fd2和fd3就绪 假设在t6时刻又调用了epoll_wait，并且fd1就绪，假设t4至t6之间fd3无数据到达 在水平触发模式下，epoll_wait调用会返回fd1，因为fd1是唯一就绪的。然而在边缘触发下，调用将会阻塞，因为在t4到t6之间fd3无新数据到达]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go实现schnorr签名与验证]]></title>
    <url>%2Fpost%2Fe2bab71c.html</url>
    <content type="text"><![CDATA[schnorr签名用到了椭圆曲线，使用一个椭圆曲线上的点$R$和一个常量$pk$作为私钥，那么公钥为$P=pk*G$ $G$是椭圆曲线的基点。知道$P$和$G$，是无法推出私钥的。签名时，随机选择一个$k$，计算$R=k*G$。 然后使用哈希计算要签名的消息以及$R$的哈希，然后再计算s=k+hash(R,m)*pk，发送$(R,s)$作为签名。验证时，计算s*G=R+hash(R,m)*P，看左右两边的点横坐标是否相同。因为G，R，P都是椭圆曲线上的点，所以需要调用椭圆曲线的加和乘，计算结果也在曲线上，所以也不用考虑取模了。 这里理论上来讲发过去的(R,s)应该要是512位的，但是这里的实现因为R有x,y两个坐标，各256位，还要marshal，变成了65字节，所以不能算作严谨的版本。理论上来说可以只发x，验证方可以通过x算出y来，但是不知道如何实现，只好这样折衷一下多发些字节过去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package mainimport ( "bytes" "crypto/ecdsa" "crypto/elliptic" "crypto/rand" "crypto/sha256" "fmt" "io" "math/big")func main()&#123; privkey,pubkey :=keyGeneration() msg:=sign([]byte("CSCI468/968 Advanced Network Security, Spring 2020"),privkey) verify(msg,pubkey,[]byte("CSCI468/968 Advanced Network Security, Spring 2020"))&#125;func sign(msg []byte, privkey ecdsa.PrivateKey) []byte &#123; //产生随机数 k, err := randFieldElement(privkey.Curve, rand.Reader) if err!=nil&#123; panic(err) &#125; N:=privkey.Params().N rx,ry:=privkey.Curve.ScalarBaseMult(k.Bytes())//r=k*g r:=elliptic.Marshal(privkey.Curve,rx,ry)//椭圆曲线上的点 65byte //计算message和hash c hash:=sha256.New() hash.Write(msg) hash.Write(r) //hash结果转int用于计算 c:=hashToInt(hash.Sum(nil),privkey.Curve)//32bytes //a*c ac:=new(big.Int) ac.Mul(privkey.D,c)//64bytes //返回值 s:=new(big.Int) s.Add(k,ac) s.Mod(s,N)//32bytes var res bytes.Buffer res.Write(r) res.Write(s.Bytes()) return res.Bytes()//64bytes&#125;//checkfunc verify(rs []byte, pubkey ecdsa.PublicKey,msg[]byte) &#123; r := rs[:65] //r rx,ry:=elliptic.Unmarshal(pubkey.Curve,r) s := rs[65:] //s leftx,_:=pubkey.ScalarBaseMult(s) hash := sha256.New() hash.Write(msg) hash.Write(r) c := hashToInt(hash.Sum(nil), pubkey.Curve) cpx,cpy:=pubkey.ScalarMult(pubkey.X,pubkey.Y,c.Bytes()) rightx,_:=pubkey.Curve.Add(rx,ry,cpx,cpy) if leftx.Cmp(rightx)==0 &#123; fmt.Println("verify passed") &#125;else&#123; fmt.Println("verify failed") &#125;&#125;func keyGeneration()(ecdsa.PrivateKey, ecdsa.PublicKey)&#123; privKey ,err :=ecdsa.GenerateKey(elliptic.P256(),rand.Reader) if err != nil &#123; panic(err) &#125; pubKey :=privKey.PublicKey return *privKey,pubKey&#125;var one = new(big.Int).SetInt64(1)func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error) &#123; params := c.Params() b := make([]byte, params.BitSize/8+8) _, err = io.ReadFull(rand, b) if err != nil &#123; return &#125; k = new(big.Int).SetBytes(b) n := new(big.Int).Sub(params.N, one) k.Mod(k, n) k.Add(k, one) return&#125;func hashToInt(hash []byte, c elliptic.Curve) *big.Int &#123; orderBits := c.Params().N.BitLen() orderBytes := (orderBits + 7) / 8 if len(hash) &gt; orderBytes &#123; hash = hash[:orderBytes] &#125; ret := new(big.Int).SetBytes(hash) excess := len(hash)*8 - orderBits if excess &gt; 0 &#123; ret.Rsh(ret, uint(excess)) &#125; return ret&#125;]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>schnorr</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 68. Text Justification]]></title>
    <url>%2Fpost%2F857cd720.html</url>
    <content type="text"><![CDATA[题目链接：https://leetcode.com/problems/text-justification/ 题目大意给出一串单词和每行宽度，要求在单词中塞入空格使之两端对齐并且排版每行为指定宽度。其中每行应该尽可能多的放入单词，单词间的空格应平均分配。无法平分时，左边空格数大于右边空格。最后一行左对齐。 思路首先遍历所有单词，找出应在一行的单词。依次判断当前行能否塞下下个单词即可。需要注意加入新的单词就意味着至少有一个空格，应把空格加入当前行的长度计算。 确定好每行的单词后，就开始往里塞空格。先平均分配空格，然后计算多余的空格，加在左边的单词中间。然后最后一行因为是左对齐，单独处理就行了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123; int maxlen=words.size(); vector&lt;vector&lt;string&gt;&gt; lines(maxlen); vector&lt;string&gt; result; int linelen[maxlen]; fill(linelen,linelen+maxlen,0); int cur=0,len=0; for(int i=0;i&lt;maxlen;)&#123; if(words[i].length()+len&lt;=maxWidth)&#123; lines[cur].push_back(words[i]); len+=words[i].length(); len++; linelen[cur]+=words[i].length(); i++; &#125;else&#123; cur++; len=0; &#125; &#125; for(int i=0;i&lt;cur;i++)&#123; int spaces=maxWidth-linelen[i]; int avgspace,addup; if(lines[i].size()&gt;1)&#123; avgspace=spaces/(lines[i].size()-1); addup=spaces-avgspace*(lines[i].size()-1); &#125; else&#123; avgspace=spaces; addup=0; &#125; string line="",sp=""; for(int j=0;j&lt;avgspace;j++) sp+=" "; for(int j=0;j&lt;lines[i].size();j++)&#123; line+=lines[i][j]; if(j!=lines[i].size()-1||j==0) line+=sp; if(addup&gt;0)&#123; line+=" "; addup--; &#125; &#125; result.push_back(line); &#125; string line=""; for(int i=0;i&lt;lines[cur].size();i++)&#123; line+=lines[cur][i]; if(i!=lines[cur].size()-1) line+=" "; &#125; for(int i=line.size();i&lt;maxWidth;i++) line+=" "; result.push_back(line); return result; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰器模式]]></title>
    <url>%2Fpost%2F17760895.html</url>
    <content type="text"><![CDATA[假如有一块蛋糕，如果只涂奶油，其他什么都不加，就是奶油蛋糕。加上草莓，就是草莓奶油蛋糕。如果再加巧克力，再用白色巧克力写上姓名，插上代表年龄的蜡烛，就成了生日蛋糕。 像这样不断为对象添加装饰的设计模式被称为装饰器模式。 类图： Display类是可以显示多行字符串的抽象类。StringDisplay继承了Display，用于显示单行字符串，相当于核心蛋糕。 Border类也是Display的子类，代表装饰的边框。其中有一个Display的实例。又由于代表装饰的类和代表蛋糕的类都是Display的实例，这样就可以一层又一层的装饰。 代码： 12345678910public abstract class Display &#123; public abstract int getColumns(); // 获取横向字符数 public abstract int getRows(); // 获取纵向行数 public abstract String getRowText(int row); // 获取第row行的字符串 public void show() &#123; // 全部显示 for (int i = 0; i &lt; getRows(); i++) &#123; System.out.println(getRowText(i)); &#125; &#125;&#125; 12345678910111213141516171819public class StringDisplay extends Display &#123; private String string; // 要显示的字符串 public StringDisplay(String string) &#123; // 通过参数传入要显示的字符串 this.string = string; &#125; public int getColumns() &#123; // 字符数 return string.getBytes().length; &#125; public int getRows() &#123; // 行数是1 return 1; &#125; public String getRowText(int row) &#123; // 仅当row为0时返回值 if (row == 0) &#123; return string; &#125; else &#123; return null; &#125; &#125;&#125; 123456public abstract class Border extends Display &#123; protected Display display; // 表示被装饰物 protected Border(Display display) &#123; // 在生成实例时通过参数指定被装饰物 this.display = display; &#125;&#125; 123456789101112131415161718192021222324252627public class FullBorder extends Border &#123; public FullBorder(Display display) &#123; super(display); &#125; public int getColumns() &#123; // 字符数为被装饰物的字符数加上两侧边框字符数 return 1 + display.getColumns() + 1; &#125; public int getRows() &#123; // 行数为被装饰物的行数加上上下边框的行数 return 1 + display.getRows() + 1; &#125; public String getRowText(int row) &#123; // 指定的那一行的字符串 if (row == 0) &#123; // 上边框 return "+" + makeLine('-', display.getColumns()) + "+"; &#125; else if (row == display.getRows() + 1) &#123; // 下边框 return "+" + makeLine('-', display.getColumns()) + "+"; &#125; else &#123; // 其他边框 return "|" + display.getRowText(row - 1) + "|"; &#125; &#125; private String makeLine(char ch, int count) &#123; // 生成一个重复count次字符ch的字符串 StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; count; i++) &#123; buf.append(ch); &#125; return buf.toString(); &#125;&#125; 12345678910111213141516public class SideBorder extends Border &#123; private char borderChar; // 表示装饰边框的字符 public SideBorder(Display display, char ch) &#123; // 通过构造函数指定Display和装饰边框字符 super(display); this.borderChar = ch; &#125; public int getColumns() &#123; // 字符数为字符串字符数加上两侧边框字符数 return 1 + display.getColumns() + 1; &#125; public int getRows() &#123; // 行数即被装饰物的行数 return display.getRows(); &#125; public String getRowText(int row) &#123; // 指定的那一行的字符串为被装饰物的字符串加上两侧的边框的字符 return borderChar + display.getRowText(row) + borderChar; &#125;&#125; 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Display b1 = new StringDisplay("Hello, world."); Display b2 = new SideBorder(b1, '#'); Display b3 = new FullBorder(b2); b1.show(); b2.show(); b3.show(); Display b4 = new SideBorder( new FullBorder( new FullBorder( new SideBorder( new FullBorder( new StringDisplay("hello") ), '*' ) ) ), '/' ); b4.show(); &#125;&#125; 结果： 很显然，Java的IO就用到了装饰器模式。 缺点： 装饰器模式的一个缺点是会导致程序中增加许多功能类似的很小的类]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2Fpost%2F34ace952.html</url>
    <content type="text"><![CDATA[在文件系统中，有文件夹概念。文件夹里可以放文件，也可以继续放文件夹。虽然文件和文件夹不同，但是在操作系统中都看作同一种对象看待（目录条目）。组合模式就是用于创造出这样结构的模式，能够使容器与内容具有一致性，创造出递归结构。 类图： 这里Entry是表示目录条目的抽象类，File代表文件，Directory类代表目录，都继承Entry。Directory中有一个存放ArrayList&lt;Entry&gt; directory，这样就可以在这个ArrayList中存放文件或文件夹。 代码实现也不放了，体会设计模式就好。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2Fpost%2F99c8c8b1.html</url>
    <content type="text"><![CDATA[策略模式使我们可以整体的替换算法的实现部分，轻松的以不同的算法去解决同一个问题。 类图： 这里书上的代码还是比较复杂的，就不放了，搞清楚各类之间的关系，体会设计模式即可。Hand类是用来表示石头剪刀布游戏手势的类。Strategy代表出手的策略。WinningStrategy代表出如果上一轮赢了，就继续出，输了就随机出的策略。ProbStrategy选择过去的结果中胜率最大的手势来出。具体的实现就不放了。Player代表玩家，生成实例时需要传入姓名和所使用策略的实例。在Main函数中可以方便的生成两个使用不同策略的Player进行游戏。 策略模式就是这样，具体的代码可以参考《图解设计模式》中所给代码，可以在图灵社区的网站上找到。顺便再提一句，由于lambda表达式的存在，Java8中可以轻易的实现策略模式。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之桥接模式]]></title>
    <url>%2Fpost%2Fbd19161c.html</url>
    <content type="text"><![CDATA[桥接模式的作用是将类的功能层次结构和类的实现层次结构连接起来 假设现在有个Something类，当我们想向它添加新功能时，可以编写一个它的子类，然后在子类中添加新的功能。这样就构成了类的功能结构。 当我们定义了一个抽象类，子类负责去实现这些抽象方法时，也形成了一个层次结构，这就叫类的实现层次结构。注意这里功能并没有增加，子类是为了具体实现抽象父类定义的方法。 试想有一个笔类，我们可以继承笔类，并向其添加画圆、画方等功能，这就是功能层次结构。假如我们要选择笔的颜色，那么我们可以在子类中添加方法来画出不同颜色的圆、方。现在我们要添加新功能画三角形，假设有12种颜色，那么为了添加这一个功能，又得重复写换颜色的12个方法。或者我们想添加新的颜色，那么又得修改所有的子类。这里功能层次结构和实现层次结构混杂在一起，难以扩展。 桥接模式可以将类的功能层次结构和类的实现层次结构分离。做到可以独立的修改功能及实现。 类图： 右边，CountDisplay继承Display，并添加了新的功能，这就是功能层次结构。 左边，StringDisplayImpl实现了DisplayImpl中的方法，这是类的实现层次结构。 这里Display类持有一个DisplayImpl的实例。这就连接了功能层次结构和实现层次结构。这样就可以独立的添加功能或者添加实现了。 代码：1234567891011121314151617181920public class Display &#123; private DisplayImpl impl; public Display(DisplayImpl impl) &#123; this.impl = impl; &#125; public void open() &#123; impl.rawOpen(); &#125; public void print() &#123; impl.rawPrint(); &#125; public void close() &#123; impl.rawClose(); &#125; public final void display() &#123; open(); print(); close(); &#125;&#125;123456789101112public class CountDisplay extends Display &#123; public CountDisplay(DisplayImpl impl) &#123; super(impl); &#125; public void multiDisplay(int times) &#123; // 循环显示times次 open(); for (int i = 0; i &lt; times; i++) &#123; print(); &#125; close(); &#125;&#125;12345public abstract class DisplayImpl &#123; public abstract void rawOpen(); public abstract void rawPrint(); public abstract void rawClose();&#125;123456789101112131415161718192021222324public class StringDisplayImpl extends DisplayImpl &#123; private String string; // 要显示的字符串 private int width; // 以字节单位计算出的字符串的宽度 public StringDisplayImpl(String string) &#123; // 构造函数接收要显示的字符串string this.string = string; // 将它保存在字段中 this.width = string.getBytes().length; // 把字符串的宽度也保存在字段中，以供使用。 &#125; public void rawOpen() &#123; printLine(); &#125; public void rawPrint() &#123; System.out.println("|" + string + "|"); // 前后加上"|"并显示 &#125; public void rawClose() &#123; printLine(); &#125; private void printLine() &#123; System.out.print("+"); // 显示用来表示方框的角的"+" for (int i = 0; i &lt; width; i++) &#123; // 显示width个"-" System.out.print("-"); // 将其用作方框的边框 &#125; System.out.println("+"); // 显示用来表示方框的角的"+" &#125;&#125;1234567891011public class Main &#123; public static void main(String[] args) &#123; Display d1 = new Display(new StringDisplayImpl("Hello, China.")); Display d2 = new CountDisplay(new StringDisplayImpl("Hello, World.")); CountDisplay d3 = new CountDisplay(new StringDisplayImpl("Hello, Universe.")); d1.display(); d2.display(); d3.display(); d3.multiDisplay(5); &#125;&#125; 结果：]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2Fpost%2F1ef33906.html</url>
    <content type="text"><![CDATA[在抽象工厂模式中，不仅有抽象工厂，还有抽象零件和抽象产品。抽象工厂的作用是将抽象零件组装为抽象产品。 类图： 这里大约分为3部分。左上角Item类是抽象的零件，便于统一处理Tray和Link，使其具有可替换性。ListLink和ListTray是具体的零件。ListTray是具有多个Link的集合。 右上角的Page是抽象的产品，代表一个页面。页面上有许多Item(可以是Link或者TrayLink)。ListPage是具体的产品，实现了MakeHTML()方法。 左下角Factory是抽象工厂，ListFactory是具体工厂，用于创建一个列表风格的页面。 结果： 代码：123456789101112131415161718package factory;public abstract class Factory &#123; public static Factory getFactory(String classname) &#123; Factory factory = null; try &#123; factory = (Factory)Class.forName(classname).newInstance(); &#125; catch (ClassNotFoundException e) &#123; System.err.println("没有找到 " + classname + "类。"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return factory; &#125; public abstract Link createLink(String caption, String url); public abstract Tray createTray(String caption); public abstract Page createPage(String title, String author);&#125; 123456789package factory;public abstract class Item &#123; protected String caption; public Item(String caption) &#123; this.caption = caption; &#125; public abstract String makeHTML();&#125; 123456789package factory;public abstract class Link extends Item &#123; protected String url; public Link(String caption, String url) &#123; super(caption); this.url = url; &#125;&#125; 123456789101112package factory;import java.util.ArrayList;public abstract class Tray extends Item &#123; protected ArrayList tray = new ArrayList(); public Tray(String caption) &#123; super(caption); &#125; public void add(Item item) &#123; tray.add(item); &#125;&#125; 12345678910111213141516171819202122232425262728package factory;import java.io.*;import java.util.ArrayList;public abstract class Page &#123; protected String title; protected String author; protected ArrayList content = new ArrayList(); public Page(String title, String author) &#123; this.title = title; this.author = author; &#125; public void add(Item item) &#123; content.add(item); &#125; public void output() &#123; try &#123; String filename = title + ".html"; Writer writer = new FileWriter(filename); writer.write(this.makeHTML()); writer.close(); System.out.println(filename + " 编写完成。"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public abstract String makeHTML();&#125; 1234567891011121314package listfactory;import factory.*;public class ListFactory extends Factory &#123; public Link createLink(String caption, String url) &#123; return new ListLink(caption, url); &#125; public Tray createTray(String caption) &#123; return new ListTray(caption); &#125; public Page createPage(String title, String author) &#123; return new ListPage(title, author); &#125;&#125; 1234567891011package listfactory;import factory.*;public class ListLink extends Link &#123; public ListLink(String caption, String url) &#123; super(caption, url); &#125; public String makeHTML() &#123; return " &lt;li&gt;&lt;a href=\"" + url + "\"&gt;" + caption + "&lt;/a&gt;&lt;/li&gt;\n"; &#125;&#125; 1234567891011121314151617181920212223package listfactory;import factory.*;import java.util.Iterator;public class ListTray extends Tray &#123; public ListTray(String caption) &#123; super(caption); &#125; public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append("&lt;li&gt;\n"); buffer.append(caption + "\n"); buffer.append("&lt;ul&gt;\n"); Iterator it = tray.iterator(); while (it.hasNext()) &#123; Item item = (Item)it.next(); buffer.append(item.makeHTML()); &#125; buffer.append("&lt;/ul&gt;\n"); buffer.append("&lt;/li&gt;\n"); return buffer.toString(); &#125;&#125; 12345678910111213141516171819202122232425package listfactory;import factory.*;import java.util.Iterator;public class ListPage extends Page &#123; public ListPage(String title, String author) &#123; super(title, author); &#125; public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append("&lt;html&gt;&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n"); buffer.append("&lt;body&gt;\n"); buffer.append("&lt;h1&gt;" + title + "&lt;/h1&gt;\n"); buffer.append("&lt;ul&gt;\n"); Iterator it = content.iterator(); while (it.hasNext()) &#123; Item item = (Item)it.next(); buffer.append(item.makeHTML()); &#125; buffer.append("&lt;/ul&gt;\n"); buffer.append("&lt;hr&gt;&lt;address&gt;" + author + "&lt;/address&gt;"); buffer.append("&lt;/body&gt;&lt;/html&gt;\n"); return buffer.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839import factory.*;public class Main &#123; public static void main(String[] args) &#123; if (args.length != 1) &#123; System.out.println("Usage: java Main class.name.of.ConcreteFactory"); System.out.println("Example 1: java Main listfactory.ListFactory"); System.out.println("Example 2: java Main tablefactory.TableFactory"); System.exit(0); &#125; Factory factory = Factory.getFactory(args[0]); Link people = factory.createLink("人民日报", "http://www.people.com.cn/"); Link gmw = factory.createLink("光明日报", "http://www.gmw.cn/"); Link us_yahoo = factory.createLink("Yahoo!", "http://www.yahoo.com/"); Link jp_yahoo = factory.createLink("Yahoo!Japan", "http://www.yahoo.co.jp/"); Link excite = factory.createLink("Excite", "http://www.excite.com/"); Link google = factory.createLink("Google", "http://www.google.com/"); Tray traynews = factory.createTray("日报"); traynews.add(people); traynews.add(gmw); Tray trayyahoo = factory.createTray("Yahoo!"); trayyahoo.add(us_yahoo); trayyahoo.add(jp_yahoo); Tray traysearch = factory.createTray("检索引擎"); traysearch.add(trayyahoo); traysearch.add(excite); traysearch.add(google); Page page = factory.createPage("LinkPage", "杨文轩"); page.add(traynews); page.add(traysearch); page.output(); &#125;&#125; 增加新的工厂如果只用到ListFactory，那就使用抽象工厂模式没有意义了。假如现在需要一个表格格式的页面，那么就可以使用抽象工厂模式整体的替换工厂、产品、零件。 类图： 具体的代码就不上了，体会这种思想即可。 结果： 与工厂模式的区别：抽象工厂模式多了一个零件的层级，而工厂模式产出产品。假如有一个汽车工厂，生产多个品牌的车，这时就需要抽象工厂模式。因为汽车由发动机、底盘、变速箱等部件组成。每生产一个具体品牌的车就整体替换工厂、产品、零件。又假如有一家供应商向汽车厂供应零部件比如挡风玻璃，那么使用工厂模式即可，产出适合不同品牌的挡风玻璃。 缺点难以增加具体的零件。以本题例子，假如现在需要在网页中增加一个图片零件，那么就需要添加新的代表图片的类，更改所有的具体工厂才行。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式]]></title>
    <url>%2Fpost%2F722e57af.html</url>
    <content type="text"><![CDATA[有些时候很难一次性组装具有复杂结构的实例，用于组装复杂结构实例的模式就是建造者模式。 类图： 这里Builder类声明了编写文档的方法，具体实现交由其子类。HTMLBuilder和TextBuilder继承了Builder，用于生成html网页和普通文本。Director持有一个Builder的实例，用于指挥构造文本。Main函数利用Director来生成文档。 代码： 123456public abstract class Builder &#123; public abstract void makeTitle(String title); public abstract void makeString(String str); public abstract void makeItems(String[] items); public abstract void close();&#125; 123456789101112131415161718192021222324252627282930313233import java.io.*;public class HTMLBuilder extends Builder &#123; private String filename; // 文件名 private PrintWriter writer; // 用于编写文件的PrintWriter public void makeTitle(String title) &#123; // HTML文件的标题 filename = title + ".html"; // 将标题作为文件名 try &#123; writer = new PrintWriter(new FileWriter(filename)); // 生成 PrintWriter &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"); // 输出标题 writer.println("&lt;h1&gt;" + title + "&lt;/h1&gt;"); &#125; public void makeString(String str) &#123; // HTML文件中的字符串 writer.println("&lt;p&gt;" + str + "&lt;/p&gt;"); // 用&lt;p&gt;标签输出 &#125; public void makeItems(String[] items) &#123; // HTML文件中的条目 writer.println("&lt;ul&gt;"); // 用&lt;ul&gt;和&lt;li&gt;输出 for (int i = 0; i &lt; items.length; i++) &#123; writer.println("&lt;li&gt;" + items[i] + "&lt;/li&gt;"); &#125; writer.println("&lt;/ul&gt;"); &#125; public void close() &#123; // 完成文档 writer.println("&lt;/body&gt;&lt;/html&gt;"); // 关闭标签 writer.close(); // 关闭文件 &#125; public String getResult() &#123; // 编写完成的文档 return filename; // 返回文件名 &#125;&#125; 123456789101112131415161718192021public class Director &#123; private Builder builder; public Director(Builder builder) &#123; // 因为接收的参数是Builder类的子类 this.builder = builder; // 所以可以将其保存在builder字段中 &#125; public void construct() &#123; // 编写文档 builder.makeTitle("Greeting"); // 标题 builder.makeString("从早上至下午"); // 字符串 builder.makeItems(new String[]&#123; // 条目 "早上好。", "下午好。", &#125;); builder.makeString("晚上"); // 其他字符串 builder.makeItems(new String[]&#123; // 其他条目 "晚上好。", "晚安。", "再见。", &#125;); builder.close(); // 完成文档 &#125;&#125; Director类中持有的是Buider实例，并不关心是TextBuilder或者是HTMLBuilder，因此可以任意替换具体的Builder，而可以任意替换正是设计模式的目标。 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; if (args.length != 1) &#123; usage(); System.exit(0); &#125; if (args[0].equals("plain")) &#123; TextBuilder textbuilder = new TextBuilder(); Director director = new Director(textbuilder); director.construct(); String result = textbuilder.getResult(); System.out.println(result); &#125; else if (args[0].equals("html")) &#123; HTMLBuilder htmlbuilder = new HTMLBuilder(); Director director = new Director(htmlbuilder); director.construct(); String filename = htmlbuilder.getResult(); System.out.println(filename + "文件编写完成。"); &#125; else &#123; usage(); System.exit(0); &#125; &#125; public static void usage() &#123; System.out.println("Usage: java Main plain 编写纯文本文档"); System.out.println("Usage: java Main html 编写HTML文档"); &#125;&#125; Main函数对于具体的构造文本过程同样一无所知，只是调用了Director的construct()方法。Director修改时，Main函数可以保持不变。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2Fpost%2F7a86e223.html</url>
    <content type="text"><![CDATA[在有些时候，我们不能根据类来生成实例，而要根据现有的实例来生成新的实例 对象种类繁多，无法将它们整合到一个类中时 难以根据类生成实例时 想解耦框架与生成的实例时 这种不根据类来生成实例，而是根据实例来生成新实例的模式就是原型模式。 类图: Product继承了Java的Cloneable接口，声明了use和createClone方法。UnderlinePen实现Product接口，将字符串加上下划线并显示。MessageBox实现Product接口，将字符串放入方框并显示。 代码: 12345678910111213package framework;import java.util.*;public class Manager &#123; private HashMap showcase = new HashMap(); public void register(String name, Product proto) &#123; showcase.put(name, proto); &#125; public Product create(String protoname) &#123; Product p = (Product)showcase.get(protoname); return p.createClone(); &#125;&#125; Manager使用hashmap来保存名字与实例。注意并没有出现具体的UnderlinePen和MessageBox。 1234567891011121314151617181920212223242526272829import framework.*;public class MessageBox implements Product &#123; private char decochar; public MessageBox(char decochar) &#123; this.decochar = decochar; &#125; public void use(String s) &#123; int length = s.getBytes().length; for (int i = 0; i &lt; length + 4; i++) &#123; System.out.print(decochar); &#125; System.out.println(""); System.out.println(decochar + " " + s + " " + decochar); for (int i = 0; i &lt; length + 4; i++) &#123; System.out.print(decochar); &#125; System.out.println(""); &#125; public Product createClone() &#123; Product p = null; try &#123; p = (Product)clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return p; &#125;&#125; MessageBox将字符串放入方框。在createClone()中实现复制自身。UnderlinePen类与此类似，不放代码了。 12345678910111213141516171819202122import framework.*;public class Main &#123; public static void main(String[] args) &#123; // 准备 Manager manager = new Manager(); UnderlinePen upen = new UnderlinePen('~'); MessageBox mbox = new MessageBox('*'); MessageBox sbox = new MessageBox('/'); manager.register("strong message", upen); manager.register("warning box", mbox); manager.register("slash box", sbox); // 生成 Product p1 = manager.create("strong message"); p1.use("Hello, world."); Product p2 = manager.create("warning box"); p2.use("Hello, world."); Product p3 = manager.create("slash box"); p3.use("Hello, world."); &#125;&#125; 感觉给出的例子不是很典型，也就勉勉强强符合第三点吧。以后在使用中再加深理解。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2Fpost%2F1a4b62fe.html</url>
    <content type="text"><![CDATA[当想达到以下目的时： 想确保任何情况下都绝对只有1个实例 想在程序上表现出只存在一个实例 就可以使用单例模式。 代码: 123456789public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton() &#123; System.out.println("生成了一个实例。"); &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 注意singleton被声明为static，而且被初始化为Singleton的实例。这样就在类被加载时初始化，且只进行一次。构造函数被声明为private，防止构造函数被外部调用。 单例模式还有其他写法，这里展示的是饿汉式。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2Fpost%2Fbf53f1b3.html</url>
    <content type="text"><![CDATA[将模版模式用于生成实例，就演变为工厂模式。在工厂模式中，父类决定实例的生成方式，但并不决定要生成的具体的类，具体生成交由子类负责，这就将生成实例的框架和负责实际生成实例的类解耦。 代码： 1234567891011package framework;public abstract class Factory &#123; public final Product create(String owner) &#123; Product p = createProduct(owner); registerProduct(p); return p; &#125; protected abstract Product createProduct(String owner); protected abstract void registerProduct(Product product);&#125; 12345package framework;public abstract class Product &#123; public abstract void use();&#125; framework包中定义了抽象工厂和抽象产品。注意抽象工厂定义了create方法，这就是模版。具体创造产品、注册产品则交给子类去实现。请注意create方法中使用createProduct而不是new来生产产品，这就避免了抽象工厂类与具体的类耦合。 12345678910111213141516package idcard;import framework.*;public class IDCard extends Product &#123; private String owner; IDCard(String owner) &#123; System.out.println("制作" + owner + "的ID卡。"); this.owner = owner; &#125; public void use() &#123; System.out.println("使用" + owner + "的ID卡。"); &#125; public String getOwner() &#123; return owner; &#125;&#125; 12345678910111213141516package idcard;import framework.*;import java.util.*;public class IDCardFactory extends Factory &#123; private List owners = new ArrayList(); protected Product createProduct(String owner) &#123; return new IDCard(owner); &#125; protected void registerProduct(Product product) &#123; owners.add(((IDCard)product).getOwner()); &#125; public List getOwners() &#123; return owners; &#125;&#125; idcard包中则是具体的工厂及产品。IDCard实现了use方法。IDCardFactory则实现了createProduct和registerProduct方法。 framework包中完全没有出现idcard包及其中各类，这就意味着如果需要增加新的产品（比如电视），那么只需要创建新的电视包，编写生产电视的工厂和具体电视，framework包则完全不需要更改。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模版模式]]></title>
    <url>%2Fpost%2F7c6bcde5.html</url>
    <content type="text"><![CDATA[父类定义了程序的模版，子类实现抽象方法并决定具体的处理，这种模式就是模版模式。 类图： 代码： 123456789101112public abstract class AbstractDisplay &#123; // 抽象类AbstractDisplay public abstract void open(); // 交给子类去实现的抽象方法(1) open public abstract void print(); // 交给子类去实现的抽象方法(2) print public abstract void close(); // 交给子类去实现的抽象方法(3) close public final void display() &#123; // 本抽象类中实现的display方法 open(); // 首先打开… for (int i = 0; i &lt; 5; i++) &#123; // 循环调用5次print print(); &#125; close(); // …最后关闭。这就是display方法所实现的功能 &#125;&#125; 123456789101112131415public class CharDisplay extends AbstractDisplay &#123; // CharDisplay是AbstractDisplay的子类 private char ch; // 需要显示的字符 public CharDisplay(char ch) &#123; // 构造函数中接收的字符被 this.ch = ch; // 保存在字段中 &#125; public void open() &#123; // 在父类中是抽象方法，此处重写该方法 System.out.print("&lt;&lt;"); // 显示开始字符"&lt;&lt;" &#125; public void print() &#123; // 同样地重写print方法。该方法会在display中被重复调用 System.out.print(ch); // 显示保存在字段ch中的字符 &#125; public void close() &#123; // 同样地重写close方法 System.out.println("&gt;&gt;"); // 显示结束字符"&gt;&gt;" &#125;&#125; 123456789101112131415161718192021222324public class StringDisplay extends AbstractDisplay &#123; // StringDisplay也是AbstractDisplay的子类 private String string; // 需要显示的字符串 private int width; // 以字节为单位计算出的字符串长度 public StringDisplay(String string) &#123; // 构造函数中接收的字符串被 this.string = string; // 保存在字段中 this.width = string.getBytes().length; // 同时将字符串的字节长度也保存在字段中，以供后面使用 &#125; public void open() &#123; // 重写的open方法 printLine(); // 调用该类的printLine方法画线 &#125; public void print() &#123; // print方法 System.out.println("|" + string + "|"); // 给保存在字段中的字符串前后分别加上"|"并显示出来 &#125; public void close() &#123; // close方法 printLine(); // 与open方法一样，调用printLine方法画线 &#125; private void printLine() &#123; // 被open和close方法调用。由于可见性是private，因此只能在本类中被调用 System.out.print("+"); // 显示表示方框的角的"+" for (int i = 0; i &lt; width; i++) &#123; // 显示width个"-" System.out.print("-"); // 组成方框的边框 &#125; System.out.println("+"); // /显示表示方框的角的"+" &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; AbstractDisplay d1 = new CharDisplay('H'); // 生成一个持有'H'的CharDisplay类的实例 AbstractDisplay d2 = new StringDisplay("Hello, world."); // 生成一个持有"Hello, world."的StringDisplay类的实例 AbstractDisplay d3 = new StringDisplay("你好，世界。"); // 生成一个持有"你好，世界。"的StringDisplay类的实例 d1.display(); // 由于d1、d2和d3都是AbstractDisplay类的子类 d2.display(); // 可以调用继承的display方法 d3.display(); // 实际的程序行为取决于CharDisplay类和StringDisplay类的具体实现 &#125;&#125; 这里AbstractDisplay是抽象类，其中只有display()是定义好的，作为模版。CharDisplay和StringDisplay类实现AbstractDisplay，定义了各自的open()、print()、close()方法。Main函数输出如下： 可以看到，CharDisplay和StringDisplay的输出不同，但是模式是固定的，都是输出一个起始字符串，然后重复给定字符串5次，然后输出结束字符串。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模版模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2Fpost%2F796a0e79.html</url>
    <content type="text"><![CDATA[在编程时，经常会出现现有程序无法直接使用，需要做适当的变换之后才能使用的情况。这种用于填补”现有程序”和”所需程序”之间的差异的设计模式就是适配器模式。 适配器模式有两种： 类适配器模式（使用继承） 对象适配器模式（使用委托） 使用继承的适配器类图： 代码： 1234567public class Main &#123; public static void main(String[] args) &#123; Print p = new PrintBanner("Hello"); p.printWeak(); p.printStrong(); &#125;&#125; 123456789101112public class Banner &#123; private String string; public Banner(String string) &#123; this.string = string; &#125; public void showWithParen() &#123; System.out.println("(" + string + ")"); &#125; public void showWithAster() &#123; System.out.println("*" + string + "*"); &#125;&#125; 1234567891011public class PrintBanner extends Banner implements Print &#123; public PrintBanner(String string) &#123; super(string); &#125; public void printWeak() &#123; showWithParen(); &#125; public void printStrong() &#123; showWithAster(); &#125;&#125; 这里Banner是现有的类,Print接口是我们要用的接口，PrintBanner实现此接口。Main函数中，使用Print接口定义的方法来输出信息。注意实际上用的是实现了Print接口的PrintBanner中的方法，PrintBanner又是继承自Banner，其printWeak()方法和printStrong()都是调用的Banner中的函数。这样就使得Main函数在完全不知道Banner存在的情况下，使用了Banner中的两个方法。就像给笔记本电脑充电，适配器连接了插座和电脑，而电脑完全不关心插座上是多少伏的电压。 使用委托的适配器使用委托的适配器，PrintBanner与Banner间不再有继承关系，转为PrintBanner持有一个Banner，并把操作委托给Banner。 代码 123456789101112public class PrintBanner extends Print &#123; private Banner banner; public PrintBanner(String string) &#123; this.banner = new Banner(string); &#125; public void printWeak() &#123; banner.showWithParen(); &#125; public void printStrong() &#123; banner.showWithAster(); &#125;&#125;]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2Fpost%2F1cfae984.html</url>
    <content type="text"><![CDATA[当在java中遍历一个数组时，可以使用下标的方式。但是当底层存储结构变化时（比如换成链表），这种方式就不管用了。通过将循环变量i抽象化、通用化后形成迭代器，这样就可以通用于各种存储结构。这种模式就叫做迭代器模式。 类图如下： Aggregate代表集合接口，这里BookShelf实现此接口，代表书架。Iterator接口代表迭代器，BookShelfIterator实现此接口，代表书架迭代器。 代码： 1234567891011121314151617181920public class BookShelf implements Aggregate &#123; private Book[] books; private int last = 0; public BookShelf(int maxsize) &#123; this.books = new Book[maxsize]; &#125; public Book getBookAt(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; this.books[last] = book; last++; &#125; public int getLength() &#123; return last; &#125; public Iterator iterator() &#123; return new BookShelfIterator(this); &#125;&#125; 1234567891011121314151617181920public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; public boolean hasNext() &#123; if (index &lt; bookShelf.getLength()) &#123; return true; &#125; else &#123; return false; &#125; &#125; public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; 注意BookShelf中iterator()方法的返回值是Iterator，只要实现了这个接口都可以作为返回值，这就降低了耦合性。给出的代码只是正常迭代，实际上可以反着迭代，跳着迭代等各种花式迭代。如果有Main函数需要迭代书架，也只需得到迭代器即可，而不用管BookShelf中到底是怎么存放书本的。如果BookShelf需要更改存储方式，那么main函数也完全不用变。]]></content>
      <categories>
        <category>图解设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT完结撒花&总结]]></title>
    <url>%2Fpost%2F7b44d484.html</url>
    <content type="text"><![CDATA[从3月份开始，现在快5月底了，终于刷完了PAT甲级的所有题（其实还有一题1057 stack，不过那题用到树状数组什么的，不准备做了）。目前排名153，满分的有139人。花了大概两个半月时间，其中经历了研究生复试，五一，毕设等大小事，刷的有快也有慢，好歹算是做完了。原本打算毕业前刷完的，现在大概还剩了一个月左右的时间，算是超额完成吧。说起来其实很惭愧，大二大三就应该做这些事的，混到快毕业了才刷完。 总的感受就是PAT甲级也没那么难。考来考去也就是二叉树、dijkstra、深搜这些东西。只有少量的题是拿到手完全没思路的，很多题稍微改改就成了另一题。动态规划几乎没有（即便有的话也可以不用动态规划解决）。说白了就是考熟练度罢了。当然其中有些题还是比较坑的，有些是测试点坑，有些是时间空间限制很严格，不一而足。测试点坑的，上网找坑点，时间限制严格的，把cin/cout换成printf/scanf往往有奇效。整套刷下来代码能力提升还是很大的。 最近打算开的新坑：Leetcode，playframework，设计模式。加油吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1151 LCA in a Binary Tree (30 分)]]></title>
    <url>%2Fpost%2F11d58264.html</url>
    <content type="text"><![CDATA[1151 LCA in a Binary Tree (30 分)The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. Given any two nodes in a binary tree, you are supposed to find their LCA. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. Output Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found.. Sample Input:1234567896 87 2 3 4 6 5 1 85 3 7 2 6 4 8 12 68 17 912 -30 899 99 Sample Output:123456LCA of 2 and 6 is 3.8 is an ancestor of 1.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. 作者: CHEN, Yue 单位: 浙江大学 时间限制: 1000 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一棵二叉树的前中序遍历，要求判断给定两个结点的最近公共祖先 分析类似1143 Lowest Common Ancestor (30 分)，但是因为不是二叉搜索树，所以不能那样做。 可以dfs记录路径，然后判断路径上出现分叉的点。 或者递归在左右子树中查找。lca在root中寻找a,b。如果root对应结点等于a或b，返回当前结点。否则在左右子树中查找a,b。左右都找到了返回当前结点，如果仅在一边找到那么返回找到的那一个子树。 代码dfs代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;using namespace std;int n,m,a,b,found;vector&lt;int&gt; pre,in,patha,pathb,temp;struct node&#123; int x; node* left; node* right;&#125;;node* root;node* buildtree(int ins,int ine,int pres,int pree)&#123; if(ins&gt;=ine||pres&gt;=pree) return nullptr; node* cur=new node; cur-&gt;x=pre[pres]; int i=ins; while(in[i]!=pre[pres])i++; cur-&gt;left=buildtree(ins, i, pres+1, pres+i-ins+1); cur-&gt;right=buildtree(i+1, ine, pres+i-ins+1, pree); return cur;&#125;void dfs(node* cur,int val,int a)&#123; if(found) return; if(cur-&gt;x==val)&#123; found=1; temp.push_back(val); if(a==1) patha=temp; else pathb=temp; &#125; temp.push_back(cur-&gt;x); if(cur-&gt;left!=nullptr) dfs(cur-&gt;left,val,a); if(cur-&gt;right!=nullptr) dfs(cur-&gt;right,val,a); temp.pop_back(); return;&#125;int main() &#123; cin&gt;&gt;m&gt;&gt;n; pre.resize(n); in.resize(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i]; root=buildtree(0, n, 0, n); for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; temp.clear(); patha.clear(); found=0; dfs(root, a, 1); found=0; temp.clear(); pathb.clear(); dfs(root, b, 0); if(patha.size()==0||pathb.size()==0)&#123; if(patha.size()==0&amp;&amp;pathb.size()==0) printf("ERROR: %d and %d are not found.\n",a,b); else if(patha.size()==0) printf("ERROR: %d is not found.\n",a); else printf("ERROR: %d is not found.\n",b); &#125;else&#123; int i=0; for(;i&lt;patha.size()&amp;&amp;i&lt;pathb.size();i++)&#123; if(patha[i]!=pathb[i]) break; &#125; if(i==patha.size()) printf("%d is an ancestor of %d.\n",a,b); else if(i==pathb.size()) printf("%d is an ancestor of %d.\n",b,a); else printf("LCA of %d and %d is %d.\n",a,b,patha[i-1]); &#125; &#125; return 0;&#125;递归代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;using namespace std;int n,m,a,b;vector&lt;int&gt; pre,in;struct node&#123; int x; node* left; node* right;&#125;;node* root;node* buildtree(int ins,int ine,int pres,int pree)&#123; if(ins&gt;=ine||pres&gt;=pree) return nullptr; node* cur=new node; cur-&gt;x=pre[pres]; int i=ins; while(in[i]!=pre[pres])i++; cur-&gt;left=buildtree(ins, i, pres+1, pres+i-ins+1); cur-&gt;right=buildtree(i+1, ine, pres+i-ins+1, pree); return cur;&#125;node* lca(node* root,int a,int b)&#123; if(root==nullptr) return nullptr; if(root-&gt;x==a||root-&gt;x==b) return root; node* left=lca(root-&gt;left,a,b); node* right=lca(root-&gt;right,a,b); if(left&amp;&amp;right) return root; return left==nullptr?right:left;&#125;int main() &#123; cin&gt;&gt;m&gt;&gt;n; pre.resize(n); in.resize(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i]; root=buildtree(0, n, 0, n); for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; int fda=0,fdb=0; for(int i=0;i&lt;n;i++)&#123; if(a==in[i]) fda=1; if(b==in[i]) fdb=1; if(fda&amp;&amp;fdb) break; &#125; if(!fda||!fdb)&#123; if(!fda&amp;&amp;!fdb) printf("ERROR: %d and %d are not found.\n",a,b); else if(!fda) printf("ERROR: %d is not found.\n",a); else printf("ERROR: %d is not found.\n",b); &#125;else&#123; node* temp=lca(root,a,b); if(temp-&gt;x==a||temp-&gt;x==b) printf("%d is an ancestor of %d.\n",temp-&gt;x==a?a:b,temp-&gt;x==a?b:a); else printf("LCA of %d and %d is %d.\n",a,b,temp-&gt;x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1148 Werewolf - Simple Version (20 分)]]></title>
    <url>%2Fpost%2F13dba318.html</url>
    <content type="text"><![CDATA[1148 Werewolf - Simple Version (20 分)Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: “Player #2 is a werewolf.”; player #2 said: “Player #3 is a human.”; player #3 said: “Player #4 is a werewolf.”; player #4 said: “Player #5 is a human.”; and player #5 said: “Player #4 is a human.”. Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (5≤N≤100). Then N lines follow and the i-th line gives the statement of the i-th player (1≤i≤N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification:If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence — that is, for two sequences A=a[1],…,a[M] and B=b[1],…,b[M], if there exists 0≤k&lt;M such that a[i]=b[i] (i≤k) and a[k+1]&lt;b[k+1], then Ais said to be smaller than B. In case there is no solution, simply print No Solution. Sample Input 1:1234565-2+3-4+5+4 Sample Output 1:11 4 Sample Input 2:12345676+6+3+1-5-2+4 Sample Output 2 (the solution is not unique):11 5 Sample Input 3:1234565-2-3-4-5-1 Sample Output 3:1No Solution 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意一群人在玩狼人杀，其中有两个狼人。然后所有人发言，其中一个平民一个狼人说谎了，求哪两个是狼人。 分析算是比较新颖的题目，只能暴力解决。使用say保存各人说的话，player记录身份，1为平民，-1为狼人。遍历狼人位置，其他位置上的都是平民。然后判断该局面是否合法。规则如下： k从1至n，如果say[k]0，但是player[say[k]]&lt;0，同样说谎。如果说谎的平民和狼人各1人，那么输出i，j 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;cmath&gt;using namespace std;int n,flag;vector&lt;int&gt; say;int liewolf,lienormal;int main() &#123; cin&gt;&gt;n; say.resize(n+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;say[i]; for(int i=1;i&lt;n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; lienormal=0; liewolf=0; vector&lt;int&gt; player(n+1,1); player[i]=-1; player[j]=-1; for(int k=1;k&lt;=n;k++)&#123; //第k个人说谎 if(say[k]&lt;0&amp;&amp;player[abs(say[k])]==1)&#123; if(player[k]&gt;0)//判断说谎者身份 lienormal++; else liewolf++; &#125; if(say[k]&gt;0&amp;&amp;player[say[k]]==-1)&#123;//说谎 if(player[k]&lt;0)//判断身份 liewolf++; else lienormal++; &#125; &#125; if(lienormal==1&amp;&amp;liewolf==1)&#123; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; return 0; &#125; &#125; &#125; cout&lt;&lt;"No Solution"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1146 Topological Order (25 分)]]></title>
    <url>%2Fpost%2Fc1734d68.html</url>
    <content type="text"><![CDATA[1146 Topological Order (25 分)This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space. Output Specification:Print in a line all the indices of queries which correspond to “NOT a topological order”. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer. Sample Input:1234567891011121314156 81 21 35 25 42 32 63 46 451 5 2 3 6 45 1 2 6 3 45 1 2 3 6 45 2 1 6 3 41 2 3 4 5 6 Sample Output:13 4 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个有向图，要求判断所给序列是否为拓扑排序 分析用in,out记录对应出入关系。对于给出的序列，判断其入度是否为0，然后删除该点的出边。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;cmath&gt;using namespace std;int n,m,k,t,first;vector&lt;set&lt;int&gt;&gt; out;vector&lt;set&lt;int&gt;&gt; in;vector&lt;int&gt; temp;int main() &#123; cin&gt;&gt;n&gt;&gt;m; out.resize(n+1); in.resize(n+1); int a,b; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; out[a].insert(b); in[b].insert(a); &#125; cin&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; vector&lt;set&lt;int&gt;&gt; tout=out; vector&lt;set&lt;int&gt;&gt; tin=in; temp.clear(); for(int j=0;j&lt;n;j++)&#123; cin&gt;&gt;t; temp.push_back(t); &#125; for(int i=0;i&lt;n;i++)&#123; if(tin[temp[i]].size()!=0)&#123; first++==0?cout&lt;&lt;"":cout&lt;&lt;" "; cout&lt;&lt;j; break; &#125; for(int k:tout[temp[i]]) tin[k].erase(temp[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1145 Hashing - Average Search Time (25 分)]]></title>
    <url>%2Fpost%2F2c6cf17c.html</url>
    <content type="text"><![CDATA[1145 Hashing - Average Search Time (25 分)The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification:Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more than 104. Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more than 105. Output Specification:For each test case, in case it is impossible to insert some number, print in a line X cannot be inserted. where X is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place. Sample Input:1234 5 410 6 4 15 1111 4 15 2 Sample Output:1215 cannot be inserted.2.8 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意要求计算平方探测哈希表的平均查询长度 分析首先表的大小要换成比给定尺寸大的第一个素数。然后使用平方探测插入，只有正数，1,4,9这样的。查询时，计算位置，如果是该位置上是该数说明找到了，或0说明此数不在表中。 坑点：如果没找到，次数会比表长大1，这个不是很理解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int msize,n,m,t;vector&lt;int&gt; table;bool isprime(int k)&#123; if(k==2||k==3) return true; for(int j=2;j&lt;=sqrt(k);j++) if(k%j==0) return false; return true;&#125;int getprimes(int size)&#123; for(int i=size;;i++)&#123; if(isprime(i)) return i; &#125;&#125;int main() &#123; cin&gt;&gt;msize&gt;&gt;n&gt;&gt;m; msize=getprimes(msize); table.resize(msize); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; int flag=0; for(int j=0;j&lt;msize;j++)&#123; int pos=(t+j*j)%msize; if(table[pos]==0)&#123; table[pos]=t; flag=1; break; &#125; &#125; if(flag==0) cout&lt;&lt;t&lt;&lt;" cannot be inserted."&lt;&lt;endl; &#125; int sum=0; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;t; int cnt=1; for(int j=0;j&lt;msize;j++)&#123; int pos=(t+j*j)%msize; if(table[pos]==t||table[pos]==0) break; cnt++; &#125; sum+=cnt; &#125; printf("%.1f\n",sum*1.0/m);&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1143 Lowest Common Ancestor (30 分)]]></title>
    <url>%2Fpost%2Fda3b8444.html</url>
    <content type="text"><![CDATA[1143 Lowest Common Ancestor (30 分)The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. A binary search tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Given any two nodes in a BST, you are supposed to find their LCA. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. Output Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found.. Sample Input:123456786 86 3 1 2 5 4 8 72 58 71 912 -30 899 99 Sample Output:123456LCA of 2 and 5 is 3.8 is an ancestor of 7.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一棵二叉树，求给定两个结点的最近公共祖先。 分析一开始想用记录父结点的办法，但是结点值会有重复，无法实现。后来在网上看到，因为已经给出了先序遍历，只要按照先序遍历依次判断。假设当前结点为a，如果u,v都小于a，那么最近公共祖先必在a左子树上。同理，大于a则在右子树。如果a正好大于等于其中一个小于等于另一个，那么a则为最近公共祖先。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int m,n,head;map&lt;int,int&gt; showup;vector&lt;int&gt; pre;int main() &#123; cin&gt;&gt;m&gt;&gt;n; int t; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; showup[t]=1; pre.push_back(t); &#125; int u,v; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;u&gt;&gt;v; int a; for(int j=0;j&lt;pre.size();j++)&#123; a=pre[j]; if((a&gt;=u&amp;&amp;a&lt;=v)||(a&gt;=v&amp;&amp;a&lt;=u)) break; &#125; if(showup[u]==0&amp;&amp;showup[v]==0) printf("ERROR: %d and %d are not found.\n", u, v); else if(showup[u]==0) printf("ERROR: %d is not found.\n", u); else if(showup[v]==0) printf("ERROR: %d is not found.\n", v); else if(a==u||a==v) printf("%d is an ancestor of %d.\n", a, a == u ? v : u); else printf("LCA of %d and %d is %d.\n", u, v, a); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1139 First Contact (30 分)]]></title>
    <url>%2Fpost%2F76cadf29.html</url>
    <content type="text"><![CDATA[1139 First Contact (30 分)Unlike in nowadays, the way that boys and girls expressing their feelings of love was quite subtle in the early years. When a boy A had a crush on a girl B, he would usually not contact her directly in the first place. Instead, he might ask another boy C, one of his close friends, to ask another girl D, who was a friend of both B and C, to send a message to B — quite a long shot, isn’t it? Girls would do analogously. Here given a network of friendship relations, you are supposed to help a boy or a girl to list all their friends who can possibly help them making the first contact. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (1 &lt; N ≤ 300) and M, being the total number of people and the number of friendship relations, respectively. Then M lines follow, each gives a pair of friends. Here a person is represented by a 4-digit ID. To tell their genders, we use a negative sign to represent girls. After the relations, a positive integer K (≤ 100) is given, which is the number of queries. Then K lines of queries follow, each gives a pair of lovers, separated by a space. It is assumed that the first one is having a crush on the second one. Output Specification:For each query, first print in a line the number of different pairs of friends they can find to help them, then in each line print the IDs of a pair of friends. If the lovers A and B are of opposite genders, you must first print the friend of A who is of the same gender of A, then the friend of B, who is of the same gender of B. If they are of the same gender, then both friends must be in the same gender as theirs. It is guaranteed that each person has only one gender. The friends must be printed in non-decreasing order of the first IDs, and for the same first ones, in increasing order of the seconds ones. Sample Input:1234567891011121314151617181920212223242510 18-2001 1001-2002 -20011004 1001-2004 -2001-2003 10051005 -20011001 -20031002 10011002 -2004-2004 10011003 -2002-2003 10031004 -2002-2001 -20031001 10031003 -20011002 -2001-2002 -200351001 -2001-2003 10011005 -2001-2002 -20041111 -2003 Sample Output:123456789101112131441002 20041003 20021003 20031004 200242001 10022001 10032002 10032002 1004012003 20010 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一堆人中的朋友关系。然后给出两人A，B。A要追B，必须找他的一个同性好友C，然后C要找B的一个同性好友D，并且CD是朋友关系。给出AB，问可能的中间人。 分析因为只中转两次，所以没必要dfs之类的了。找到A，B的同性朋友，然后判断A的朋友和B的朋友是否认识即可。存储某人的朋友用邻接表，判断两人是否认识用邻接矩阵。 注意A可能直接认识B，所以要排除。然后输入会有-0000的，注意此时的性别判断。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int n,m,k;vector&lt;int&gt; r[10000];struct node&#123; int v1; int v2; node(int v1,int v2):v1(v1),v2(v2)&#123;&#125;&#125;;vector&lt;node&gt; res;int isfrds[10000][10000];map&lt;int,int&gt; girl;bool cmp(node n1,node n2)&#123; return n1.v1!=n2.v1?n1.v1&lt;n2.v1:n1.v2&lt;n2.v2;&#125;int main() &#123; scanf("%d %d",&amp;n,&amp;m); string s1,s2; int a,b; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;s1&gt;&gt;s2; if(s1[0]=='-')&#123; a=stoi(s1.substr(1,s1.length()-1)); girl[a]=1; &#125;else a=stoi(s1); if(s2[0]=='-')&#123; b=stoi(s2.substr(1,s2.length()-1)); girl[b]=1; &#125;else b=stoi(s2); r[a].push_back(b); r[b].push_back(a); isfrds[a][b]=isfrds[b][a]=1; &#125; cin&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; res.clear(); scanf("%d %d",&amp;a,&amp;b); a=abs(a); b=abs(b); for(int afrds:r[a])&#123; if(girl[a]==girl[afrds]&amp;&amp;afrds!=b)&#123; for(int bfrds:r[b])&#123; if(girl[b]==girl[bfrds]&amp;&amp;bfrds!=a)&#123; if(isfrds[afrds][bfrds]==1)&#123; node t(afrds,bfrds); res.push_back(t); &#125; &#125; &#125; &#125; &#125; sort(res.begin(),res.end(),cmp); cout&lt;&lt;res.size()&lt;&lt;endl; for(auto v:res)&#123; printf("%04d %04d\n",v.v1,v.v2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1135 Is It A Red-Black Tree (30 分)]]></title>
    <url>%2Fpost%2Fb7852df8.html</url>
    <content type="text"><![CDATA[1135 Is It A Red-Black Tree (30 分)There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black. (2) The root is black. (3) Every leaf (NULL) is black. (4) If a node is red, then both its children are black. (5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes. For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not. Figure 1 Figure 2 Figure 3 For each given binary search tree, you are supposed to tell if it is a legal red-black tree. Input Specification:Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3. Output Specification:For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not. Sample Input:1234567397 -2 1 5 -4 -11 8 14 -15911 -2 1 -7 5 -4 8 14 -15810 -7 5 -6 8 15 -11 17 Sample Output:123YesNoNo 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一棵二叉树的前序遍历，要求判断是否为红黑树。红黑树的规则如下： 所有结点非红即黑 根结点为黑色 叶子结点（NULL结点）为黑色。 红色结点的孩子都是黑色 对于每一个结点，其到叶子结点的所有路径含有相同数目的黑色结点 分析首先建立出树。使用map标记为红色的结点。判断是否为红黑树，主要判断2、4、5性质。首先判断根结点是否黑色。然后从根结点dfs，遇到红结点判断其孩子颜色是否全黑。然后判断左右子树上黑结点数是否相同。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int k,n,is;map&lt;int,int&gt;neg;vector&lt;int&gt; pre,in;struct node&#123; int v; node* left; node* right;&#125;;node* buildtree(int pres,int pree,int ins,int ine)&#123; if(pres&gt;=pree||ins&gt;=ine) return nullptr; int cur=pre[pres]; node* root=new node; int i=ins; while(i&lt;ine&amp;&amp;in[i]!=cur)i++; root-&gt;v=cur; root-&gt;left=buildtree(pres+1, pres+i-ins+1, ins, i); root-&gt;right=buildtree(pres+i-ins+1, pree, i+1, ine); return root;&#125;int dfs(node* root)&#123;//返回黑色结点的数量 if(is==0)//已经不是红黑树，返回 return 0; if(root==nullptr) return 1;//null结点为黑色 if(neg[root-&gt;v]==1)&#123;//判断红色结点孩子颜色 if(root-&gt;left&amp;&amp;neg[root-&gt;left-&gt;v]==1) is=0; if(root-&gt;right&amp;&amp;neg[root-&gt;right-&gt;v]==1) is=0; &#125; int leftb=dfs(root-&gt;left); int rightb=dfs(root-&gt;right); if(leftb!=rightb)//判断左右路径黑结点数是否相同 is=0; if(neg[root-&gt;v]==0) return leftb+1;//此结点为黑色，黑结点数量+1 else return leftb;&#125;int main() &#123; cin&gt;&gt;k; node* root; while(k--)&#123; pre.clear(); in.clear(); neg.clear(); cin&gt;&gt;n; int t; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; if(t&lt;0)&#123; t=-t; neg[t]=1; &#125; pre.push_back(t); &#125; in=pre; sort(in.begin(),in.end()); root=buildtree(0,n,0,n); //is为全局变量，标记是否为红黑树 is=1; if(neg[root-&gt;v]==1) is=0; if(is) dfs(root); if(is) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1134 Vertex Cover (25 分)]]></title>
    <url>%2Fpost%2F7dd39019.html</url>
    <content type="text"><![CDATA[1134 Vertex Cover (25 分)A vertex cover of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. Now given a graph with several vertex sets, you are supposed to tell if each of them is a vertex cover or not. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than 104), being the total numbers of vertices and the edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge. After the graph, a positive integer K (≤ 100) is given, which is the number of queries. Then K lines of queries follow, each in the format: N**v v[1] v[2]⋯v[N**v] where N**v is the number of vertices in the set, and v[i]’s are the indices of the vertices. Output Specification:For each query, print in a line Yes if the set is a vertex cover, or No if not. Sample Input:12345678910111213141516171810 118 76 84 58 48 11 21 49 89 11 02 454 0 3 8 46 6 1 7 5 4 93 1 8 42 2 87 9 8 7 6 5 4 2 Sample Output:12345NoYesYesNoNo 作者: CHEN, Yue 单位: 浙江大学 时间限制: 600 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意题目比较难懂。给出一个图，然后给出k个集合。要求判断图的每一条边的两个端点是否至少有一个属于对应集合。 分析存储边，用set存储集合（set的查找速度更快）。然后使用visit数组保存已经查询过的顶点。每次遍历图的所有边，先判断两个端点是否已查询过，都无则在set中查询，更新visit。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int n,m,k;int v[10000][10000],visit[10000];struct edge&#123; int a; int b; edge()&#123;&#125;; edge(int a,int b):a(a),b(b)&#123;&#125;;&#125;;vector&lt;edge&gt; edges;int main() &#123; scanf("%d %d",&amp;n,&amp;m); int a,b; for(int i=0;i&lt;m;i++)&#123; scanf("%d %d",&amp;a,&amp;b); edge e(a,b); edges.push_back(e); &#125; scanf("%d",&amp;k); set&lt;int&gt; s; int is; for(int i=0;i&lt;k;i++)&#123; is=1; scanf("%d",&amp;a); fill(visit,visit+10000,0); s.clear(); for(int j=0;j&lt;a;j++)&#123; scanf("%d",&amp;b); s.insert(b); &#125; for(int i=0;i&lt;edges.size();i++)&#123; a=edges[i].a; b=edges[i].b; if(visit[a]||visit[b])continue; if(s.find(a)!=s.end()) visit[a]=1; if(s.find(b)!=s.end()) visit[b]=1; if(visit[a]!=1&amp;&amp;visit[b]!=1) is=0; if(!is) break; &#125; if(is) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1131 Subway Map (30 分)]]></title>
    <url>%2Fpost%2F3f8c2492.html</url>
    <content type="text"><![CDATA[1131 Subway Map (30 分)In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 100), the number of subway lines. Then N lines follow, with the i-th (i=1,⋯,N) line describes the i-th subway line in the format: M S[1] S[2] … S[M] where M (≤ 100) is the number of stops, and S[i]’s (i=1,⋯,M) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order — that is, the train travels between S[i] and S[i+1] (i=1,⋯,M−1) without any stop. Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called “transfer stations”), no station can be the conjunction of more than 5 lines. After the description of the subway, another positive integer K (≤ 10) is given. Then K lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively. The following figure shows the sample map. Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers. Output Specification:For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following: 123Take Line#X1 from S1 to S2.Take Line#X2 from S2 to S3....... where Xi‘s are the line numbers and Si‘s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed. If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique. Sample Input:12345678947 1001 3212 1003 1204 1005 1306 77979 9988 2333 1204 2006 2005 2004 2003 2302 200113 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 30114 6666 8432 4011 130633011 30136666 20012004 3001 Sample Output:123456789102Take Line#3 from 3011 to 3013.10Take Line#4 from 6666 to 1306.Take Line#3 from 1306 to 2302.Take Line#2 from 2302 to 2001.6Take Line#2 from 2004 to 1204.Take Line#1 from 1204 to 1306.Take Line#3 from 1306 to 3001. 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出地铁线路图，要求输出两站之间的最短换乘路径。如果最短路径相同，选择换乘次数最小的。 分析之前没碰到过类似的题，比较棘手。可以使用dfs，遍历所有的路径选择满足条件的。 使用vector数组v，存储第i个结点能到达的车站。line数组存储两站之间的路线。遍历时将路径暂存至tempath，至终点时与path比较，选择较好的路径。输出结果时，计算路径上相邻两点的线路，与之前线路不同则为一次换乘。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n,k,a,b,mintransf,visit[10000],mincnt;vector&lt;int&gt; v[10000];vector&lt;int&gt; path,tempath;int line[10000][10000];int getransf()&#123; int cnt=0,preline,curline; preline=line[tempath[0]][tempath[1]]; for(int i=2;i&lt;tempath.size();i++)&#123; curline=line[tempath[i-1]][tempath[i]]; if(curline!=preline)&#123; cnt++; preline=curline; &#125; &#125; return cnt;&#125;void dfs(int cur,int cnt)&#123; if(cur==b)&#123; int transf=getransf();//得到换乘数 if(cnt&lt;mincnt||(cnt==mincnt&amp;&amp;transf&lt;mintransf))&#123; path=tempath; mintransf=transf; mincnt=cnt; &#125; return; &#125; for(int i:v[cur])&#123; if(!visit[i])&#123; visit[i]=1; tempath.push_back(i); dfs(i,cnt+1); tempath.pop_back(); visit[i]=0; &#125; &#125;&#125;void printpath()&#123; printf("%d\n",path.size()-1); int preline=line[path[0]][path[1]]; int last=a; int curline; for(int i=2;i&lt;path.size();i++)&#123; curline=line[path[i-1]][path[i]]; if(curline!=preline)&#123; printf("Take Line#%d from %04d to %04d.\n",preline,last,path[i-1]); preline=curline; last=path[i-1]; &#125; &#125; printf("Take Line#%d from %04d to %04d.\n",preline,last,path.back());&#125;int main() &#123; cin&gt;&gt;n; int m,cur,pre; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;m; pre=-1; for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;cur; if(pre!=-1)&#123; v[pre].push_back(cur); v[cur].push_back(pre); line[cur][pre]=i; line[pre][cur]=i; &#125; pre=cur; &#125; &#125; cin&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; tempath.clear(); mincnt=99999999; cin&gt;&gt;a&gt;&gt;b; visit[a]=1; tempath.push_back(a); dfs(a,0);//搜索 visit[a]=0; printpath();//输出结果 &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1129 Recommendation System (25 分)]]></title>
    <url>%2Fpost%2F2e7b6d48.html</url>
    <content type="text"><![CDATA[1129 Recommendation System (25 分)Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user’s preference by the number of times that an item has been accessed by this user. Input Specification:Each input file contains one test case. For each test case, the first line contains two positive integers: N (≤ 50,000), the total number of queries, and K (≤ 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing — for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space. Output Specification:For each case, process the queries one by one. Output the recommendations for each query in a line in the format: 1query: rec[1] rec[2] ... rec[K] where query is the item that the user is accessing, and rec[i] (i=1, … K) is the i-th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order. Note: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query. Sample Input:1212 33 5 7 5 5 3 2 1 8 3 8 12 Sample Output:12345678910115: 37: 3 55: 3 5 75: 5 3 73: 5 3 72: 5 3 71: 5 3 28: 5 3 13: 5 3 18: 3 5 112: 3 5 8 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出客户的n个查询，以及最大推荐数k。要求客户查询时，向其推荐之前查询次数最多的k个商品。查询次数相同时，输出序号小的。 分析利用一个showup数组记录id的出现次数。再用set数组times，记录出现次数为i的id。每次读入数字，计算最大出现次数，更新times。然后从times[maxtime]开始，输出k个数字即可。这题卡时间非常严重，一定要使用scanf/printf。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int n,k,maxtime;int showup[50001];set&lt;int&gt; times[50001];int main() &#123; scanf("%d %d",&amp;n,&amp;k); int q; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;q); if(i!=0)&#123; int c=0; cout&lt;&lt;q&lt;&lt;":"; for(int t=maxtime;t&gt;0;t--)&#123; for(int x:times[t])&#123; printf(" %d",x); c++; if(c==k) break; &#125; if(c==k) break; &#125; printf("\n"); &#125; int prev=showup[q]++; int t=showup[q]; if(t&gt;maxtime) maxtime=t; times[prev].erase(q); times[t].insert(q); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1127 ZigZagging on a Tree (30 分)]]></title>
    <url>%2Fpost%2Fdc8e0946.html</url>
    <content type="text"><![CDATA[1127 ZigZagging on a Tree (30 分)Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” — that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output Specification:For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input:123812 11 20 17 1 15 8 512 20 17 11 15 8 5 1 Sample Output:11 11 5 8 17 12 20 15 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一棵树的后序中序遍历，要求输出z字型层序遍历（即一层左向右，下一层右向左这样） 分析先根据后序中序构造出树。然后层序遍历，根据层数判断方向。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;vector&lt;int&gt; post,in;struct node&#123; int v; node* left; node* right;&#125;;node* build(int is,int ie,int ps,int pe)&#123; if(ps&gt;pe||is&gt;ie) return nullptr; int x=post[pe]; int mid=is; while(in[mid]!=x)mid++; node* root=new node; root-&gt;v=x; root-&gt;left=build(is,mid-1,ps,ps+mid-is-1); root-&gt;right=build(mid+1,ie,ps+mid-is,pe-1); return root;&#125;int main() &#123; cin&gt;&gt;n; post.resize(n); in.resize(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i]; node* root=build(0, n-1, 0, n-1); deque&lt;node*&gt; q; vector&lt;node*&gt; vec; q.push_back(root); int l=0,first=0; while(!q.empty())&#123; l++; int size=q.size(); if(size==0) break; vec.clear(); for(int i=0;i&lt;size;i++)&#123; node* temp=q.front(); q.pop_front(); if(temp-&gt;left) q.push_back(temp-&gt;left); if(temp-&gt;right) q.push_back(temp-&gt;right); vec.push_back(temp); &#125; if(l%2==0) for(int i=0;i&lt;size;i++)&#123; first++==0?cout&lt;&lt;"":cout&lt;&lt;" "; cout&lt;&lt;vec[i]-&gt;v; &#125; else for(int i=size-1;i&gt;=0;i--)&#123; first++==0?cout&lt;&lt;"":cout&lt;&lt;" "; cout&lt;&lt;vec[i]-&gt;v; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1123 Is It a Complete AVL Tree (30 分)]]></title>
    <url>%2Fpost%2F2540e7b9.html</url>
    <content type="text"><![CDATA[1123 Is It a Complete AVL Tree (30 分)An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print YES if the tree is complete, or NO if not. Sample Input 1:12588 70 61 63 65 Sample Output 1:1270 63 88 61 65YES Sample Input 2:12888 70 61 96 120 90 65 68 Sample Output 2:1288 65 96 61 70 90 120 68NO 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一串数字，要求构造一颗avl树。然后中序遍历，判断是否为完全二叉树。 分析如何建立avl树，参考1066 Root of AVL Tree （25 分) 遍历时，flag记录是否有结点已经不满。如果flag==1，且之后结点有了孩子，则不是一颗完全二叉树。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1122 Hamiltonian Cycle (25 分)]]></title>
    <url>%2Fpost%2F3c26fb76.html</url>
    <content type="text"><![CDATA[1122 Hamiltonian Cycle (25 分)The “Hamilton cycle problem” is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a “Hamiltonian cycle”. In this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers N (2&lt;N≤200), the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format Vertex1 Vertex2, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format: n V1 V2 … V**n where n is the number of vertices in the list, and V**i‘s are the vertices on a path. Output Specification:For each query, print in a line YES if the path does form a Hamiltonian cycle, or NO if not. Sample Input:1234567891011121314151617186 106 23 41 52 53 14 11 66 31 24 567 5 1 4 3 6 2 56 5 1 4 3 6 29 6 2 1 6 3 4 5 2 64 1 2 5 17 6 1 3 4 5 2 67 6 1 2 5 4 3 1 Sample Output:123456YESNONONOYESNO 作者: CHEN, Yue 单位: 浙江大学 时间限制: 300 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个图，要求判断一个环是否是Hamiltonian cycle。题目对这个定义说得挺不清楚的。其实就是必须是简单环（除起点终点不能重复）而且图中所有点都要访问一次。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n,m,k;int visited[202];int g[202][202];int main() &#123; cin&gt;&gt;n&gt;&gt;m; int v1,v2; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;v1&gt;&gt;v2; g[v1][v2]=1; g[v2][v1]=1; &#125; cin&gt;&gt;k; int c; for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;c; int first,cur,pre,t; bool iscycle=true; fill(visited,visited+202,0); for(int j=0;j&lt;c;j++)&#123; cin&gt;&gt;t; visited[t]++; if(j==0)&#123; first=t; pre=t; &#125; else&#123; cur=t; if(g[pre][cur]==0) iscycle=false; pre=cur; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i!=first&amp;&amp;visited[i]!=1) iscycle=false; if(i==first&amp;&amp;visited[i]!=2) iscycle=false; &#125; if(cur!=first) iscycle=false; iscycle?cout&lt;&lt;"YES":cout&lt;&lt;"NO"; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1121 Damn Single (25 分)]]></title>
    <url>%2Fpost%2F463d9db3.html</url>
    <content type="text"><![CDATA[1121 Damn Single (25 分)“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID’s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (≤ 10,000) followed by M ID’s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (重婚) or dangling with more than one companion. Output Specification:First print in a line the total number of lonely guests. Then in the next line, print their ID’s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line. Sample Input:123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 Sample Output:12510000 23333 44444 55555 88888 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出情侣的名单以及聚会的名单，要求找出聚会中的单身狗。纯单身狗以及伴侣没出现的都算单身狗。 分析用match数组保存情侣配对关系，map party记录聚会中出现的人。对于聚会上的每一个人，查找match数组得其情侣，然后在party中查找是否在场。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n,q,temp;int match[100000];map&lt;int,int&gt; party;int main() &#123; fill(match,match+100000,-1); cin&gt;&gt;n; int a,b; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a&gt;&gt;b; match[a]=b; match[b]=a; &#125; cin&gt;&gt;q; for(int i=0;i&lt;q;i++)&#123; cin&gt;&gt;temp; party[temp]=1; &#125; vector&lt;int&gt; single; for(auto it:party)&#123; if(match[it.first]==-1||party[match[it.first]]==0) single.push_back(it.first); &#125; cout&lt;&lt;single.size()&lt;&lt;endl; for(int i=0;i&lt;single.size();i++)&#123; if(i!=0) printf(" "); printf("%05d",single[i]); &#125; return 0;&#125; 其他这题最后不能输出多余空行，否则测试点1格式错误。然而1101 Quick Sort （25 分)里面必须输出空行。。无语了]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1119 Pre- and Post-order Traversals (30 分)]]></title>
    <url>%2Fpost%2F3f8b0bdd.html</url>
    <content type="text"><![CDATA[1119 Pre- and Post-order Traversals (30 分)Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique. Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output Specification:For each test case, first printf in a line Yes if the tree is unique, or No if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 1:12371 2 3 4 6 7 52 6 7 4 5 3 1 Sample Output 1:12Yes2 1 6 4 7 3 5 Sample Input 2:12341 2 3 42 4 3 1 Sample Output 2:12No2 1 3 4 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一棵树的前序及后序遍历，判断二叉树是否唯一，并输出其中序遍历。如果不唯一，输出任一情况。 分析考虑根结点只有一个孩子的情况，只给出前后序是无法判断该子树是左子树还是右子树的。当出现这种情况时，即为不唯一，又因为输出任一情况即可，为编程方便统一当作右子树处理。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;bool uniq=true;vector&lt;int&gt; pre,in,post;void findres(int pres,int pree,int posts,int poste)&#123;//左闭右开 if(pres+1==pree)&#123; in.push_back(pre[pres]); return; &#125; int i=pres; while(pres&lt;pree&amp;&amp;pre[i]!=post[poste-2])i++;//前序遍历中找到右孩子的位置 if(i-pres&gt;1)//如果存在左子树 findres(pres+1,i,posts,posts+i-pres-1); else uniq=false; in.push_back(pre[pres]);//在中序遍历中加入根结点 findres(i,pree,posts+i-pres-1,poste-1);//遍历右子树&#125;int main() &#123; cin&gt;&gt;n; int t; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; pre.push_back(t); &#125; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; post.push_back(t); &#125; findres(0,n,0,n); if(!uniq) cout&lt;&lt;"No"; else cout&lt;&lt;"Yes"; cout&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; if(i!=0)cout&lt;&lt;" "; cout&lt;&lt;in[i]; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1118 Birds in Forest (25 分)]]></title>
    <url>%2Fpost%2F10b5211a.html</url>
    <content type="text"><![CDATA[1118 Birds in Forest (25 分)Some scientists took pictures of thousands of birds in a forest. Assume that all the birds appear in the same picture belong to the same tree. You are supposed to help the scientists to count the maximum number of trees in the forest, and for any pair of birds, tell if they are on the same tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive number N (≤104) which is the number of pictures. Then N lines follow, each describes a picture in the format: K B1 B2 … B**K where K is the number of birds in this picture, and B**i‘s are the indices of birds. It is guaranteed that the birds in all the pictures are numbered continuously from 1 to some number that is no more than 104. After the pictures there is a positive number Q (≤104) which is the number of queries. Then Q lines follow, each contains the indices of two birds. Output Specification:For each test case, first output in a line the maximum possible number of trees and the number of birds. Then for each query, print in a line Yes if the two birds belong to the same tree, or No if not. Sample Input:1234567843 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 Sample Output:1232 10YesNo 作者: CHEN, Yue 单位: 浙江大学 时间限制: 150 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出森林中鸟的照片，出现在同一张照片的鸟是同一颗树上的。求有几棵树，以及鸟的总数。然后给出任两只鸟，要求判断是否同一颗树。 分析并查集，每次都与照片中出现的第一只鸟合并。注意必须降低树的深度，否则测试点4会超时。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;int par[10010],showup[10010],tshowup[10010];int findpar(int x)&#123; int t=x; while(x!=par[x]) x=par[x]; while(par[t]!=x)&#123; int temp=par[t]; par[t]=x; t=temp; &#125; return x;&#125;void makeunion(int a,int b)&#123; int pa=findpar(a); int pb=findpar(b); par[pa]=pb;&#125;int main() &#123; int k,t,q; cin&gt;&gt;n; for(int i=0;i&lt;10010;i++)&#123; par[i]=i; &#125; for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; cin&gt;&gt;t; showup[t]=1; if(j==0) x=t; else makeunion(x, t); &#125; &#125; int sum=0,tsum=0; for(int i=0;i&lt;10010;i++)&#123; if(showup[i])&#123; sum++; tshowup[findpar(i)]=1; &#125; &#125; for(int i=0;i&lt;10010;i++) tsum+=tshowup[i]; cout&lt;&lt;tsum&lt;&lt;" "&lt;&lt;sum&lt;&lt;endl; cin&gt;&gt;q; int b1,b2; for(int i=0;i&lt;q;i++)&#123; cin&gt;&gt;b1&gt;&gt;b2; if(findpar(b1)==findpar(b2)) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1114 Family Property (25 分)]]></title>
    <url>%2Fpost%2F115a479a.html</url>
    <content type="text"><![CDATA[1114 Family Property (25 分)This time, you are supposed to help us collect the data for family-owned property. Given each person’s family members, and the estate（房产）info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤1000). Then N lines follow, each gives the infomation of a person who owns estate in the format: ID Father Mother k Child.. M Area where ID is a unique 4-digit identification number for each person; Father and Mother are the ID‘s of this person’s parents (if a parent has passed away, -1 will be given instead); k (0≤k≤5) is the number of children of this person; Child**i‘s are the ID‘s of his/her children; Mestate is the total number of sets of the real estate under his/her name; and Area is the total area of his/her estate. Output Specification:For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format: ID M AVGsets AVGarea where ID is the smallest ID in the family; M is the total number of family members; AVGsets is the average number of sets of their real estate; and AVGarea is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID’s if there is a tie. Sample Input:1234567891011106666 5551 5552 1 7777 1 1001234 5678 9012 1 0002 2 3008888 -1 -1 0 1 10002468 0001 0004 1 2222 1 5007777 6666 -1 0 2 3003721 -1 -1 1 2333 2 1509012 -1 -1 3 1236 1235 1234 1 1001235 5678 9012 0 1 502222 1236 2468 2 6661 6662 1 3002333 -1 3721 3 6661 6662 6663 1 100 Sample Output:123438888 1 1.000 1000.0000001 15 0.600 100.0005551 4 0.750 100.000 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出n个人以及他们的亲属、财产、房产面积，要求统计家族总人数、人均财产、人均面积。按人均面积递减排序，如果相同按id递增排序。 分析一开始想用联通分量做，不是很方便。后来才想到了并查集，还是不熟练。 输入时处理家族关系。然后根据出现过的id找到他的家族，统计家族信息。然后根据出现过的家族id，存入一个新的vector。排序输出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;struct person&#123; int id; int father; int mother; vector&lt;int&gt; childs; double estate; double area;&#125;;struct fam&#123; int id; int num; double estate; double area;&#125;;vector&lt;fam&gt; famliy(10000);int parent[10000];int showup[10000],fshowup[10000];person peo[10100];int findpar(int a)&#123; while(parent[a]!=a)&#123; a=parent[a]; &#125; return a;&#125;int makeunion(int a,int b)&#123; int pa=findpar(a); int pb=findpar(b); if(pa&lt;pb) parent[pb]=pa; else parent[pa]=pb; return pa&lt;pb?pa:pb;&#125;bool cmp(fam f1,fam f2)&#123; if(f1.area/f1.num!=f2.area/f2.num) return f1.area/f1.num&gt;f2.area/f2.num; else return f1.id&lt;f2.id;&#125;int main() &#123; cin&gt;&gt;n; int id,father,mother,k,c; for(int i=0;i&lt;10000;i++) parent[i]=i; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;id&gt;&gt;father&gt;&gt;mother&gt;&gt;k; peo[i].id=id; showup[id]=1; if(father!=-1) &#123; makeunion(id, father); showup[father]=1; &#125; if(mother!=-1) &#123; showup[mother]=1; makeunion(id, mother); &#125; for(int j=0;j&lt;k;j++)&#123; cin&gt;&gt;c; showup[c]=1; makeunion(id,c); &#125; cin&gt;&gt;peo[id].estate&gt;&gt;peo[id].area; &#125; for(int i=0;i&lt;10000;i++)&#123; if(showup[i]) &#123; int fid = findpar(i); fshowup[fid] = 1; famliy[fid].id = fid; famliy[fid].num++; famliy[fid].estate += peo[i].estate; famliy[fid].area += peo[i].area; &#125; &#125; int sum=0; for(int i:fshowup) sum+=i; vector&lt;fam&gt; res; for(int i=0;i&lt;10000;i++) if(fshowup[i]) res.push_back(famliy[i]); sort(res.begin(),res.end(),cmp); cout&lt;&lt;sum&lt;&lt;endl; for(int i=0;i&lt;sum;i++)&#123; double es=res[i].estate; double ar=res[i].area; printf("%04d %d %.3f %.3f\n",res[i].id,res[i].num,es/res[i].num,ar/res[i].num); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1112 Stucked Keyboard (20 分)]]></title>
    <url>%2Fpost%2F3b4e1ea3.html</url>
    <content type="text"><![CDATA[1112 Stucked Keyboard (20 分)On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for k times. Now given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string. Notice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed k times whenever it is pressed. For example, when k=3, from the string thiiis iiisss a teeeeeest we know that the keys i and e might be stucked, but s is not even though it appears repeatedly sometimes. The original string could be this isss a teest. Input Specification:Each input file contains one test case. For each case, the 1st line gives a positive integer k (1&lt;k≤100) which is the output repeating times of a stucked key. The 2nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and _. It is guaranteed that the string is non-empty. Output Specification:For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key. Sample Input:123caseee1__thiiis_iiisss_a_teeeeeest Sample Output:12eicase1__this_isss_a_teest 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一串由坏键盘打出的字符串。敲一次坏的键会重复k次，求哪些键是坏的，并求原字符串。 分析虽然20分，但是一开始想歪了，想用每个字符出现总次数除以各字符连续出现的次数。是连续出现的次数是要根据k算的，比如k=3，那1-3个e算一次，4-6个e就得算成两次，特别复杂。 后来换了思路。利用map代表字符是否可能为坏键，初始化为1。然后遍历字符串，统计每个字符连续出现个数，不整除k的是正常的键。 最后输出时candi为0代表是好的键。为1代表第一次检测到，输出并改为2。为2说明是坏键，向后数k-1个。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int k;string s;map&lt;char,int&gt; candi;int main() &#123; cin &gt;&gt; k&gt;&gt;s; for(int i=0;i&lt;s.length();i++) candi[s[i]]=1; for(int i=0;i&lt;s.length();)&#123; int c=1; while(i+c&lt;s.length()&amp;&amp;s[i]==s[i+c]) c++; if(c%k!=0) candi[s[i]]=0; i+=c; &#125; string orign; for(int i=0;i&lt;s.length();i++)&#123; orign+=s[i]; if(candi[s[i]]==1) &#123; cout&lt;&lt;s[i]; candi[s[i]]=2; &#125; if(candi[s[i]]==2) i+=(k-1); &#125; cout&lt;&lt;endl&lt;&lt;orign; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1111 Online Map （30 分)]]></title>
    <url>%2Fpost%2Fc1f5441a.html</url>
    <content type="text"><![CDATA[1111 Online Map （30 分)Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (2≤N≤500), and M, being the total number of streets intersections on a map, and the number of streets, respectively. Then M lines follow, each describes a street in the format: 1V1 V2 one-way length time where V1 and V2 are the indices (from 0 to N−1) of the two ends of the street; one-way is 1 if the street is one-way from V1 to V2, or 0 if not; length is the length of the street; and time is the time taken to pass the street. Finally a pair of source and destination is given. Output Specification:For each case, first print the shortest path from the source to the destination with distance D in the format: 1Distance &#x3D; D: source -&gt; v1 -&gt; ... -&gt; destination Then in the next line print the fastest path with total time T: 1Time &#x3D; T: source -&gt; w1 -&gt; ... -&gt; destination In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique. In case the shortest and the fastest paths are identical, print them in one line in the format: 1Distance &#x3D; D; Time &#x3D; T: source -&gt; u1 -&gt; ... -&gt; destination Sample Input 1:123456789101112131415161710 150 1 0 1 18 0 0 1 14 8 1 1 13 4 0 3 23 9 1 4 10 6 0 1 17 5 1 2 18 5 1 2 12 3 0 2 22 1 1 1 11 3 0 3 11 4 0 1 19 7 1 3 15 1 0 5 26 5 1 1 23 5 Sample Output 1:12Distance &#x3D; 6: 3 -&gt; 4 -&gt; 8 -&gt; 5Time &#x3D; 3: 3 -&gt; 1 -&gt; 5 Sample Input 2:12345678910117 90 4 1 1 11 6 1 1 32 6 1 1 12 5 1 2 23 0 0 1 13 1 1 1 33 2 1 1 24 5 0 2 26 5 1 1 23 5 Sample Output 2:1Distance &#x3D; 3; Time &#x3D; 4: 3 -&gt; 2 -&gt; 5 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一张图，结点之间既有长度也有时间。求起点至终点最短路径、时间最短路径。其中最短路径有多条时，输出时间最短的。时间最短路径有多条时，输出路上结点数最少的。 分析使用两次dijkstra。因为要输出路径，用pre数组记录前驱。tatn(timeatnode)记录走至第i个结点的时间,natn(numberatnode)记录走至第i个结点时路径上结点数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n, m, start, des, inf = 999999999;int e[505][505];int tim[505][505];int dis[505], pre[505], vis[505],tatn[505],natn[505];int main() &#123; cin &gt;&gt; n &gt;&gt; m; fill(e[0], e[0] + 505 * 505, inf); fill(tim[0], tim[0] + 505 * 505, inf); fill(dis, dis + 505, inf); int v1, v2, oneway, len, t; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; oneway &gt;&gt; len &gt;&gt; t; e[v1][v2] = len; tim[v1][v2] = t; if (!oneway) &#123; e[v2][v1] = len; tim[v2][v1] = t; &#125; &#125; cin &gt;&gt; start &gt;&gt; des; dis[start] = 0; //计算最短路 for (int i = 0; i &lt; n; i++) &#123; int v = -1, mindis = inf; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; dis[j] != inf) &#123; if (dis[j] &lt; mindis) &#123; mindis=dis[j]; v = j; &#125; &#125; &#125; if (v == -1 ||v==des) break; vis[v] = 1; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; e[v][i] != inf) &#123; if (dis[i] &gt; dis[v] + e[v][i]) &#123; dis[i] = dis[v] + e[v][i]; pre[i] = v; tatn[i]=tatn[v]+tim[v][i]; &#125;else if(dis[i] == dis[v] + e[v][i])&#123;//路径相同时，比较时间 if(tatn[i]&gt;tatn[v]+tim[v][i]) &#123; pre[i] = v; tatn[i]=tatn[v]+tim[v][i]; &#125; &#125; &#125; &#125; &#125; vector&lt;int&gt; dpath; for(int i=des;i!=start;)&#123; dpath.push_back(i); i=pre[i]; &#125; cout&lt;&lt;"Distance = "&lt;&lt;dis[des]; fill(dis, dis + 505, inf); fill(vis,vis+505,0); dis[start]=0; //计算最短时间 for (int i = 0; i &lt; n; i++) &#123; int v = -1, mint = inf; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; dis[j] != inf) &#123; if (dis[j] &lt; mint) &#123; mint=dis[j]; v = j; &#125; &#125; &#125; if (v == -1 ||v==des) break; vis[v] = 1; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; tim[v][i] != inf) &#123; if (dis[i] &gt; dis[v] + tim[v][i]) &#123; dis[i] = dis[v] + tim[v][i]; pre[i] = v; natn[i]=natn[v]+1; &#125;else if(dis[i]==dis[v]+tim[v][i])&#123;//时间相同时，比较路径上结点数 if(natn[i]&gt;natn[v]) &#123; pre[i] = v; natn[i]=natn[v]+1; &#125; &#125; &#125; &#125; &#125; vector&lt;int&gt; tpath; for(int i=des;i!=start;)&#123; tpath.push_back(i); i=pre[i]; &#125; if(tpath==dpath) cout&lt;&lt;"; "; else &#123; cout &lt;&lt; ": " &lt;&lt; start; for (int i = dpath.size() - 1; i &gt;= 0; i--) cout &lt;&lt; " -&gt; " &lt;&lt; dpath[i]; cout&lt;&lt;endl; &#125; cout&lt;&lt;"Time = "&lt;&lt;dis[des]&lt;&lt;": "&lt;&lt;start; for (int i = tpath.size() - 1; i &gt;= 0; i--) cout &lt;&lt; " -&gt; " &lt;&lt; tpath[i]; return 0;&#125; 其他测试点4是时间相同情况，测试点2是路径长度相同情况。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dijkstra</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1110 Complete Binary Tree （25 分)]]></title>
    <url>%2Fpost%2F4a16c23f.html</url>
    <content type="text"><![CDATA[1110 Complete Binary Tree （25 分)Given a tree, you are supposed to tell if it is a complete binary tree. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤20) which is the total number of nodes in the tree — and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification:For each case, print in one line YES and the index of the last node if the tree is a complete binary tree, or NO and the index of the root if not. There must be exactly one space separating the word and the number. Sample Input 1:1234567891097 8- -- -- -0 12 34 5- -- - Sample Output 1:1YES 8 Sample Input 2:1234567898- -4 50 6- -2 3- 7- -- - Sample Output 2:1NO 1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个棵树的结构，判断此数是否为完全二叉树。 分析层序遍历。用一个变量记录遍历到的结点数，遍历到第一个空结点即退出。最后比较遍历过结点数的和应有结点数。注意这里结点编号可能是2位的。一开始没注意，测试点2，3，4一直错。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;int showup[21];vector&lt;int&gt; tree[21];int main() &#123; cin &gt;&gt; n; string lf,rt; int l, r; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;lf&gt;&gt;rt; l = isdigit(lf[0]) ? stoi(lf) : -1; r = isdigit(rt[0]) ? stoi(rt) : -1; tree[i].push_back(l); tree[i].push_back(r); if (l != -1) showup[l] = 1; if (r != -1) showup[r] = 1; &#125; int head; for (int i = 0; i &lt; n; i++) if (showup[i] == 0) &#123; head = i; break; &#125; int last; deque&lt;int&gt; q; q.push_back(head); int c = 0, cur; while (!q.empty()) &#123; last=cur; cur = q.front(); q.pop_front(); if(cur==-1) break; l = tree[cur][0]; r = tree[cur][1]; q.push_back(l); q.push_back(r); c++; &#125; if (c!=n) cout &lt;&lt; "NO " &lt;&lt; head &lt;&lt; endl; else cout &lt;&lt; "YES " &lt;&lt; last&lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1109 Group Photo （25 分)]]></title>
    <url>%2Fpost%2Fa7839211.html</url>
    <content type="text"><![CDATA[1109 Group Photo （25 分)Formation is very important when taking a group photo. Given the rules of forming K rows with N people as the following: The number of people in each row must be N/K (round down to the nearest integer), with all the extra people (if any) standing in the last row; All the people in the rear row must be no shorter than anyone standing in the front rows; In each row, the tallest one stands at the central position (which is defined to be the position (m/2+1), where m is the total number of people in that row, and the division result must be rounded down to the nearest integer); In each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.); When there are many people having the same height, they must be ordered in alphabetical (increasing) order of their names, and it is guaranteed that there is no duplication of names. Now given the information of a group of people, you are supposed to write a program to output their formation. Input Specification:Each input file contains one test case. For each test case, the first line contains two positive integers N (≤104), the total number of people, and K (≤10), the total number of rows. Then N lines follow, each gives the name of a person (no more than 8 English letters without space) and his/her height (an integer in [30, 300]). Output Specification:For each case, print the formation — that is, print the names of people in K lines. The names must be separated by exactly one space, but there must be no extra space at the end of each line. Note: since you are facing the group, people in the rear rows must be printed above the people in the front rows. Sample Input:123456789101110 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159 Sample Output:123Bob Tom Joe NickAnn Mike EvaTim Amy John 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出N个人的姓名及身高，需要把他们拍成K行。多余的人都排到最后一行，前一排的任一人需要比后一排的所有人矮。同一行中，个子最高的排中间，然后剩下的依次按左右左右排序。 分析首先计算各行的人数。然后把人按身高排序，从高到低填充每一行。同一行中，先计算中间最高者位置，然后往左依次是第2,4,6…高的，向右是第3,5,7…高的。填充即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n,k;struct person&#123; string name; int height;&#125;;vector&lt;vector&lt;person&gt;&gt; formation;vector&lt;person&gt; people;bool cmp(person p1,person p2)&#123; return p1.height!=p2.height?p1.height&gt;p2.height:p1.name&lt;p2.name;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;k; formation.resize(k); people.resize(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;people[i].name&gt;&gt;people[i].height; sort(people.begin(),people.end(),cmp); int m,len,c=0; for(int i=0;i&lt;k;i++)&#123; int midc=c; if(i==0) len=n/k+n%k; else len=n/k; m=len/2+1; formation[i].resize(len+1); formation[i][m]=people[midc]; c=midc+1; for(int pos=m-1;pos&gt;0;pos--) &#123; formation[i][pos] =people[c]; c+=2; &#125; c=midc+2; for(int pos=m+1;pos&lt;=len;pos++) &#123; formation[i][pos] =people[c]; c+=2; &#125; c=midc+len; &#125; for(int i=0;i&lt;formation.size();i++) &#123; for(int j=1;j&lt;formation[i].size();j++) &#123; if(j!=1) cout&lt;&lt;" "; cout&lt;&lt;formation[i][j].name; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1107 Social Clusters （30 分)]]></title>
    <url>%2Fpost%2Ff9ec2b61.html</url>
    <content type="text"><![CDATA[1107 Social Clusters （30 分)When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters. Input Specification:Each input file contains one test case. For each test case, the first line contains a positive integer N (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to N. Then N lines follow, each gives the hobby list of a person in the format: K**i: h**i[1] h**i[2] … h**i[K**i] where K**i (&gt;0) is the number of hobbies, and h**i[j] is the index of the j-th hobby, which is an integer in [1, 1000]. Output Specification:For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input:12345678983: 2 7 101: 42: 5 31: 41: 31: 44: 6 8 1 51: 4 Sample Output:1234 3 1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 1200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出N个学生和他们的兴趣，要求根据共同兴趣划分小圈子。输出小圈子个数和各圈子人数。 分析刷了一百多题了，好像是PAT第一次出现并查集。实现findfather和makeunion操作。然后用hobby[t]数组记录第一个兴趣为t的人。之后每次遇到t，将当前的人合并到第一兴趣为t的人的集合即可。 然后遍历每个人，计算他们的father并用map统计人数。再把人数放入vector中排序输出即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;int hobby[1001];int father[100010];int findfather(int i)&#123; int x=i; while(father[x]!=x) x=father[x]; int temp; //降低深度 while(father[i]!=x)&#123; temp=father[i]; father[i]=x; i=temp; &#125; return x;&#125;void makeunion(int a,int b)&#123; int xa=findfather(a); int xb=findfather(b); if(xa!=xb) father[xb]=xa;&#125;int main() &#123; int c,t; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; father[i]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d:",&amp;c); for(int j=0;j&lt;c;j++)&#123; cin&gt;&gt;t; if(hobby[t]==0) hobby[t]=i; makeunion(i,findfather(hobby[t])); &#125; &#125; map &lt;int,int&gt; mapp; for(int i=1;i&lt;=n;i++) mapp[findfather(i)]++; vector&lt;int&gt; count; for(auto it:mapp) count.push_back(it.second); sort(count.rbegin(),count.rend()); cout&lt;&lt;count.size()&lt;&lt;endl; int f=0; for(int i=0;i&lt;count.size();i++)&#123; f++==0?cout&lt;&lt;"":cout&lt;&lt;" "; cout&lt;&lt;count[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1105 Spiral Matrix （25 分)]]></title>
    <url>%2Fpost%2F4f9b4de.html</url>
    <content type="text"><![CDATA[1105 Spiral Matrix （25 分)This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: m×n must be equal to N; m≥n; and m−n is the minimum of all the possible values. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than 104. The numbers in a line are separated by spaces. Output Specification:For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:121237 76 20 98 76 42 53 95 60 81 58 93 Sample Output:123498 95 9342 37 8153 20 7658 60 76 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意将一个数组由大到小排成一个螺旋数组。其中矩阵行与列的差要最小。 分析首先计算出m,n，肯定大约是根号N的。从根号N开始，m逐渐增加，找到第一个n。如果n大于m，则交换。 然后用dir变量控制填入矩阵的方向。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int t, m, n;vector&lt;int&gt; num;vector&lt;vector&lt;int&gt;&gt; matrix;int dirt[4][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;int main() &#123; cin &gt;&gt; t; m = sqrt(t); for (; m &lt;= t; m++) if (t % m == 0) &#123; n = t / m; break; &#125; if (n &gt; m)//防止出现m=4,n=5这种情况 swap(n, m); matrix.resize(m); for(int i=0;i&lt;m;i++) matrix[i].resize(n); num.resize(t); for (int i = 0; i &lt; t; i++) cin&gt;&gt;num[i]; sort(num.begin(),num.end(),greater&lt;int&gt;()); int cnt=0,dir=0,x=0,y=0; while(cnt&lt;t)&#123; matrix[x][y]=num[cnt++]; if((dir==0&amp;&amp;y==n-1)||(dir==0&amp;&amp;matrix[x][y+1]!=0))//向右到头，转下 dir=1; else if((dir==1&amp;&amp;x==m-1)||(dir==1&amp;&amp;matrix[x+1][y]!=0))//向下到头，转左 dir=2; else if((dir==2&amp;&amp;y==0)||(dir==2&amp;&amp;matrix[x][y-1]!=0))//向左到头，转上 dir=3; else if((dir==3&amp;&amp;x==0)||(dir==3&amp;&amp;matrix[x-1][y]!=0))//向上到头，转右 dir=0; x+=dirt[dir][0]; y+=dirt[dir][1]; &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(j!=0) cout&lt;&lt;" "; cout&lt;&lt;matrix[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1103 Integer Factorization （30 分)]]></title>
    <url>%2Fpost%2F93afcc31.html</url>
    <content type="text"><![CDATA[1103 Integer Factorization （30 分)The K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P. Input Specification:Each input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7). The numbers in a line are separated by a space. Output Specification:For each case, if the solution exists, output in the format: 1N &#x3D; n[1]^P + ... n[K]^P where n[i] (i = 1, …, K) is the i-th factor. All the factors must be printed in non-increasing order. Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen — sequence { a1,a2,⋯,a**K } is said to be larger than { b1,b2,⋯,b**K } if there exists 1≤L≤K such that a**i=b**i for i&lt;L and a**L&gt;b**L. If there is no solution, simple output Impossible. Sample Input 1:1169 5 2 Sample Output 1:1169 &#x3D; 6^2 + 6^2 + 6^2 + 6^2 + 5^2 Sample Input 2:1169 167 3 Sample Output 2:1Impossible 作者: CHEN, Yue 单位: 浙江大学 时间限制: 1200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出N，K，P，要求将N分解为K个数的P次幂 分析dfs暴力求解。由大到小，最大值为√(N-k-1)[实际上是p次方根，此时剩余k-1个数全为1]。通过upbound参数，控制本次选的数不能大于上一次选的，从而实现选的数非递增排序。findres的参数分别为剩余的n，已有数字个数，保存已有数字的vector，当前数字上限，已有数字和。剪枝规则如下：1.当剩余的n恰好等于k-cnt时，说明余下的数字全为1。2.当n小于0或者已有数字大于k个时，返回3.当n等于0且恰有k个数，比较和，更新结果。 然后从upbound开始，依次判断。x为当前数的p次。假设选取当前数。则剩余k-cnt-1个数的最大值需大于n-x，最小值需小于n-x。符合条件才继续搜索。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n, k, p, up, maxsum = -1;vector&lt;int&gt; po;vector&lt;int&gt; res;void findres(int n, int cnt, vector&lt;int&gt; v, int upbound, int sum) &#123; if (n == k - cnt) &#123; for (int i = 0; i &lt; n; i++) v.push_back(1); sum += n; if (sum &gt; maxsum) &#123; maxsum = sum; res = v; &#125; return; &#125; if (n &lt; 0||cnt&gt;k) return; if (cnt == k &amp;&amp; n == 0) &#123; if (sum &gt; maxsum) &#123; maxsum = sum; res = v; &#125; return; &#125; for (int i = upbound; i &gt;= 1; i--) &#123; int x = po[i];//x为i的p次 if (n - x &gt;= 0) if ((n - x) &lt;= (k - cnt - 1) * x)//剩余数的最大值要大于n-x if ((n - x) &gt;= (k - cnt - 1)) &#123;//剩余数的最小值要小于n-x v.push_back(i); findres(n - x, cnt + 1, v, i, sum + i); v.pop_back(); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; up = sqrt(n - k + 1); po.resize(up + 1); for (int i = 1; i &lt;= up + 1; i++) po[i] = pow(i, p); vector&lt;int&gt; temp; findres(n, 0, temp, up, 0); if (maxsum == -1) cout &lt;&lt; "Impossible" &lt;&lt; endl; else &#123; cout &lt;&lt; n &lt;&lt; " = "; int f = 0; for (int i:res) &#123; f++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " + "; cout &lt;&lt; i &lt;&lt; "^" &lt;&lt; p; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1101 Quick Sort （25 分)]]></title>
    <url>%2Fpost%2F4193e7a5.html</url>
    <content type="text"><![CDATA[1101 Quick Sort （25 分)There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it; 3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well; 2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well; and for the similar reason, 4 and 5 could also be the pivot. Hence in total there are 3 pivot candidates. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤105). Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces. Output Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:1251 3 2 4 5 Sample Output:1231 4 5 作者: CAO, Peng 单位: Google 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个序列，求其中可以作为快速排序哨兵的数。 分析用maxx,minn数组，maxx[i]记录0至i-1的最大数。minn[i]记录i+1至n-1的最小数。 然后遍历num，与maxx及minn比较即可。最后的回车必须要加，否则有一个点格式错误。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;int num[100010];int maxx[100010];int minn[100010];int main() &#123; cin &gt;&gt; n; fill(maxx,maxx+n,-1); fill(minn,minn+n,2000000000); for(int i=0;i&lt;n;i++) cin&gt;&gt;num[i]; int maxt=-1,mint=2000000000; int r; for(int i=0;i&lt;n;i++)&#123; r=n-i-1; if(maxt&lt;num[i]) maxt=num[i]; maxx[i+1]=maxt; if(mint&gt;num[r]) mint=num[r]; minn[r-1]=mint; &#125; int f=0; int cnt=0; vector&lt;int&gt; res; for(int i=0;i&lt;n;i++)&#123; if(num[i]&gt;maxx[i]&amp;&amp;num[i]&lt;minn[i]) &#123; cnt++; res.push_back(num[i]); &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; for(int i:res) &#123; f++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; i; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1099 Build A Binary Search Tree （30 分)]]></title>
    <url>%2Fpost%2F7a14fe1e.html</url>
    <content type="text"><![CDATA[1099 Build A Binary Search Tree （30 分)A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:123456789101191 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42 Sample Output:158 25 82 11 38 67 45 73 42 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一颗二叉树的形状，再给出一组数填充进此树，要求输出这棵树的层序遍历。 分析因为是二叉树，把输入的数排序之后即为中序遍历。中序遍历此树，过程中即可知道各个位置上对应的数。用一个map存储层号和各层上的数即可。 30分的题出的比20分的还简单，也是醉了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n,cnt;vector&lt;int&gt; tree[101];vector&lt;int&gt; num;map&lt;int,vector&lt;int&gt;&gt; layer;void inorder(int root,int l)&#123; if(root==-1) return; inorder(tree[root][0],l+1); layer[l].push_back(num[cnt++]); inorder(tree[root][1],l+1);&#125;int main() &#123; cin&gt;&gt;n; num.resize(n); int l,r; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;l&gt;&gt;r; tree[i].push_back(l); tree[i].push_back(r); &#125; for(int i=0;i&lt;n;i++) cin&gt;&gt;num[i]; sort(num.begin(),num.end()); inorder(0,0); int f=0; for(auto it=layer.begin();it!=layer.end();it++)&#123; for(int x:it-&gt;second) &#123; f++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout&lt;&lt;x; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1097 Deduplication on a Linked List （25 分)]]></title>
    <url>%2Fpost%2F37b33969.html</url>
    <content type="text"><![CDATA[1097 Deduplication on a Linked List （25 分)Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤105) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: 1Address Key Next where Address is the position of the node, Key is an integer of which absolute value is no more than 104, and Next is the position of the next node. Output Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:12345600100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854 Sample Output:1234500100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个链表，要求保留每个关键字的绝对值出现第一次的结点。把删除的结点也组成链表。最后输出剩余结点，以及删除结点。 分析先用一个map存储地址与结点，然后遍历。用两个vector存储剩余的和删除的结点。这里不需要map，使用vector，结点push的顺序即为链表中的顺序。最后输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int head, n;struct node &#123; int addr; int val; int next; node(int addr, int val, int next) : addr(addr), val(val), next(next) &#123;&#125; node() &#123;&#125;&#125;;map&lt;int, node&gt; orig;vector&lt;node&gt; rem;vector&lt;node&gt; rmv;map&lt;int,int&gt;ocur;int main() &#123; cin &gt;&gt; head &gt;&gt; n; int at, vt, next; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; at &gt;&gt; vt &gt;&gt; next; node n(at, vt, next); orig[at] = n; &#125; for(int i=head;i!=-1;i=orig[i].next)&#123; node now=orig[i]; int x=abs(now.val); ocur[x]++; if(ocur[x]&gt;1) rmv.push_back(now); else rem.push_back(now); &#125; for(int i=0;i&lt;rem.size();i++)&#123; if(i&lt;rem.size()-1) printf("%05d %d %05d\n",rem[i].addr,rem[i].val,rem[i+1].addr); else printf("%05d %d -1\n",rem[i].addr,rem[i].val); &#125; for(int i=0;i&lt;rmv.size();i++)&#123; if(i&lt;rmv.size()-1) printf("%05d %d %05d\n",rmv[i].addr,rmv[i].val,rmv[i+1].addr); else printf("%05d %d -1\n",rmv[i].addr,rmv[i].val); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1096 Consecutive Factors （20 分)]]></title>
    <url>%2Fpost%2F214666a9.html</url>
    <content type="text"><![CDATA[1096 Consecutive Factors （20 分)Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification:Each input file contains one test case, which gives the integer N (1&lt;N&lt;231). Output Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]*factor[2]*...*factor[k], where the factors are listed in increasing order, and 1 is NOT included. Sample Input:1630 Sample Output:1235*6*7 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个数，分解因数。求因数可以组成连续最长序列的最小值。 分析一开始拿到题没什么思路。网上查了一下，暴力解决。i从2开始，遍历至根号n，计算从i开始连续因数的长度。如果是长度为0，说明是质数，直接输出本身。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n,cnt,start,maxcnt=-1;int main() &#123; cin&gt;&gt;n; int f=sqrt(n); int flag=0; for(int i=2;i&lt;=f;i++)&#123; int x=n; cnt=0; for(int j=i;j&lt;=f;j++)&#123; if(x%j==0)&#123; cnt++; x/=j; if(cnt&gt;maxcnt)&#123; maxcnt=cnt; start=i; &#125; &#125; else break; &#125; &#125; if(maxcnt==-1) &#123; cout&lt;&lt;"1"&lt;&lt;endl; cout&lt;&lt;n; &#125;else &#123; cout&lt;&lt;maxcnt&lt;&lt;endl; cout&lt;&lt;start; for(int i=start+1;i&lt;start+maxcnt;i++) cout&lt;&lt;"*"&lt;&lt;i; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1095 Cars on Campus （30 分)]]></title>
    <url>%2Fpost%2F1c1b1c69.html</url>
    <content type="text"><![CDATA[1095 Cars on Campus （30 分)Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period. Input Specification:Each input file contains one test case. Each case starts with two positive integers N (≤104), the number of records, and K (≤8×104) the number of queries. Then N lines follow, each gives a record in the format: 1plate_number hh:mm:ss status where plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59; and status is either in or out. Note that all times will be within a single day. Each in record is paired with the chronologically next record for the same car provided it is an outrecord. Any in records that are not paired with an out record are ignored, as are out records not paired with an in record. It is guaranteed that at least one car is well paired in the input, and no car is both in and out at the same moment. Times are recorded using a 24-hour clock. Then K lines of queries follow, each gives a time point in the format hh:mm:ss. Note: the queries are given in ascending order of the times. Output Specification:For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space. Sample Input:12345678910111213141516171819202122232416 7JH007BD 18:00:01 inZD00001 11:30:08 outDB8888A 13:00:00 outZA3Q625 23:59:50 outZA133CH 10:23:00 inZD00001 04:09:59 inJH007BD 05:09:59 inZA3Q625 11:42:01 outJH007BD 05:10:33 inZA3Q625 06:30:50 inJH007BD 12:23:42 outZA3Q625 23:55:00 inJH007BD 12:24:23 outZA133CH 17:11:22 outJH007BD 18:07:01 outDB8888A 06:30:50 in05:10:0006:30:5011:00:0012:23:4214:00:0018:00:0023:59:00 Sample Output:123456781452101JH007BD ZD00001 07:20:09 作者: CHEN, Yue 单位: 浙江大学 时间限制: 300 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出车进出浙大的列表，求给定时间校园内车的数量和在校园时间最长的车 分析首先读取输入，根据inout配对筛选合法的数据。把进入时间和出校时间存放至两个vector。再读入查询的时间，根据upper_bound函数查找，作差即为校园内车数。时间复杂度nlgn。一辆车可以来回进出校园，所以统计停车时间时需要都加上。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n,k;struct sta&#123; string plate; int time; string in; sta(const string &amp;plate, int time, const string &amp;in) : plate(plate), time(time), in(in) &#123;&#125; sta() &#123;&#125;&#125;;vector&lt;sta&gt; v;vector&lt;int&gt; intime;vector&lt;int&gt; outime;map&lt;string,int&gt; carpark;vector&lt;string&gt; longcar;bool cmp(sta s1,sta s2)&#123; return s1.plate!=s2.plate?s1.plate&lt;s2.plate:s1.time&lt;s2.time;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;k; string p,in; int h,m,s; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;p; scanf("%d:%d:%d ",&amp;h,&amp;m,&amp;s); cin&gt;&gt;in; int x=h*3600+m*60+s; sta st(p,x,in); v.push_back(st); &#125; sort(v.begin(),v.end(),cmp); int maxt=-1; for(int i=0;i&lt;v.size()-1;i++)&#123; if(v[i].plate==v[i+1].plate&amp;&amp;v[i].in=="in"&amp;&amp;v[i+1].in=="out")&#123; carpark[v[i].plate]+=v[i+1].time-v[i].time; int x=carpark[v[i].plate]; if(x&gt;maxt) &#123; maxt=x; longcar.clear(); longcar.push_back(v[i].plate); &#125;else if(x==maxt)&#123; longcar.push_back(v[i].plate); &#125; intime.push_back(v[i].time); outime.push_back(v[i+1].time); &#125; &#125; sort(intime.begin(),intime.end()); sort(outime.begin(),outime.end()); sort(longcar.begin(),longcar.end()); int cnt=0; for(int i=0;i&lt;k;i++)&#123; scanf("%d:%d:%d",&amp;h,&amp;m,&amp;s); int x=h*3600+m*60+s; int ii=upper_bound(intime.begin(),intime.end(),x)-intime.begin(); int oi=upper_bound(outime.begin(),outime.end(),x)-outime.begin(); cnt=ii-oi; printf("%d\n",cnt); &#125; for(string s:longcar) cout&lt;&lt;s&lt;&lt;" "; printf("%02d:%02d:%02d",maxt/3600,(maxt%3600)/60,maxt%60); return 0;&#125; 其他这题我做复杂了，根据车进出时间排序，再判断是in或者out可以做到o(n)的复杂度。不过nlng也能过。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1093 Count PAT's （25 分)]]></title>
    <url>%2Fpost%2Fdf791960.html</url>
    <content type="text"><![CDATA[1093 Count PAT’s （25 分)The string APPAPT contains two PAT‘s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters. Now given any string, you are supposed to tell the number of PAT‘s contained in the string. Input Specification:Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only P, A, or T. Output Specification:For each test case, print in one line the number of PAT‘s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007. Sample Input:1APPAPT Sample Output:12 作者: CAO, Peng 单位: Google 时间限制: 150 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意统计字符串中PAT的数量 分析不能算难，但比较有意思。必须用o(n)的算法，否则超时。pc记录P的个数，pa记录PA出现个数，res记录结果。遍历字符串，出现P则让pc++，出现A则之前所有P与当前A能组成PA，pa+=pc。出现T则之前所有PA与当前T可组成PAT。res+=pa。 代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;string s;long int res;int pc, pa;int main() &#123; cin &gt;&gt; s; int l = s.length(); for (int i = 0; i &lt; l; i++) &#123; if (s[i] == 'P') pc++; if (s[i] == 'A') pa += pc; if (s[i] == 'T') res += pa; &#125; cout &lt;&lt; res % 1000000007; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1091 Acute Stroke （30 分)]]></title>
    <url>%2Fpost%2F8f5ba664.html</url>
    <content type="text"><![CDATA[1091 Acute Stroke （30 分)One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core. Input Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers: M, N, L and T, where M and N are the sizes of each slice (i.e. pixels of a slice are in an M×N matrix, and the maximum resolution is 1286 by 128); L (≤60) is the number of slices of a brain; and T is the integer threshold (i.e. if the volume of a connected core is less than T, then that core must not be counted). Then L slices are given. Each slice is represented by an M×N matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than T are counted. Two pixels are connected and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one. Figure 1 Output Specification:For each case, output in a line the total volume of the stroke core. Sample Input:123456789101112131415163 4 5 21 1 1 11 1 1 11 1 1 10 0 1 10 0 1 10 0 1 11 0 1 10 1 0 00 0 0 01 0 1 10 0 0 00 0 0 00 0 0 10 0 0 11 0 0 0 Sample Output:126 作者: CHEN, Yue 单位: 浙江大学 时间限制: 600 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出三维L*M*N的大脑扫描图，要求计算中风核的大小。连续的1（六个方向）算一个核，大小小于T的核不计算。 分析bfs即可。注意不能用dfs，递归过深会爆栈导致段错误。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int m,n,l,t;int brain[62][1300][130];int visit[62][1300][130];int cnt;int dir[6][3]=&#123;&#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,0,-1&#125;&#125;;struct node&#123; int x; int y; int z; node(int x, int y, int z) : x(x), y(y), z(z) &#123;&#125; node() &#123;&#125;&#125;;deque&lt;node&gt;q;int bfs(int x,int y,int z)&#123; int c=1; visit[x][y][z]=1; node nd(x,y,z); q.push_back(nd); while(!q.empty()) &#123; node tempnode=q.front(); q.pop_front(); for (int i = 0; i &lt; 6; i++) &#123; int xx = tempnode.x + dir[i][0]; int yy = tempnode.y + dir[i][1]; int zz = tempnode.z + dir[i][2]; if (xx &lt; 0 || xx &gt;= l || yy &lt; 0 || yy &gt;= m || zz &lt; 0 || zz &gt;= n) continue; if (brain[xx][yy][zz] == 1 &amp;&amp; !visit[xx][yy][zz]) &#123; c++; visit[xx][yy][zz]=1; node newnd(xx, yy, zz); q.push_back(newnd); &#125; &#125; &#125; return c;&#125;int main() &#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;l&gt;&gt;t; for(int i=0;i&lt;l;i++) for(int j=0;j&lt;m;j++) for(int k=0;k&lt;n;k++) cin&gt;&gt;brain[i][j][k]; for(int i=0;i&lt;l;i++) for(int j=0;j&lt;m;j++) for(int k=0;k&lt;n;k++) if(brain[i][j][k]==1&amp;&amp;!visit[i][j][k]) &#123; int temp = bfs(i, j, k); if (temp&gt;= t) cnt+=temp; &#125; printf("%d",cnt); return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1087 All Roads Lead to Rome （30 分)]]></title>
    <url>%2Fpost%2F157f8432.html</url>
    <content type="text"><![CDATA[1087 All Roads Lead to Rome （30 分)Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome. Output Specification:For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness — it is guaranteed by the judge that such a solution exists and is unique. Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1-&gt;City2-&gt;...-&gt;ROM. Sample Input:123456789101112136 7 HZHROM 100PKN 40GDN 55PRS 95BLN 80ROM GDN 1BLN ROM 1HZH PKN 1PRS ROM 2BLN HZH 2PKN GDN 1HZH PRS 1 Sample Output:123 3 195 97HZH-&gt;PRS-&gt;ROM 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意从一个城出发去罗马，途径许多城市。给出各城市间距离以及各城市的快乐值，求去罗马最短的路线。如果最短的路线有多条，则选择路线上快乐值和最大的。如果仍有多条，输出平均快乐值最大的（即途径城市最少的） 分析类似1030 Travel Plan （30 分) 和1003 Emergency （25 分)。 读入数据，利用map映射城市名与编号。用nodes数组记录第i个结点上的信息。包括路径条数，路径上的城市集合，和总快乐值。然后从起点dijkstra即可。注意路径长度相同时路径数的更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;struct node&#123; int pnum; vector&lt;int&gt; path; int happy;&#125;;int n,k,cnt,happy[202],e[202][202],dis[202],visit[202],inf=99999999;node nodes[202];map&lt;string,int&gt; m;int main() &#123; string temp; cin&gt;&gt;n&gt;&gt;k; cin&gt;&gt;temp; m[temp]=cnt++; int h; for(int i=0;i&lt;n-1;i++)&#123; cin&gt;&gt;temp&gt;&gt;h; happy[cnt]=h; m[temp]=cnt++; &#125; string s1,s2; int d; fill(e[0],e[0]+202*202,inf); fill(dis,dis+202,inf); for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;d; e[m[s1]][m[s2]]=e[m[s2]][m[s1]]=d; &#125; dis[0]=0; nodes[0].pnum=1; for(int i=0;i&lt;n;i++)&#123; int v=-1,mind=inf; for(int i=0;i&lt;n;i++)&#123; if(!visit[i]&amp;&amp;dis[i]&lt;mind)&#123; mind=dis[i]; v=i; &#125; &#125; if(v==-1) break; visit[v]=1; for(int j=0;j&lt;n;j++)&#123; if(!visit[j]&amp;&amp;e[v][j]!=inf)&#123; if(dis[j]&gt;dis[v]+e[v][j])&#123;//从v至j路径更短 dis[j]=dis[v]+e[v][j]; nodes[j].path=nodes[v].path; nodes[j].path.push_back(j); nodes[j].happy=nodes[v].happy+happy[j]; nodes[j].pnum=nodes[v].pnum; &#125;else if(dis[j]==dis[v]+e[v][j])&#123;//路径相同 nodes[j].pnum+=nodes[v].pnum; if((nodes[j].happy&lt;nodes[v].happy+happy[j]) ||(nodes[j].happy==nodes[v].happy+happy[j]&amp;&amp;nodes[j].path.size()&gt;nodes[v].path.size()+1))&#123;//根据快乐值更新 dis[j]=dis[v]+e[v][j]; nodes[j].path=nodes[v].path; nodes[j].path.push_back(j); nodes[j].happy=nodes[v].happy+happy[j]; &#125; &#125; &#125; &#125; &#125; map&lt;int,string&gt; idtoname; for(auto it=m.begin();it!=m.end();it++) idtoname[it-&gt;second]=it-&gt;first; for(auto it=m.begin();it!=m.end();it++)&#123; if(it-&gt;first=="ROM") &#123; int id=it-&gt;second; cout&lt;&lt;nodes[id].pnum&lt;&lt;" "&lt;&lt;dis[id]&lt;&lt;" "&lt;&lt;nodes[id].happy&lt;&lt;" "&lt;&lt;nodes[id].happy/nodes[id].path.size()&lt;&lt;endl; cout&lt;&lt;idtoname[0]; for(int i:nodes[id].path) cout&lt;&lt;"-&gt;"&lt;&lt;idtoname[i]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dijkstra</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1086 Tree Traversals Again （25 分)]]></title>
    <url>%2Fpost%2Fbaba86e8.html</url>
    <content type="text"><![CDATA[1086 Tree Traversals Again （25 分)An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack. Output Specification:For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input:123456789101112136Push 1Push 2Push 3PopPopPush 4PopPopPush 5Push 6PopPop Sample Output:13 4 2 6 5 1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出中序遍历一棵树的过程，求这棵树的后序遍历 分析一开始没想明白。其实push的顺序就是前序遍历，pop的顺序是中序，知道前序中序，后序就好办了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n;bool flag=true;vector&lt;int&gt; pre;vector&lt;int&gt; in;stack&lt;int&gt; s;void postorder(int root,int start,int end)&#123; if(start&gt;end) return; int i = start; while(i&lt;end &amp;&amp; in[i] != pre[root] ) i++; postorder(root+1,start,i-1); postorder(root+1+i-start,i+1,end); printf("%s%d",flag==true?"":" ",pre[root]); flag = false;&#125;int main() &#123; cin&gt;&gt;n; int x; string str; for(int i=0;i&lt;2*n;i++)&#123; cin&gt;&gt;str; if(str.length()==4)&#123; cin&gt;&gt;x; pre.push_back(x); s.push(x); &#125;else&#123; in.push_back(s.top()); s.pop(); &#125; &#125; postorder(0,0,n-1); return 0;&#125; 其他读取数据的时候，如果cin和getline混用最后一个测试点会段错误，很奇怪，不知道为什么。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[坑][自闭]1082 Read Number in Chinese （25 分)]]></title>
    <url>%2Fpost%2Fae2989cb.html</url>
    <content type="text"><![CDATA[1082 Read Number in Chinese （25 分)Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai. Input Specification:Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification:For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1:1-123456789 Sample Output 1:1Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2:1100800 Sample Output 2:1yi Shi Wan ling ba Bai 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题意给出一串数字，要求输出中文读法。 分析看到这题我的内心是自闭的🙄。不过兵来将挡，水来土掩，刚（头铁）就完事了。 一开始考虑用string存数字，便于提取各位。后来发现还是用int更方便。 首先，把数字分成三部分。第9位（亿级），8-5位（万级），4-1位（个级）。这里就能体现出int的优越性了，如果使用string会非常麻烦。然后依次处理。万级的逻辑与个级类似，只不过多加了个Wan。 start用于控制开始输出，例如输入100。亿位万位都是0，显然不用输出0亿0万。当输出第一个不为0的数后，置start为1。 fisrt用于控制空格。第一个数之前不输出空格， 其余数输出前需加空格 prtling用于控制是否需要输出0。 亿级（第9位）逻辑比较简单。判断是否为0即可。如果不为0，输出。如果万位个位全为0，直接返回。 万级（8-5位）首先判断是否为0。如果为0输出ling。否则计算千百十个位，依次处理。1.千位。还是判断是否为0，如果为0且百十个不都为0（在千位这个判断好像可以省去），则输出ling。否则在千位不等于0时，输出x Qian。(x为千位数字)2.百位。与千位类似。判断是否为0，如果为0且十个位不为0，则输出ling（这个判断不能省，1001百位的0需输出，1000则不用，）。否则百位不为0时，输出x Bai。3.十位个位逻辑类似。4.最后输出Wan。 个级（4-1位）逻辑与万级类似 代码代码虽然丑了点，但是逻辑还是比较易于理解的。事实上，处理个十百千位的逻辑类似，处理万级与个级的逻辑也类似，还是可以把代码写的好看的，只不过得多花费些功夫。 柳婼大佬的代码，写的很简洁，但我是不可能看懂的🤷🏻‍♂️ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;vector&lt;string&gt; num = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;;int main() &#123; int n; cin &gt;&gt; n; if (n == 0) &#123; cout &lt;&lt; "ling"; return 0; &#125; if (n &lt; 0) &#123; cout &lt;&lt; "Fu "; n = -n; &#125; int part[3]; part[0] = n / 100000000; part[1] = n % 100000000 / 10000; part[2] = n % 10000; int start = 0;//开始输出 int first = 0; int prtling = 0;//打印了0 for (int i = 0; i &lt; 3; i++) &#123; if (part[i] == 0 &amp;&amp; start == 0) continue; if (i == 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[part[0]] &lt;&lt; " " &lt;&lt; "Yi"; start = 1; if (part[1] == 0 &amp;&amp; part[2] == 0) return 0; &#125; else if (i == 1) &#123; if (part[i] == 0) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else &#123; int q = part[i] / 1000; part[i] = part[i] % 1000; int b = part[i] / 100; part[i] = part[i] % 100; int shi = part[i] / 10; int ge = part[i] % 10; if (q == 0 &amp;&amp; prtling == 0 &amp;&amp; start == 1 &amp;&amp; (b != 0 || shi != 0 || ge != 0)) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else if (q != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[q] &lt;&lt; " Qian"; prtling = 0; start = 1; &#125; if (b == 0 &amp;&amp; prtling == 0 &amp;&amp; start == 1 &amp;&amp; (shi != 0 || ge != 0)) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else if (b != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[b] &lt;&lt; " Bai"; prtling = 0; start = 1; &#125; if (shi == 0 &amp;&amp; prtling == 0 &amp;&amp; start == 1 &amp;&amp; ge != 0) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else if (shi != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[shi] &lt;&lt; " Shi"; prtling = 0; start = 1; &#125; if (ge != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[ge]; prtling = 0; start = 1; &#125; cout &lt;&lt; " Wan"; &#125; &#125; else if (i == 2) &#123; int q = part[i] / 1000; part[i] = part[i] % 1000; int b = part[i] / 100; part[i] = part[i] % 100; int shi = part[i] / 10; int ge = part[i] % 10; if (q == 0 &amp;&amp; prtling == 0 &amp;&amp; start == 1 &amp;&amp; (b != 0 || shi != 0 || ge != 0)) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else if (q != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[q] &lt;&lt; " Qian"; prtling = 0; start = 1; &#125; if (b == 0 &amp;&amp; prtling == 0 &amp;&amp; start == 1 &amp;&amp; (shi != 0 || ge != 0)) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else if (b != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[b] &lt;&lt; " Bai"; prtling = 0; start = 1; &#125; if (shi == 0 &amp;&amp; prtling == 0 &amp;&amp; start == 1 &amp;&amp; ge != 0) &#123; cout &lt;&lt; " ling"; prtling = 1; &#125; else if (shi != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[shi] &lt;&lt; " Shi"; prtling = 0; start = 1; &#125; if (ge != 0) &#123; first++ == 0 ? cout &lt;&lt; "" : cout &lt;&lt; " "; cout &lt;&lt; num[ge]; prtling = 0; start = 1; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 10.14 Mojave 安装caffe记录]]></title>
    <url>%2Fpost%2Fa9f37014.html</url>
    <content type="text"><![CDATA[MacOS 10.14 Mojave 安装caffe记录做毕设需要用到caffe，尝试在自己电脑上安装，过程中发现安装caffe还是有不少坑的，特此记录。主要参考https://zhuanlan.zhihu.com/p/46930024 安装依赖首先需要更新xcode(暂时是10.12)。 假设你已经在mac上安装了homebrew，根据caffe的官方指南，我们需要安装一些依赖： 12brew install -vd snappy leveldb gflags glog szip lmdbbrew install openblas 跟官方指南不一样的是homebrew已经取消了science这个tap，所以使用如下的命令来安装hdf5 和 opencv： 1brew install hdf5 opencv 这一步，有可能需要更新gcc，其中提示需要CLT：The bottle needs the Xcode CLT to be installed.首先确认xcode中clt已经安装： 然后运行brew config,查看brew中是否有clt的配置。如果显示CLT: N/A，那么运行xcode-select —install。设置好CLT后，继续安装依赖。 因为新版本的boost, boost-python和旧版本有兼容性问题[1], 我们使用homebrew 所提供的boost@1.59版本 来代替最新版本的boost: 123brew install boost@1.59 boost-python@1.59brew link boost@1.59 --forcebrew link boost-python@1.59 --force 这一步应该没什么问题 至于protobuf，实测在3.6.1版本上也不能正确编译，而homebrew带其他版本太旧，这里我们从source编译protobuf的3.5.1版本： 12345678cd ~&#x2F;Downloads wget https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;archive&#x2F;v3.5.1.zipunzip protobuf-3.5.1.zipcd protobuf-3.5.1.&#x2F;autogen.sh.&#x2F;configuremakemake install 这里，我按照它的做法安装protobuf，然而在import caffe时会出现ImportError: No module named google.protobuf.internal最后还是选择使用anaconda管理:conda install protobuf用的是3.6.1版本，并没有出现错误。 之前的编译没用opencv，没法计算图片均值。于是重新编译了一次。事实证明protobuf3.6.1果然没法编译。 设置python版本 依赖安装完了，现在我们对所需要用到的python版本进行设置，因为据说caffe在python3的表现并不是很好很容易出bug，这里我们使用的是anaconda的虚拟环境来构建一个python2.7的版本，并且安装相关依赖： 123conda create --name py27 python&#x3D;2.7source activate py27pip install numpy scipy scikit-image 这一步，因为我用的已经是anaconda2，应该可以略去。保险起见还是创建了这样一个环境。重新编译证明，这步的确可略去&lt;/span&gt; 配置caffe 现在开始装caffe。 1234cd ~git clone https:&#x2F;&#x2F;github.com&#x2F;BVLC&#x2F;caffe.gitcd caffecp Makefile.config.example Makefile.config 其次需要在Makefile.config里做一些调整： 12345678910111213141516171819202122232425262728291. 取消CPU_ONLY前面的注释2. 取消USE_OPENCV前面的注释3. 取消USE_HDF5前面的注释，并且改成14. 取消OPENCV_VERSION前面的注释5. 注释掉CUDA_DIR那一行6. 将BLAS改成open7. 设置blas的路径，取消这两行的注释# Homebrew puts openblas in a directory that is not on the standard search pathBLAS_INCLUDE :&#x3D; $(shell brew --prefix openblas)&#x2F;includeBLAS_LIB :&#x3D; $(shell brew --prefix openblas)&#x2F;lib8.设置python的路径，因为我使用的是anaconda3，所以我创建了一个名叫py27的python&#x3D;2.7的子环境，然后设置如下：# Uncomment to support layers written in Python (will link against Python libs)WITH_PYTHON_LAYER :&#x3D; 1ANACONDA_HOME :&#x3D; $(HOME)&#x2F;anaconda3&#x2F;envs&#x2F;py27PYTHON_INCLUDE :&#x3D; $(ANACONDA_HOME)&#x2F;include \ $(ANACONDA_HOME)&#x2F;include&#x2F;python2.7 \ $(ANACONDA_HOME)&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;numpy&#x2F;core&#x2F;include# Uncomment to use Python 3 (default is Python 2)# PYTHON_LIBRARIES :&#x3D; boost_python3 python3.5m# PYTHON_INCLUDE :&#x3D; &#x2F;usr&#x2F;include&#x2F;python3.5m \# &#x2F;usr&#x2F;lib&#x2F;python3.5&#x2F;dist-packages&#x2F;numpy&#x2F;core&#x2F;include# We need to be able to find libpythonX.X.so or .dylib.# PYTHON_LIB :&#x3D; &#x2F;usr&#x2F;libPYTHON_LIB :&#x3D; $(ANACONDA_HOME)&#x2F;lib 这一步，注意修改ANACONDA_HOME为自己的anaconda路径。如果使用opencv，使用brew安装后修改INCLUDE_DIRS以及LIBRARY_DIRS下面贴一个我的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123## Refer to http:&#x2F;&#x2F;caffe.berkeleyvision.org&#x2F;installation.html# Contributions simplifying and improving our build system are welcome!# cuDNN acceleration switch (uncomment to build with cuDNN).# USE_CUDNN :&#x3D; 1# CPU-only switch (uncomment to build without GPU support).CPU_ONLY :&#x3D; 1# uncomment to disable IO dependencies and corresponding data layersUSE_OPENCV :&#x3D; 1# USE_LEVELDB :&#x3D; 0# USE_LMDB :&#x3D; 0# This code is taken from https:&#x2F;&#x2F;github.com&#x2F;sh1r0&#x2F;caffe-android-libUSE_HDF5 :&#x3D; 1# uncomment to allow MDB_NOLOCK when reading LMDB files (only if necessary)# You should not set this flag if you will be reading LMDBs with any# possibility of simultaneous read and write# ALLOW_LMDB_NOLOCK :&#x3D; 1# Uncomment if you&#39;re using OpenCV 3# OPENCV_VERSION :&#x3D; 3# To customize your choice of compiler, uncomment and set the following.# N.B. the default for Linux is g++ and the default for OSX is clang++# CUSTOM_CXX :&#x3D; g++# CUDA directory contains bin&#x2F; and lib&#x2F; directories that we need.# CUDA_DIR :&#x3D; &#x2F;usr&#x2F;local&#x2F;cuda# On Ubuntu 14.04, if cuda tools are installed via# &quot;sudo apt-get install nvidia-cuda-toolkit&quot; then use this instead:# CUDA_DIR :&#x3D; &#x2F;usr# CUDA architecture setting: going with all of them.# For CUDA &lt; 6.0, comment the *_50 through *_61 lines for compatibility.# For CUDA &lt; 8.0, comment the *_60 and *_61 lines for compatibility.# For CUDA &gt;&#x3D; 9.0, comment the *_20 and *_21 lines for compatibility.CUDA_ARCH :&#x3D; -gencode arch&#x3D;compute_20,code&#x3D;sm_20 \ -gencode arch&#x3D;compute_20,code&#x3D;sm_21 \ -gencode arch&#x3D;compute_30,code&#x3D;sm_30 \ -gencode arch&#x3D;compute_35,code&#x3D;sm_35 \ -gencode arch&#x3D;compute_50,code&#x3D;sm_50 \ -gencode arch&#x3D;compute_52,code&#x3D;sm_52 \ -gencode arch&#x3D;compute_60,code&#x3D;sm_60 \ -gencode arch&#x3D;compute_61,code&#x3D;sm_61 \ -gencode arch&#x3D;compute_61,code&#x3D;compute_61# BLAS choice:# atlas for ATLAS (default)# mkl for MKL# open for OpenBlasBLAS :&#x3D; open# Custom (MKL&#x2F;ATLAS&#x2F;OpenBLAS) include and lib directories.# Leave commented to accept the defaults for your choice of BLAS# (which should work)!# BLAS_INCLUDE :&#x3D; &#x2F;path&#x2F;to&#x2F;your&#x2F;blas# BLAS_LIB :&#x3D; &#x2F;path&#x2F;to&#x2F;your&#x2F;blas# Homebrew puts openblas in a directory that is not on the standard search pathBLAS_INCLUDE :&#x3D; $(shell brew --prefix openblas)&#x2F;includeBLAS_LIB :&#x3D; $(shell brew --prefix openblas)&#x2F;lib# This is required only if you will compile the matlab interface.# MATLAB directory should contain the mex binary in &#x2F;bin.# MATLAB_DIR :&#x3D; &#x2F;usr&#x2F;local# MATLAB_DIR :&#x3D; &#x2F;Applications&#x2F;MATLAB_R2012b.app# NOTE: this is required only if you will compile the python interface.# We need to be able to find Python.h and numpy&#x2F;arrayobject.h.# PYTHON_INCLUDE :&#x3D; &#x2F;usr&#x2F;include&#x2F;python2.7 \# &#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;numpy&#x2F;core&#x2F;include# Anaconda Python distribution is quite popular. Include path:# Verify anaconda location, sometimes it&#39;s in root.ANACONDA_HOME :&#x3D; $(HOME)&#x2F;anaconda2PYTHON_INCLUDE :&#x3D; $(ANACONDA_HOME)&#x2F;include \ $(ANACONDA_HOME)&#x2F;include&#x2F;python2.7 \ $(ANACONDA_HOME)&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;numpy&#x2F;core&#x2F;include# Uncomment to use Python 3 (default is Python 2)# PYTHON_LIBRARIES :&#x3D; boost_python3 python3.5m# PYTHON_INCLUDE :&#x3D; &#x2F;usr&#x2F;include&#x2F;python3.5m \# &#x2F;usr&#x2F;lib&#x2F;python3.5&#x2F;dist-packages&#x2F;numpy&#x2F;core&#x2F;include# We need to be able to find libpythonX.X.so or .dylib.#PYTHON_LIB :&#x3D; &#x2F;usr&#x2F;libPYTHON_LIB :&#x3D; $(ANACONDA_HOME)&#x2F;lib# Homebrew installs numpy in a non standard path (keg only)# PYTHON_INCLUDE +&#x3D; $(dir $(shell python -c &#39;import numpy.core; print(numpy.core.__file__)&#39;))&#x2F;include# PYTHON_LIB +&#x3D; $(shell brew --prefix numpy)&#x2F;lib# Uncomment to support layers written in Python (will link against Python libs)WITH_PYTHON_LAYER :&#x3D; 1# Whatever else you find you need goes here.INCLUDE_DIRS :&#x3D; $(PYTHON_INCLUDE) &#x2F;usr&#x2F;local&#x2F;include &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv@2&#x2F;2.4.13.7_2&#x2F;includeLIBRARY_DIRS :&#x3D; $(PYTHON_LIB) &#x2F;usr&#x2F;local&#x2F;lib &#x2F;usr&#x2F;lib &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv@2&#x2F;2.4.13.7_2&#x2F;lib# If Homebrew is installed at a non standard location (for example your home directory) and you use it for general dependencies# INCLUDE_DIRS +&#x3D; $(shell brew --prefix)&#x2F;include# LIBRARY_DIRS +&#x3D; $(shell brew --prefix)&#x2F;lib# NCCL acceleration switch (uncomment to build with NCCL)# https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;nccl (last tested version: v1.2.3-1+cuda8.0)# USE_NCCL :&#x3D; 1# Uncomment to use &#96;pkg-config&#96; to specify OpenCV library paths.# (Usually not necessary -- OpenCV libraries are normally installed in one of the above $LIBRARY_DIRS.)# USE_PKG_CONFIG :&#x3D; 1# N.B. both build and distribute dirs are cleared on &#96;make clean&#96;BUILD_DIR :&#x3D; buildDISTRIBUTE_DIR :&#x3D; distribute# Uncomment for debugging. Does not work on OSX due to https:&#x2F;&#x2F;github.com&#x2F;BVLC&#x2F;caffe&#x2F;issues&#x2F;171# DEBUG :&#x3D; 1# The ID of the GPU that &#39;make runtest&#39; will use to run unit tests.TEST_GPUID :&#x3D; 0# enable pretty build (comment to see full commands)Q ?&#x3D; @ 编译 一切就绪，就可以编译了： 1234567cd ~&#x2F;caffemake allmake testmake runtestmake pycaffesource activate py27python -c &quot;import caffe&quot; 这一步，有可能以下问题：1.import caffe Segmentation fault: 11原因是caffe用的python和系统默认的不符，建议使用ananconda的python，然后在caffe的Makefile.config中设置python为anaconda的python。具体使用哪一个python可以使用which python查看。可以看到在两个环境下默认的python是不同的。2.ImportError: No module named google.protobuf.internal在py27环境下，使用anaconda安装protobuf。如果是手动编译的protobuf，需要进到protobuf目录下python文件夹，运行python setup.py install3.ImportError: No module named caffepython的搜索路径中没有caffe。在~/.bash_profile中添加export PYTHONPATH=~/caffe/python:$PYTHONPATH 成功如果import caffe没有问题，那么caffe就安装成功了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>caffe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1080 Graduate Admission （30 分)]]></title>
    <url>%2Fpost%2F80b92c6f.html</url>
    <content type="text"><![CDATA[1080 Graduate Admission （30 分)It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure. Each applicant will have to provide two grades: the national entrance exam grade G**E, and the interview grade G**I. The final grade of an applicant is (G**E+G**I)/2. The admission rules are: The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list. If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade G**E. If still tied, their ranks must be the same. Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected. If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded. Input Specification:Each input file contains one test case. Each case starts with a line containing three positive integers: N (≤40,000), the total number of applicants; M (≤100), the total number of graduate schools; and K (≤5), the number of choices an applicant may have. In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively. Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s G**E and G**I, respectively. The next Kintegers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1. Output Specification:For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly. Sample Input:1234567891011121311 6 32 1 2 2 2 3100 100 0 1 260 60 2 3 5100 90 0 3 490 100 1 2 090 90 5 1 380 90 1 0 280 80 0 1 280 80 0 1 280 70 1 3 270 80 1 2 3100 100 0 2 4 Sample Output:1234560 1035 6 72 81 4 作者: CHEN, Yue 单位: 浙江大学 时间限制: 250 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出n个学生的成绩，以及志愿，要求各个学校录取的学生，规则为：1.每个学生有Gi，Ge两门成绩，按照总分排序，总分相同按照Ge排序，如果仍相同，那么排名相同2.按照排名，判断各学生志愿。志愿按照输入顺序，如果某志愿学校有空余名额即录取该学生。3.如果排名相同的两人报了同一所学校，即便超出名额，也要同时录取两人。最后输出各学校录取的学生id，按照增序排序。 分析按照题意模拟即可。其中如果某校仍有名额，或上次录取的学生与当前学生排名相同，即录取当前学生。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n, m, k;struct stu &#123; int id; int ge; int gi; double total; int rank; vector&lt;int&gt; school;&#125;;vector&lt;int&gt; quota;vector&lt;stu&gt; stus;vector&lt;int&gt; adm[105];bool cmp(stu s1, stu s2) &#123; return s1.total != s2.total ? s1.total &gt; s2.total : s1.ge &gt; s2.ge;&#125;int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; quota.resize(m); stus.resize(n); int gi, ge; for (int i = 0; i &lt; m; i++) cin &gt;&gt; quota[i]; for (int i = 0; i &lt; n; i++) &#123; int s; stus[i].id = i; cin &gt;&gt; ge &gt;&gt; gi; stus[i].ge = ge; stus[i].gi = gi; stus[i].total = (ge + gi) / 2.0; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; s; stus[i].school.push_back(s); &#125; &#125; sort(stus.begin(), stus.end(), cmp); stus[0].rank = 1; //计算排名 for (int i = 1; i &lt; stus.size(); i++) &#123; if (stus[i].total == stus[i - 1].total &amp;&amp; stus[i].ge == stus[i - 1].ge) stus[i].rank = stus[i - 1].rank; else stus[i].rank = i + 1; &#125; //进行录取 for (int i = 0; i &lt; n; i++) &#123; for (int c:stus[i].school) &#123; if (quota[c] &gt; 0 || stus[adm[c].back()].rank == stus[i].rank) &#123; adm[c].push_back(i); quota[c]--; break; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; vector&lt;int&gt; temp; //根据stus下标得到学生id for (int id:adm[i]) temp.push_back(stus[id].id); sort(temp.begin(), temp.end()); if (!temp.empty()) &#123; cout &lt;&lt; temp[0]; for (int j = 1; j &lt; adm[i].size(); j++) cout &lt;&lt; " " &lt;&lt; temp[j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 五、其他注意第31行，取消cin/cout的同步，否则测试点4超时。或者将程序中cin/cout改成scanf/printf。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1078 Hashing （25 分)]]></title>
    <url>%2Fpost%2F72cdbcb3.html</url>
    <content type="text"><![CDATA[1078 Hashing （25 分)The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification:Each input file contains one test case. For each case, the first line contains two positive numbers: MSize (≤104) and N (≤MSize) which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead. Sample Input:124 410 6 4 15 Sample Output:10 1 4 - 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个hashtable的大小，采用平方探测法，求插入各元素的位置。当表大小不为素数时，要转化为比它大的第一个素数。 分析不算难，转化大小很简单，主要在这个平方探测上面。 是(key + step * step) % size 而不是(key % size + step * step)， 知道了这个，就比较好办了。最后一个测试点刚开始不过，查了半天，后来把main中定义的变量改成全局的就过，醉了。估计是最后一个测试点数据大，局部变量栈上分配不出空间来。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int tsize, n;int table[10010], tmp, step;bool isprime(int num) &#123; if (num == 1) return false; for (int i = 2; i * i &lt;= num; i++) if (num % i == 0) return false; return true;&#125;int main() &#123; cin &gt;&gt; tsize &gt;&gt; n; while (!isprime(tsize))tsize++; for (int i = 0; i &lt; n; i++) &#123; step = 0; cin &gt;&gt; tmp; int pos = tmp % tsize; while (pos &lt; tsize &amp;&amp; table[pos] != 0 &amp;&amp; step &lt; tsize) &#123; pos = (tmp + step * step) % tsize; step++; &#125; if (i != 0) cout &lt;&lt; ' '; if (table[pos] == 0) &#123; table[pos] = 1; cout &lt;&lt; pos; &#125; else &#123; cout &lt;&lt; '-'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1077 Kuchiguse （20 分)]]></title>
    <url>%2Fpost%2Fbb71602.html</url>
    <content type="text"><![CDATA[1077 Kuchiguse （20 分)The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification:Each input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive. Output Specification:For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write nai. Sample Input 1:12343Itai nyan~Ninjin wa iyadanyan~uhhh nyan~ Sample Output 1:1nyan~ Sample Input 2:12343Itai!Ninjinnwaiyada T_TT_T Sample Output 2:1nai 作者: HOU, Qiming 单位: 浙江大学 时间限制: 150 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一串字符串，求所有字符串的最大后缀 分析按照题意，从尾到头判断各字符串上相应位置字符是否相同即可。后缀初始化为空，如果有两字符不同且后缀为空，那么输出nai，否则输出相应后缀。当最短的字符串已经遍历完，都没有发现不同，也输出后缀。这题通过率0.2，很奇怪，感觉应该不止。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;string s[105];int main() &#123; int n,minl=9999; cin&gt;&gt;n; getchar(); for(int i=0;i&lt;n;i++) &#123; getline(cin, s[i]); if(s[i].length()&lt;minl) minl=s[i].length(); &#125; string temp=""; for(int i=1;i&lt;=minl;i++)&#123; char c=s[0][s[0].length()-i]; for(int j=1;j&lt;n;j++)&#123; if(c!=s[j][s[j].length()-i])&#123; if(temp=="") cout&lt;&lt;"nai"; else cout&lt;&lt;temp; return 0; &#125; &#125; temp=c+temp; &#125; cout&lt;&lt;temp; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1076 Forwards on Weibo （30 分)]]></title>
    <url>%2Fpost%2F8626386b.html</url>
    <content type="text"><![CDATA[1076 Forwards on Weibo （30 分)Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format: 1M[i] user_list[i] where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID‘s for query. Output Specification:For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted. Sample Input:1234567897 33 2 3 402 5 62 3 12 3 41 41 52 2 6 Sample Output:1245 作者: CHEN, Yue 单位: 浙江大学 时间限制: 3000 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个微博的关注关系网，一个用户发微博时，他的关注者都会转发，关注者的关注者继续转发，求l层内的转发数 分析虽然30分的题，但是比较简单，用bfs即可。我这里用的是邻接表的结构。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;vector&lt;int&gt; users[1010];int see[1010];int n,l,mi,tmp,k;deque&lt;int&gt; q;void cal(int root,int layer)&#123; q.push_back(root); int cnt=0; fill(see,see+1010,0); see[root]=1; while(layer--)&#123; int qsize=q.size(); while(qsize--) &#123; int cur = q.front(); q.pop_front(); for (int u:users[cur]) &#123; if (!see[u]) &#123; see[u] = 1; cnt++; q.push_back(u); &#125; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;l; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;mi; for(int j=0;j&lt;mi;j++)&#123; cin&gt;&gt;tmp; users[tmp].push_back(i); &#125; &#125; cin&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;tmp; q.clear(); cal(tmp,l); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[天坑]1075 PAT Judge （25 分)]]></title>
    <url>%2Fpost%2F9a0b3dc0.html</url>
    <content type="text"><![CDATA[[天坑]1075 PAT Judge （25 分)The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT. Input Specification:Each input file contains one test case. For each case, the first line contains 3 positive integers, N (≤104), the total number of users, K (≤5), the total number of problems, and M (≤105), the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format: 1user_id problem_id partial_score_obtained where partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space. Output Specification:For each test case, you are supposed to output the ranklist in the following format: 1rank user_id total_score s[1] ... s[K] where rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-“ must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted. The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist. Sample Input:123456789101112131415161718192021227 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0 Sample Output:123451 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 - 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出pat的提交记录，要求各个用户的排名。注意：1.按总分高至低，总分相同者名次相同。2.总分相同时，按满分题数排序。3.满分题数相同时，按照id低至高排序。4.没有提交记录者，或者都未通过编译者，不计入排序 分析用结构体user记录用户。其中有id，各题分数，满分题数，总分，是否提交、通过编译。各题初始化为-2，易于判断是未提交或未通过编译。读入各用户信息，然后排序即可。但是光这样还不够，有个地方非常隐蔽。由于编译未通过或未提交都是0分，但不输出。提交得0分是要输出的。都为0分时，按id排序，未通过编译者可能排在0分者前，导致名次错误。对应的是测试点2，这个地方卡了好久。因此，总分初始化为-1，有成功提交记录再初始化为0。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;struct user&#123; int id; vector&lt;int&gt; scr; int pfts; int tal; bool submit; bool comp; user() &#123;this-&gt;tal=-1;&#125;&#125;;bool cmp(user u1,user u2)&#123; return u1.tal!=u2.tal?u1.tal&gt;u2.tal:(u1.pfts!=u2.pfts?u1.pfts&gt;u2.pfts:u1.id&lt;u2.id);&#125;int main() &#123; int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; vector&lt;user&gt; users(n+1); int mark[k+1]; for(int i=1;i&lt;=n;i++) &#123; users[i].scr.resize(k + 1); //各题分数初始化为-2 for(int j=1;j&lt;=k;j++) users[i].scr[j]=-2; users[i].id=i; &#125; for(int i=1;i&lt;=k;i++) cin&gt;&gt;mark[i]; int uid,pid,scr; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;uid&gt;&gt;pid&gt;&gt;scr; //对应id有提交记录 users[uid].submit=true; if(scr&gt;=0) &#123; //编译通过 users[uid].comp = true; //总分初始化为0 if(users[uid].tal==-1) users[uid].tal=0; &#125; if(scr&gt;users[uid].scr[pid]) &#123; if(users[uid].scr[pid]&gt;=0)//原来已有分数，总分增加相应增量 users[uid].tal+=scr-users[uid].scr[pid]; else if(scr&gt;=0)//原来未提交或编译未通过，总分增加对应分数 users[uid].tal+=scr; users[uid].scr[pid] = scr; if(scr==mark[pid])//该题满分 users[uid].pfts++; &#125; &#125; sort(users.begin(),users.end(),cmp); int r=1; for(int i=0;i&lt;n;i++)&#123; user u=users[i]; if(u.submit&amp;&amp;u.comp) &#123; printf("%d %05d %d", r, u.id, u.tal); for (int j = 1; j &lt;= k; j++) &#123; int i = u.scr[j]; cout &lt;&lt; " "; if(i==-2) cout&lt;&lt;"-"; else if(i==-1) cout&lt;&lt;'0'; else cout&lt;&lt;i; &#125; cout &lt;&lt; endl; if (i &lt; n-1 &amp;&amp; u.tal != users[i + 1].tal) r=i+2; &#125; &#125; return 0;&#125; 其他pat的系统也非常迷，第一次提交超时，查了半天没发现哪错了，再提交又过了。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1074 Reversing Linked List （25 分)]]></title>
    <url>%2Fpost%2Fd7dc89f8.html</url>
    <content type="text"><![CDATA[1074 Reversing Linked List （25 分)Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6. Input Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N lines follow, each describes a node in the format: 1Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input:123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 Sample Output:12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个链表，给出k，要求以k为一组翻转链表 分析使用map&lt;int,node&gt;记录地址和结点，利用vector&lt;node&gt;暂存结点。从头结点开始，读取k个结点进vector，将其翻转。判断剩余结点是否大于k个。如果大于k个，则vec[0]结点的next为向后数k个结点的地址。如果小于则不翻转，对应的next为vec[k-1]的next。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;struct node&#123; int addr; int data; int next; node(int addr, int data, int next) : addr(addr), data(data), next(next) &#123;&#125; node() &#123;&#125;&#125;;map&lt;int,node&gt; list,rev;int main() &#123; int addr,data,next; int head,n,k; cin&gt;&gt;head&gt;&gt;n&gt;&gt;k; if(head==-1)&#123; cout&lt;&lt;"00000 0 -1"; return 0; &#125; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;addr&gt;&gt;data&gt;&gt;next; node n(addr,data,next); list[addr]=n; &#125; vector&lt;node&gt; vec; int temp=head,f=0; while(temp!=-1)&#123; vec.push_back(list[temp]); if(vec.size()==k)&#123; if(f==0)&#123; f=1; head=vec[k-1].addr; &#125; for(int i=k-1;i&gt;0;i--)&#123; vec[i].next=vec[i-1].addr; rev[vec[i].addr]=vec[i]; &#125; int ttemp=temp,c=0; while(list[ttemp].next!=-1&amp;&amp;c&lt;k)&#123; ttemp=list[ttemp].next; c++; &#125; if(c==k) vec[0].next=ttemp; else vec[0].next=list[temp].next; rev[vec[0].addr]=vec[0]; vec.clear(); &#125; temp=list[temp].next; &#125; if(!vec.empty()) for(auto n:vec) rev[n.addr]=n; temp=head; while(rev[temp].next!=-1)&#123; printf("%05d %d %05d\n",temp,rev[temp].data,rev[temp].next); temp=rev[temp].next; &#125; printf("%05d %d -1\n",temp,rev[temp].data); return 0;&#125; 其他注意测试点5的情况，对应 L%k=(k-1)的情况。例如7个结点，k=4。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1072 Gas Station （30 分)]]></title>
    <url>%2Fpost%2F713cd98b.html</url>
    <content type="text"><![CDATA[1072 Gas Station （30 分)A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range. Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers: N (≤103), the total number of houses; M (≤10), the total number of the candidate locations for the gas stations; K (≤104), the number of roads connecting the houses and the gas stations; and D**S, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM. Then K lines follow, each describes a road in the format 1P1 P2 Dist where P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output Specification:For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution. Sample Input 1:1234567891011124 3 11 51 2 21 4 21 G1 41 G2 32 3 22 G2 13 4 23 G3 24 G1 3G2 G1 1G3 G2 2 Sample Output 1:12G12.0 3.3 Sample Input 2:1232 1 2 101 G1 92 G1 20 Sample Output 2:1No Solution 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意有一片居民区，现在要修建一个气站。气站有m个候选点，要求气站与最近房子距离最大。如果有多个选择，选与房子平均距离最小的。如果仍有多个，选择序号小的。 分析实际上就是对m个候选点用dijkstra算法。关键在于给出的数据中，会有气站与房子，气站与气站的情况。因此得先判断输入的是房子还是气站。房子编号1-N，如果是气站，则在N之后编号。G1即为N+1，依次类推。 代码我的代码最后一个测试点不过，不知道什么原因。后来照着https://www.liuchuo.net/archives/2376 修改，大概是数组初始化的问题。这里就不贴代码了。可以参考柳婼大佬的代码。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删了一波水题]]></title>
    <url>%2Fpost%2Fae648bfe.html</url>
    <content type="text"><![CDATA[PAT还是有不少水题，完全没用到算法知识的，没什么记录的必要，干脆删了。以后碰到这种水题也不写题解了。最近又要做毕设，刷题放缓，争取毕业前能刷完PAT甲级吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1068 Find More Coins （30 分)]]></title>
    <url>%2Fpost%2Fa7b8cdfd.html</url>
    <content type="text"><![CDATA[1068 Find More Coins （30 分)Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 104 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤104, the total number of coins) and M (≤102, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the face values V1≤V2≤⋯≤V**k such that V1+V2+⋯+V**k=M. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead. Note: sequence {A[1], A[2], …} is said to be “smaller” than sequence {B[1], B[2], …} if there exists k≥1 such that A[i]=B[i] for all i&lt;k, and A[k] &lt; B[k]. Sample Input 1:128 95 9 8 7 2 3 4 1 Sample Output 1:11 3 5 Sample Input 2:124 87 2 4 3 Sample Output 2:1No Solution 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意从一堆硬币中，选出和加起来为m的硬币。并且硬币的序列要最小。如果没有相应的方案，输出”No Solution”。 分析采用深搜，加上一些优化。首先对输入进行排序，硬币由小选到大，这样找到的第一个解就是最小的。第二记录所有硬币的和，如果小于m，那么直接输出”No Solution”。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int n, m;vector&lt;int&gt; temp;int a[10005];void dfs(int i, int total) &#123; if (i == n) return; if (total + a[i] == m) &#123; temp.push_back(a[i]); cout &lt;&lt; temp[0]; for (int i = 1; i &lt; temp.size(); i++) cout &lt;&lt; " " &lt;&lt; temp[i]; exit(0); &#125; for (int j = 0; j &lt; 2; j++) &#123; if (j == 0) &#123;//选此硬币 temp.push_back(a[i]); dfs(i + 1, total + a[i]); temp.pop_back(); &#125; else if (total + a[i] &lt; m)//不选此硬币 dfs(i + 1, total); &#125;&#125;int main() &#123; int sum = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; &#125; if (sum &lt; m) cout &lt;&lt; "No Solution" &lt;&lt; endl; else &#123; sort(a, a + n); dfs(0, 0); cout &lt;&lt; "No Solution" &lt;&lt; endl; &#125; return 0;&#125; 五、其他附上一个同样是深搜，写的很好的写法：https://blog.csdn.net/sinat_29278271/article/details/48022061这道题还有动态规划的解法，参考：1.https://blog.csdn.net/xyt8023y/article/details/472552412.https://blog.csdn.net/tiantangrenjian/article/details/173342013.https://blog.csdn.net/gzxcyy/article/details/14025949]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
        <tag>动态规划</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1067 Sort with Swap(0, i) （25 分)]]></title>
    <url>%2Fpost%2F40aeb913.html</url>
    <content type="text"><![CDATA[1067 Sort with Swap(0, i) （25 分)Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: 123Swap(0, 1) &#x3D;&gt; &#123;4, 1, 2, 0, 3&#125;Swap(0, 3) &#x3D;&gt; &#123;4, 1, 2, 3, 0&#125;Swap(0, 4) &#x3D;&gt; &#123;0, 1, 2, 3, 4&#125; Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers. Input Specification:Each input file contains one test case, which gives a positive N (≤105) followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space. Output Specification:For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input:12103 5 7 2 6 4 9 0 8 1 Sample Output:19 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一组数据，每次只能和0号元素交换，问最少几次交换可以把数组变为有序 分析一开始没有什么思路，在网上找了一些解法也比较晦涩，例如柳婼のblog。可能是我太菜:(。后来找到一个思路比较直观1067. Sort with Swap(0,*) (25)。不同与第一种解法，这里的a[i]就是i位置上的元素，而不是元素i的位置，符合日常使用习惯，比较直观。当a[0]!=0时，把a[0]上的元素交换到相应位置。当a[0]==0时，找到第一个不在正确位置上的元素，交换到0位置，下一次交换即可换到正确位置上。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; int n, c=0, cnt = 0, a[100010]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; while(c&lt;n)&#123; if(a[0]==0)&#123; for(;c&lt;n&amp;&amp;a[c]==c;c++); if(c==n) break; swap(a[0],a[c]); cnt++; &#125;else&#123; swap(a[0],a[a[0]]); cnt++; &#125; &#125; cout &lt;&lt; cnt; return 0;&#125; 其他这题可以扩展一下，如果说可以交换任意两个元素而不是只能同0位置交换，那么最小交换次数是多少。可以参考使序列有序的最少交换次数]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1066 Root of AVL Tree （25 分)]]></title>
    <url>%2Fpost%2F8c97c5ef.html</url>
    <content type="text"><![CDATA[1066 Root of AVL Tree（25 分)An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, print the root of the resulting AVL tree in one line. Sample Input 1:12588 70 61 96 120 Sample Output 1:170 Sample Input 2:12788 70 61 96 120 90 65 Sample Output 2:188 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意要求根据给出的结点，构造一颗avl树，返回根结点上的值。构造相应的树即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;struct node&#123; int v; node* left; node* right; int height;&#125;;int height(node *root)&#123; return root==NULL?-1:root-&gt;height;&#125;node* rr(node* root)&#123; node*t=root-&gt;right; root-&gt;right=t-&gt;left; t-&gt;left=root; root-&gt;height=max(height(root-&gt;left),height(root-&gt;right))+1; t-&gt;height=max(height(t-&gt;left),height(t-&gt;right))+1; return t;&#125;node* ll(node* root)&#123; node*t=root-&gt;left; root-&gt;left=t-&gt;right; t-&gt;right=root; root-&gt;height=max(height(root-&gt;left),height(root-&gt;right))+1; t-&gt;height=max(height(t-&gt;left),height(t-&gt;right))+1; return t;&#125;node* rl(node* root)&#123; root-&gt;right=ll(root-&gt;right); root=rr(root); return root;&#125;node* lr(node* root)&#123; root-&gt;left=rr(root-&gt;left); root=ll(root); return root;&#125;node* insert(node* root,int v)&#123; if(root==NULL)&#123; root=new node; root-&gt;height=0; root-&gt;v=v; root-&gt;left=NULL; root-&gt;right=NULL; &#125;else if(v&gt;root-&gt;v)&#123; root-&gt;right=insert(root-&gt;right,v); if(height(root-&gt;right)-height(root-&gt;left)==2) if(v&gt;root-&gt;right-&gt;v) root=rr(root); else root=rl(root); &#125;else if(v&lt;root-&gt;v)&#123; root-&gt;left=insert(root-&gt;left,v); if(height(root-&gt;left)-height(root-&gt;right)==2) if(v&lt;root-&gt;left-&gt;v) root=ll(root); else root=lr(root); &#125; root-&gt;height=max(height(root-&gt;left),height(root-&gt;right))+1; return root;&#125;int main() &#123; int n; cin&gt;&gt;n; int v; node *root; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;v; root=insert(root,v); &#125; cout&lt;&lt;root-&gt;v&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1065 A+B and C (64bit) （20 分)]]></title>
    <url>%2Fpost%2Ffca01750.html</url>
    <content type="text"><![CDATA[1065 A+B and C (64bit) （20 分)Given three integers A, B and C in [−263,263], you are supposed to tell whether A+B&gt;C. Input Specification:The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces. Output Specification:For each test case, output in one line Case #X: true if A+B&gt;C, or Case #X: false otherwise, where X is the case number (starting from 1). Sample Input:123431 2 32 3 49223372036854775807 -9223372036854775808 0 Sample Output:123Case #1: falseCase #2: trueCase #3: false 作者: HOU, Qiming 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出64位表示的a,b,c，要求判断a+b是否&gt;c。 分析主要就在判断溢出上。a&gt;0且b&gt;0时可能发生溢出，溢出后和必小于0（因为和的最高位为1）。a]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>整数溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1064 Complete Binary Search Tree （30 分)]]></title>
    <url>%2Fpost%2Fb2e3d629.html</url>
    <content type="text"><![CDATA[1064 Complete Binary Search Tree （30 分)A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification:For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input:12101 2 3 4 5 6 7 8 9 0 Sample Output:16 3 8 1 5 7 9 0 2 4 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一组序列，要求建立完全二叉树，并输出层序遍历 分析因为是完全二叉树，已知根结点编号i(从1开始)，可知左儿子编号2i，右儿子编号2i+1。且中序遍历结果为输入序列的递增序列。从根结点开始中序遍历，又已知中序遍历结果，那么就可以知道各结点上的值。然后从1-N遍历即是层序遍历结果。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;vector&lt;int&gt; tree;vector&lt;int&gt; nodes;int n,indexx=1;void buildtree(int root)&#123; if(root&gt;n) return; int left=root*2; int right=left+1; buildtree(left); tree[root]=nodes[indexx++]; buildtree(right);&#125;int main() &#123; cin &gt;&gt; n; tree.resize(n+1); nodes.resize(n+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;nodes[i]; sort(nodes.begin(),nodes.end()); buildtree(1); cout&lt;&lt;tree[1]; for(int i=2;i&lt;=n;i++) cout&lt;&lt;" "&lt;&lt;tree[i]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>二叉树</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1063 Set Similarity （25 分)]]></title>
    <url>%2Fpost%2F7b0f3e2a.html</url>
    <content type="text"><![CDATA[1063 Set Similarity （25 分)Given two sets of integers, the similarity of the sets is defined to be N**c/N**t×100%, where N**c is the number of distinct common numbers shared by the two sets, and N**t is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets. Input Specification:Each input file contains one test case. Each case first gives a positive integer N (≤50) which is the total number of sets. Then N lines follow, each gives a set with a positive M (≤104) and followed by M integers in the range [0,109]. After the input of sets, a positive integer K (≤2000) is given, followed by K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N). All the numbers in a line are separated by a space. Output Specification:For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place. Sample Input:123456733 99 87 1014 87 101 5 877 99 101 18 5 135 18 9921 21 3 Sample Output:1250.0%33.3% 作者: CHEN, Yue 单位: 浙江大学 时间限制: 500 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一堆集合，要求给定两个集合间的相似度。相似度定义为两个集合共有元素数/两个集合总元素数。 分析这里给出元素时会有重复元素，但是重复元素是没有用的。所以使用set存储集合，方便去重。计算相似度时，假设给出两集合号为s1,s2。nc初始化为0,nt初始化为s2.size。遍历s1,在s2中寻找其元素。找到nc++,找不到则nt++。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int n,k,l,t; cin&gt;&gt;n; set&lt;int&gt; sets[55]; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;l; for(int j=0;j&lt;l;j++)&#123; cin&gt;&gt;t; sets[i].insert(t); &#125; &#125; cin&gt;&gt;k; int s1,s2; for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;s1&gt;&gt;s2; int nc=0,nt=sets[s2].size(); for(auto it=sets[s1].begin();it!=sets[s1].end();it++)&#123; if(sets[s2].find(*it)!=sets[s2].end()) nc++; else nt++; &#125; double sim=(double)nc/nt*100.0; printf("%.1f%%\n",sim); &#125; return 0;&#125; 其他这题用map，会超时，估计是因为map的插入操作比较费时。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019春]各大厂实习生招聘要求]]></title>
    <url>%2Fpost%2F50e8071e.html</url>
    <content type="text"><![CDATA[春招实习生正在招聘中，在此记录各大厂实习生招聘要求，作为方向指引，努力目标。 阿里研发工程师JAVA Software Engineer, Java岗位描述Job Description如果你想了解JAVA开发在阿里巴巴互联网生态系统中无与伦比的应用广度与深度；如果你对基础技术感兴趣，你可以参与基础软件的设计、开发和维护，如分布式文件系统、缓存系统、Key/Value存储系统、数据库、Linux操作系统和Java优化等；如果你热衷于高性能分布式技术，你可以参与高性能分布式服务端程序的系统设计，为阿里巴巴的产品提供强有力的后台支持，在海量的网络访问和数据处理中，设计并设施最强大的解决方案；如果你喜欢研究搜索技术，你可以参与搜索引擎各个功能模块的设计和实现，构建高可靠性、高可用性、高可扩展性的体系结构，满足日趋复杂的业务需求；如果你对电子商务产品技术感兴趣，你可以参与产品的开发和维护，完成从需求到设计、开发和上线等整个项目周期内的工作；如果你对数据敏感，你可以参与海量数据处理和开发，通过sql、pl/sql、java进行etl程序开发，满足商业上对数据的开发需求；如果你热衷于客户端开发，你可以参与为用户提供丰富而有价值的桌面或无线软件产品。 岗位要求Qualifications或许，你来自计算机专业，机械专业，甚至可能是学生物的；但是，你酷爱着计算机以及互联网技术，热衷于解决挑战性的问题，追求极致的用户体验；或许，你痴迷于数据结构和算法，热衷于ACM，常常为看到“accept”而兴奋的手足舞蹈；或许，你熟悉Unix/Linux/Win32环境下编程，并有相关开发经验，熟练使用调试工具，并熟悉Perl，Python，shell等脚本语言；或许，你熟悉网络编程和多线程编程，对TCP/IP，HTTP等网络协议有很深的理解，并了解XML和HTML语言；或许，你热衷于数据库技术，能够熟练编写SQL脚本，有MySql或Oracle应用开发经验；或许，你并不熟悉Java编程语言，更精通C，C++，PHP，.NET等编程语言中的一种或几种，但你有良好和快速的学习能力；有可能，你参加过大学生数学建模竞赛，“挑战杯”，机器人足球比赛等；也有可能，你在学校的时候作为骨干参与学生网站的建设和开发；这些，都是我们想要的。来吧，加入我们！ 基础平台研发工程师 Software Engineer，Systems and Infrastructure岗位描述Job Description负责云计算和大数据基础技术研发，包括不限于以下方向：1、云基础设施技术，包括研发面向百万级服务器的网络（如RDMA、可编程芯片）、服务器（如异构计算）、数据中心，以及构建超大规模的基础设施智能化运维体系（如AIOps）；2、虚拟化技术，包括XEN、KVM等开源技术的改进，以及也包括我们自研的SDN、VPC等网络虚拟化、存储虚拟化技术，还包括Docker等轻量级的容器方案；3、MySQL、PostgrelSQL、MongoDB、Redis、HBase等开源数据库内核的改进（阿里巴巴是WebScaleSQL组织的一员，并拥有多个开源项目的committer）；4、包含单集群上万个节点，多地多集群的超大规模分布式存储系统(文件系统，KVstore，BigTable等等）、分布式计算系（MapReduce，DAG，类Hive/spark的计算系统包括离线，分布式开发语言，分布式开发IDE，查询优化，流式实时计算，图计算，MPP等等）、弹性分布式资源管理和调度（海量多维度的多目标的调度系统，多个资源维度资源隔离技术等等）、机器学习平台（包括Paratemter Server，深度学习，逻辑回归等等）、异构等新型硬件上计算（包括CPU，GPU，FPGA，RDMA等等）；5、大数据在线引擎体系的目标是是集广告、搜索、推荐的投放三位于一体，在近百毫秒周期内，从服务端跨越至移动端上智能，支撑总体近TB级的模型，完成知识推理向量匹配等各种召回，以及其它深度学习的排序和预测算法，参与计算的数十亿商品保持实时更新，支持数百位算法工程师面向众多场景展开测试，在算子流图化的抽象之下，引擎内的模型和数据可随时调整布局满足迭代所需。 岗位要求Qualifications1、快速学习，不断突破技术瓶颈，乐于探索未知领域，随时准备好去面对新挑战；2、具备优秀程序员的基本素养，对代码有洁癖，遇到问题可以一查到底，善用工具，对工程效率有自己的见解；3、全栈式人才，在计算机系统结构、操作系统内核、网络、分布式系统、算法等领域有所专长相互融合；4、至少需要在一门编程语言上达到精通的水平，对编程语言不封闭，有学习新语言的兴趣。 算法工程师-自然语言处理 Algorithm Engineer, NLP岗位描述Job Description阿里巴巴广阔的商业生态需要丰富且深入的的自然语言处理技术，涵盖了从应用层的机器翻译、智能对话、智能客服、广告搜索到底层的词法分析、句法分析、语义分析、文档分析、深度文本表示、文本生成、知识库建设。阿里巴巴的自然语言处理技术正在推进平台化、服务化策略，不断追求技术的深度以及技术与业务的适当解耦。本岗位需要招聘自然语言处理专业的优秀本科、硕士、博士毕业生一起来夯实基础、赋能商业，实现技术与商业的完美结合。期待追求卓越、自我驱动、聪明、乐观、自省、皮实的优秀人士加入阿里巴巴，共同开创人工智能和大数据，云计算共同赋能的商业新格局。 具体职责包括但不限于：1、紧跟业界最新自然语言处理技术动态，深入研发并努力创新自然语言处理相关的知识库、词法、句法、语义、文档、深度学习、机器翻译、智能对话等技术，包括新颖的算法/模型的提出，模块的实际开发，对接自然语言处理平台的接入以及把高水平研发成果以论文/专利等形式进行发布；2、理解自然语言处理技术应用的相关的业务场景及需求，在自然语言处理技术内核的基础上考虑业务场景的特殊性进而适当适配业务需求；3、在核心技术研发之外，也会适当参与到具体的NLP相关业务中，例如商业场景的多语言翻译和沟通，搜索Query分析、智能对话的语义解析及意图理解、商品评价的语义理解、内容搜索推荐的结构化分析、商品搜索推荐的标签体系、社会化问答的文本分析、智能客服的场景定制等。 岗位要求Qualifications1、本科及以上学历，硕士博士优先，计算机、数学、信息管理等相关专业；2、具备极佳的工程实现能力，精通C/C++、Java、Python、Perl等至少一门语言；对目前主流的深度学习平台：tensorflow、pytorch、mxnet等，至少对其中一个有上手经验；3、精通自然语言处理领域的1到2项底层技术，有实际成果并发表在自然语言处理国际顶级会议、期刊者优先，有在相关的自然语言处理竞赛中获得优异成绩者优先；4、熟悉深度学习以及常见机器学习算法的原理与算法，能熟练运用聚类、分类、回归、排序等模型解决有挑战性的问题，有大数据处理的实战经验；5、有强烈求知欲，对人工智能领域相关技术有热情；6、具有良好的数学基础，良好的英语阅读能力；7、有团队意识，与他人合作良好，最好具有团队协作的经验。 腾讯软件开发-后台开发方向岗位描述从事腾讯产品服务后台的架构设计、开发、优化及运营工作；使用最优秀的架构设计及算法实现，在网络接入、业务运行逻辑、用户数据存储、业务数据挖掘等方向，为海量互联网用户提供稳定、安全、高效和可靠的专业后台支撑体系。 岗位要求编程基本功扎实，掌握C/C++/JAVA等开发语言、常用算法和数据结构；熟悉TCP/UDP网络协议及相关编程、进程间通讯编程；了解Python、Shell、Perl等脚本语言；了解MYSQL及SQL语言、编程，了解NoSQL, key-value存储原理；全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。 软件开发-Web开发方向岗位描述从事腾讯集团内外部web站点/系统的架构设计，方案选型及建设工作。在这里，您既有机会为海量互联网用户，也有机会为数万名腾讯员工和合作伙伴提供稳定、安全、高效和可靠的专业服务。 岗位要求熟练掌握html/css/javascript等前端技术，有jQuery、node.js等js框架使用及扩展编写经验者为佳；熟悉java/c++/python/php等主流web编程语言，接触过相应的框架并有一定的理解；了解redis/memcache等缓存中间件者优先考虑；能熟练使用MySQL/MongoDB等数据库，如有查询优化方面的经验为佳；有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识，心态好，有责任心。 软件开发-云计算开发方向岗位描述从事腾讯云产品的架构设计、开发、优化及运营工作，包括不限于以下方向：1、虚拟化技术，包括XEN、KVM等开源技术的改进；2、SDN、VPC等网络虚拟化、存储虚拟化技术，以及Docker等轻量级的容器方案；3、MySQL、PostgrelSQL、MongoDB、Redis、HBase等开源数据库内核的改进；4、超大规模分布式存储系统、分布式计算系统、弹性分布式资源管理和调度、机器学习平台；5、新型硬件在虚拟化、计算、存储上的应用（包括GPU，FPGA，RDMA等）。 岗位要求1、编程基本功扎实，精通C/C++/JAVA/GO/PHP等其中一门编程语言，有学习新语言的兴趣；2、熟悉TCP/UDP网络协议及相关编程、进程间通讯编程；3、全面、扎实的软件知识结构，掌握操作系统、计算机系统结构、设计模式、数据结构、网络安全等专业知识；4、了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识；5、快速学习，不断突破技术瓶颈，乐于探索未知领域，随时准备面对新的挑战；6、具有以下条件者优先： 1）开源社区的活跃贡献者； 2）具备公有云或企业专有云相关实践经验者。 技术研究-自然语言处理方向岗位描述腾讯拥有上亿量级的产品数据、极其丰富的产品场景、超大规模的计算资源、全谱领域的深厚技术积累、追求极致的创新氛围、适宜年轻人的企业文化，可为您提供充分的专业发挥空间，让您有可能做出影响整个互联网行业发展的优秀成果。 该岗位主要职责包括但不限于：1、 负责词法分析、自动对话、语义挖掘和语言逻辑等相关研究工作；2、 负责自然语言处理的算法研发，包括但不限于语义分析、意图识别、人机对话、机器翻译、知识图谱、命名实体识别等；3、 负责NLP前沿问题的研究，结合未来实际应用场景，提供技术解决方案。 岗位要求1、 计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，本科及以上，博士优先；2、 熟悉至少一种编程语言，包括但不限于java、C/C++、C#、python等；3、 在学术会议ACL、EMNLP、NAACL、COLING、IJCAI、AAAI等发表过文章，有深度学习学术或工程项目经验优先；4、 熟悉自然语言处理领域的1到2项底层技术，有实际成果并发表在自然语言处理国际顶级会议、期刊者优先，有在相关的自然语言处理竞赛中获得优异成绩者优先。 字节跳动大数据实习生岗位描述：1、负责字节跳动海量用户行为数据的处理，在分布式计算平台基础上建立高效、实时的数据 pipeline；2、负责推荐系统、广告系统的数据分析，发现模式与规律，为实验解释、系统改进提供数据支持；3、负责 Hadoop，Spark 等大数据基础设施和平台的改进，解决大规模生产环境集群可用性和性能优化问题。 岗位要求：1、2020年获得本科/硕士/博士及以上学历，计算机相关专业；2、热爱计算机科学和互联网技术，优秀的编码能力，乐于快速学习和尝试新技术、新工具；3、对数据敏感，掌握量化分析方法，善于从数据中发现问题，提出假设并使用数据进行验证；4、对至少一项分布式计算平台有使用经验，例如 Hadoop，Spark，Hive，Storm，Kafka 等；5、有参与开源项目对社区有贡献的经历，有互联网公司实习经历，有大数据处理或用户行为数据分析经验者优先。 算法实习生岗位描述：1、利用机器学习技术，改进头条的推荐、广告系统，优化数亿用户的阅读体验；2、分析基础数据，挖掘用户兴趣、文章价值，增强推荐、广告系统的预测能力；3、分析用户商业意图，挖掘流量潜在商业价值，提升流量变现；4、研发机器翻译与对话技术，促进跨语言内容理解与交流。 岗位要求：1、2020年获得本科/硕士/博士及以上学历，计算机、机器学习和模式识别相关专业；2、热爱计算机科学和互联网技术，对人工智能类产品有浓厚兴趣；3、具备强悍的编码能力，熟悉 linux 开发环境，熟悉 C++ 和 Python 语言优先；4、有扎实的数据结构和算法功底，熟悉机器学习、自然语言处理、数据挖掘、分布式计算、计算机视觉、计算机图形、语音识别与合成中一项5、对推荐系统、计算广告、搜索引擎、对话问答、图像和视频分析处理相关技术有经验者优先；6、优秀的分析问题和解决问题的能力，对解决具有挑战性问题充满激情。 后端开发实习生岗位描述：1、负责架构设计和开发，为亿级用户提供优质顺畅的信息服务和极致体验；2、参与设计系统技术方案，核心代码开发和系统调优；3、参与制定代码规范、测试规范，建立起开发质量控制方法；4、协助团队攻克各种高并发、数据隔离、系统解耦等方面的技术难关；5、参与各专项技术调研，新技术引入等前瞻项目；6、参与机器学习与异构计算系统研发。 岗位要求：1、2020年获得本科/硕士/博士及以上学历，计算机相关专业；2、热爱计算机科学和互联网技术，精通至少一门编程语言，包括但不仅限于：Java、C、C++、PHP、 Python、Go；3、掌握扎实的计算机基础知识，深入理解数据结构、算法和操作系统知识；4、有优秀的逻辑分析能力，能够对业务逻辑进行合理的抽象和拆分；5、有强烈的求知欲，优秀的学习和沟通能力。 美团点评后台开发工程师岗位职责如果你热爱编程，这里给你平台用代码改变世界；如果你乐于挑战，这里有用户和商家五花八门的需求和苛刻的系统运行环境在等待着你；在这里，你可以参与后端模块、数据平台、基础服务和云计算功能的开发工作；在这里，你还将参与需求定义，确定设计方案并负责最终实现！ 任职要求1.一句话，会写代码。你可以是本科及以上计算机相关专业的科班出身，也可以是自学成才的非本专业技术达人；2.至少学习并实践过一门以上的开发语言（包括但不限于：JAVA、C、C++、Python、Ruby等）；3.熟悉基础数据结构，如链表，二叉树等；4.对新技术有强烈的求知精神，能深入代码研究，能通过英文论文等第一手资料了解业界新技术；5.优秀的逻辑思维能力，善于从复杂系统表象中分析问题，对解决复杂问题充满激情。 具备以下者优先： 1.有参与各级计算机竞赛并获奖经历；2.有原创的技术博客或者开源项目或者参与过知名的开源项目；3.有在知名公司核心部门的实习经历，且实习时间不少于6个月。 机器学习/数据挖掘算法工程师岗位职责在这里，你将通过机器学习、数据挖掘、深度/增强学习前沿技术对海量O2O数据进行洞察和预测，提高线下服务效率，优化线上用户体验，人和服务的高效连接潜力无限，帮助亿万用户吃得更好生活更好；在这里，你将从海量浏览和交易数据中不断抽象模式建立模型，一手保障商户在线营销可靠安全，另一手为消费者呈现有效评价提供优质服务，用技术提升消费质量；在这里，你可以发挥你的算法天赋，在海量数据的平台上实践各种机器学习和挖掘算法，搜索、推荐、广告、调度、无人配送、风控、金融、ERP和智能化交互，为你提供最广阔的施展天地。 任职要求1.良好的数据结构和算法基础，具有较强的程序开发和分布式系统实现能力；2.熟练掌握数据库设计原理，对NoSQL和分布式计算有理解和实践；3.对概率论、机器学习和自然语言处理有一定的理论基础，在深度学习/增强学习/最优化等方向有理解或实践；4.对数据敏感，思维逻辑清晰，对业务问题充满好奇，相信大数据背后的力量。 具备以下者优先：1.具备相关行业互联网公司核心项目实习经验者优先；2.发表过相关技术方向国际顶会或核心期刊一作论文者优先；3.对大型开源软件项目有核心开发贡献者优先。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[天坑]1060 Are They Equal （25 分)]]></title>
    <url>%2Fpost%2F10cbac93.html</url>
    <content type="text"><![CDATA[1060 Are They Equal （25 分)If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×105with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification:Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100. Output Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]...d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1:13 12300 12358.9 Sample Output 1:1YES 0.123*10^5 Sample Input 2:13 120 128 Sample Output 2:1NO 0.120*10^3 0.128*10^3 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出有效位数和两个数字，要求比较这两数字用科学技术法表示后是否相同。例如题目所给3 12300 12358.9，都可以表示成0.123*10^5。 分析这道题目简直就是天坑，巨坑。判断两个数相同，需要判断系数，指数都相同。使用string存储数。 对于系数，遍历，找到第一个不为0且不为.的数字，从这个数字开始取n个数。注意需要把小数点去掉，比如1.23，n=3，那么从1开始，取123三个数。 对于指数，找到第一个不为0且不为小数点的位置nonzero，找到小数点位置dot。dot-nonzero即为指数。例如1234.5。dot=4,nonzero=0。指数为4。指数小于0时需加一。例如0.0123，dot=1，nonzero=3，指数为1-3+1=-1。 得到系数指数，判断，输出即可。还需要注意输入为0的情况，手动在0.后面补充n个0。对应最后一个测试点。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;void standform(string s,string r,int n)&#123; int dots=-1,nonzeros=-1,dotr=-1,nonzeror=-1; int c=0; string ns,nr; for(int i=0;i&lt;s.length();i++)&#123; //第一个不为0不为.的位置 if(s[i]!='.'&amp;&amp;s[i]!='0'&amp;&amp;nonzeros==-1) nonzeros = i; //从这个位置开始取n个数 if(nonzeros!=-1&amp;&amp;c&lt;n)&#123; if(s[i]!='.')&#123; ns+=s[i]; c++; &#125; &#125; //小数点位置 if(s[i]=='.') dots=i; &#125; if(dots==-1) dots=s.length(); c=0; //同样处理 for(int i=0;i&lt;r.length();i++)&#123; if(r[i]!='.'&amp;&amp;r[i]!='0'&amp;&amp;nonzeror==-1) nonzeror = i; if(nonzeror!=-1&amp;&amp;c&lt;n)&#123; if(r[i]!='.') &#123; nr += r[i]; c++; &#125; &#125; if(r[i]=='.') dotr=i; &#125; if(dotr==-1) dotr=r.length(); int exps=dots-nonzeros,expo=dotr-nonzeror; exps=exps&lt;0?exps+1:exps; expo=expo&lt;0?expo+1:expo; //处理输入为0情况 if(nonzeros==-1) &#123; ns = string(n, '0'); exps=0; &#125; if(nonzeror==-1) &#123; nr = string(n, '0'); expo=0; &#125; //输出 if(ns==nr&amp;&amp;exps==expo) cout&lt;&lt;"YES 0." + ns + "*10^" + to_string(exps); else &#123; cout&lt;&lt;"NO"; cout&lt;&lt;" 0." + ns + "*10^" + to_string(exps); cout&lt;&lt;" 0." + nr + "*10^" + to_string(expo); &#125;&#125;int main() &#123; int n; string a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; standform(a,b,n); return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1059 Prime Factors （25 分)]]></title>
    <url>%2Fpost%2Fb8ff81e3.html</url>
    <content type="text"><![CDATA[1059 Prime Factors （25 分)Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format N = p1k1×p2k2×⋯×pmk**m. Input Specification:Each input file contains one test case which gives a positive integer N in the range of long int. Output Specification:Factor N in the format N = p1^k1*p2^k2*…*p**m^k**m, where p**i‘s are prime factors of N in increasing order, and the exponent k**i is the number of p**i — hence when there is only one p**i, k**i is 1 and must NOT be printed out. Sample Input:197532468 Sample Output:197532468&#x3D;2^2*11*17*101*1291 作者: HE, Qinming 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意将一个数分解成其质因数的乘积 分析用map&lt;int,int&gt;存放质数及出现的次数。首先计算根号n内的质数，初始化为0。然后当n不等于1且n不为质数时循环，找根号n内的质因数。找到后出现次数++，并让n除等于此数。最后遍历map输出即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;bool isprime(long int i)&#123; for(long int t=2;t&lt;=sqrt(i);t++) if(i%t==0) return false; return true;&#125;int main() &#123; long int n; cin&gt;&gt;n; cout&lt;&lt;n&lt;&lt;"="; if(n==1)&#123; cout&lt;&lt;1&lt;&lt;endl; return 0; &#125; map&lt;int,int&gt; primes; for(long int i=2;i&lt;=sqrt(n);i++)&#123; if(isprime(i)) primes[i]=0; &#125; while(n!=1&amp;&amp;!isprime(n))&#123; for(auto it=primes.begin();it!=primes.end();it++)&#123; if(n%(it-&gt;first)==0) &#123; n/=(it-&gt;first); it-&gt;second++; break; &#125; &#125;&#125; if(isprime(n)) primes[n]++; int f=1; for(auto it=primes.begin();it!=primes.end();it++)&#123; if(it-&gt;second!=0) &#123; if(f==0)&#123; cout&lt;&lt;"*"; &#125; f=0; cout &lt;&lt; it-&gt;first; if(it-&gt;second!=1) cout&lt;&lt;"^"&lt;&lt;it-&gt;second; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>质因数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[未解决]1057 Stack （30 分)]]></title>
    <url>%2Fpost%2F35cc8af1.html</url>
    <content type="text"><![CDATA[1057 Stack [未解决]Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian — return the median value of all the elements in the stack. With N elements, the median value is defined to be the (N/2)-th smallest element if N is even, or ((N+1)/2)-th if N is odd. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤105). Then N lines follow, each contains a command in one of the following 3 formats: 123Push keyPopPeekMedian where key is a positive integer no more than 105. Output Specification:For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead. Sample Input:12345678910111213141516171817PopPeekMedianPush 3PeekMedianPush 2PeekMedianPush 1PeekMedianPopPopPush 5Push 4PeekMedianPopPopPopPop Sample Output:123456789101112InvalidInvalid322124453Invalid 作者: CHEN, Yue 单位: 浙江大学 时间限制: 300 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意需要实现一个能返回中位数的栈。 分析排序后返回，毫无疑问超时。网上搜了一圈，提到的全是树状数组这个东西。黑人问号。先马着，研究一会再来更新。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1056 Mice and Rice （25 分)]]></title>
    <url>%2Fpost%2F77898fa3.html</url>
    <content type="text"><![CDATA[1056 Mice and Rice （25 分)Mice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse. First the playing order is randomly decided for N**P programmers. Then every N**G programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every N**G winners are then grouped in the next match until a final winner is determined. For the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N**P and N**G (≤1000), the number of programmers and the maximum number of mice in a group, respectively. If there are less than N**G mice at the end of the player’s list, then all the mice left will be put into the last group. The second line contains N**P distinct non-negative numbers W**i (i=0,⋯,N**P−1) where each W**i is the weight of the i-th mouse respectively. The third line gives the initial playing order which is a permutation of 0,⋯,N**P−1 (assume that the programmers are numbered from 0 to N**P−1). All the numbers in a line are separated by a space. Output Specification:For each test case, print the final ranks in a line. The i-th number is the rank of the i-th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line. Sample Input:12311 325 18 0 46 37 3 19 22 57 56 106 0 8 7 10 5 9 1 4 2 3 Sample Output:15 5 5 2 5 5 5 3 1 3 5 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意这题题目比较难懂，大意如下： 给出np老鼠总数，ng每组老鼠个数。需要按照ng分组，选出最重的老鼠进入下一轮。直到冠军产生为止。 第一行给出老鼠的个数以及每组老鼠数。第二行给出各老鼠重量。第三行给出老鼠的ID。以题中数据为例，ng为3，那么6，0，8为一组，选出最重的。7，10，5为一组，同样选出最重的，依次类推。每组中最重的进入下一轮，其余淘汰。输出各老鼠的排名。在同一轮中被淘汰的老鼠排名相同。 分析利用四个vector&lt;int&gt;。winner，loser存放晋级和淘汰的老鼠id。temp存放当前所有老鼠，group存放一组老鼠。当winner不唯一时循环，每一轮的winner为下一轮考虑的temp。将temp中的老鼠按ng分组，选出最重的加入winner，其余加入loser。这样，一轮temp结束后，loser中老鼠的名次即为winner中老鼠数+1。如此循环，最后一只老鼠的排名即为1。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int weight[1010];int rankk[1010];int main() &#123; int ng,np; cin&gt;&gt;np&gt;&gt;ng; int id; for(int i=0;i&lt;np;i++) cin&gt;&gt;weight[i]; vector&lt;int&gt; loser,winner,temp,group; for(int i=0;i&lt;np;i++) &#123; cin &gt;&gt; id; winner.push_back(id); &#125; while (winner.size()!=1)&#123; temp=winner; winner.clear(); loser.clear(); group.clear(); for(int i=0;i&lt;temp.size();)&#123; int k=0,max=-1,maxid=-1; //按ng处理每组老鼠 while(k&lt;ng&amp;&amp;(i+k)&lt;temp.size())&#123; id=temp[i+k]; group.push_back(id); //选出最重的 if(weight[id]&gt;max) &#123; max=weight[id]; maxid=id; &#125; k++; &#125; i+=k; winner.push_back(maxid); for(int i:group) if(i!=maxid) loser.push_back(i); &#125; //loser老鼠排名可确定 for(int i:loser) rankk[i]=winner.size()+1; &#125; rankk[winner[0]]=1; cout&lt;&lt;rankk[0]; for(int i=1;i&lt;np;i++) cout&lt;&lt;" "&lt;&lt;rankk[i]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1055 The World's Richest （25 分)]]></title>
    <url>%2Fpost%2F9f6e2da8.html</url>
    <content type="text"><![CDATA[1055 The World’s Richest （25 分)Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤105) - the total number of people, and K (≤103) - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [−106,106]) of a person. Finally there are K lines of queries, each contains three positive integers: M (≤100) - the maximum number of outputs, and [Amin, Amax] which are the range of ages. All the numbers in a line are separated by a space. Output Specification:For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M richest people with their ages in the range [Amin, Amax]. Each person’s information occupies a line, in the format 1Name Age Net_Worth The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None. Sample Input:123456789101112131415161712 4Zoe_Bill 35 2333Bob_Volk 24 5888Anny_Cin 95 999999Williams 30 -22Cindy 76 76000Alice 18 88888Joe_Mike 32 3222Michael 5 300000Rosemary 40 5888Dobby 24 5888Billy 24 5888Nobody 5 04 15 454 30 354 5 951 45 50 Sample Output:12345678910111213141516Case #1:Alice 18 88888Billy 24 5888Bob_Volk 24 5888Dobby 24 5888Case #2:Joe_Mike 32 3222Zoe_Bill 35 2333Williams 30 -22Case #3:Anny_Cin 95 999999Michael 5 300000Alice 18 88888Cindy 76 76000Case #4:None 作者: CHEN, Yue 单位: 浙江大学 时间限制: 500 ms 内存限制: 128 MB 代码长度限制: 16 KB 题目大意给出一组富翁，再给出m,amin,amax,求年龄在amin-amax之间的前m个富翁 分析直接排序，然后遍历筛选会超时。考虑到只需要取前100个人即可，那么每个年龄段也只需要存前100个。先把所有人存储，再排序。遍历所有人，用数组book记录各年龄段的人数，超过100的不要。用一个新的vector存放筛选过的人，最后只需到筛选过的vector中遍历即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;struct richer&#123; string name; int age; int worth; richer(const string &amp;name, int age, int worth) : name(name), age(age), worth(worth) &#123;&#125;&#125;;bool cmp(richer r1,richer r2)&#123; return r1.worth!=r2.worth?r1.worth&gt;r2.worth:(r1.age!=r2.age?r1.age&lt;r2.age:r1.name&lt;r2.name);&#125;int book[201];int main() &#123; int n,k; scanf("%d %d",&amp;n,&amp;k); string name; int age,worth; vector&lt;richer&gt; billionaires; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;name; scanf("%d %d",&amp;age,&amp;worth); richer r(name,age,worth); billionaires.push_back(r); &#125; sort(billionaires.begin(),billionaires.end(),cmp); vector&lt;richer&gt; candidates; for(int i=0;i&lt;n;i++)&#123; if(book[billionaires[i].age]&lt;=100)&#123; book[billionaires[i].age]++; candidates.push_back(billionaires[i]); &#125; &#125; int m,lage,uage; for(int i=1;i&lt;=k;i++)&#123; printf("Case #%d:\n",i); scanf("%d %d %d",&amp;m,&amp;lage,&amp;uage); int t=m; for(auto r:candidates)&#123; if(r.age&gt;=lage&amp;&amp;r.age&lt;=uage)&#123; printf("%s %d %d\n",r.name.c_str(),r.age,r.worth); m--; &#125; if(m==0) break; &#125; if(t==m) printf("None\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1053 Path of Equal Weight （30 分)]]></title>
    <url>%2Fpost%2Ff9ffddd6.html</url>
    <content type="text"><![CDATA[1053 Path of Equal Weight （30 分)Given a non-empty tree with root R, and with weight W**i assigned to each tree node T**i. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L. Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure. Input Specification:Each input file contains one test case. Each case starts with a line containing 0&lt;N≤100, the number of nodes in a tree, M (&lt;N), the number of non-leaf nodes, and 0&lt;S&lt;230, the given weight number. The next line contains N positive numbers where W**i (&lt;1000) corresponds to the tree node T**i. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID‘s of its children. For the sake of simplicity, let us fix the root ID to be 00. Output Specification:For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. Note: sequence {A1,A2,⋯,A**n} is said to be greater than sequence {B1,B2,⋯,B**m} if there exists 1≤k&lt;min{n,m} such that A**i=B**i for i=1,⋯,k, and A**k+1&gt;B**k+1. Sample Input:123456789101120 9 2410 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 200 4 01 02 03 0402 1 0504 2 06 0703 3 11 12 1306 1 0907 2 08 1016 1 1513 3 14 16 1717 2 18 19 Sample Output:123410 5 2 710 4 1010 3 3 6 210 3 3 6 2 Special thanks to Zhang Yuan and Yang Han for their contribution to the judge’s data.作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一颗树以及各结点上的权值，要求根结点到叶结点路径上权值和等于给定数的路径。以非递增顺序输出。输入格式为第一行n,m,k分别代表结点数，非叶结点数，权值。第二行为各结点权值。之后各行为结点id以及该结点的子女id。 分析虽然是30分的题，但是不难，使用vector&lt;int&gt;存储子女id，使用dfs从根结点开始遍历即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;struct node&#123; int id; int weight; vector&lt;int&gt; kids;&#125;;vector&lt;node&gt; tree;vector&lt;vector&lt;int&gt;&gt; ans;int n,m,s;void dfs(int cur,int w,vector&lt;int&gt; path)&#123; //叶结点 if(tree[cur].kids.empty())&#123; if(w+tree[cur].weight==s) &#123; path.push_back(tree[cur].weight); ans.push_back(path); &#125; return; &#125; for(auto i:tree[cur].kids)&#123; path.push_back(tree[cur].weight); dfs(i,w+tree[cur].weight,path); path.pop_back(); &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; tree.resize(n); for(int i=0;i&lt;n;i++) &#123; tree[i].id=i; cin &gt;&gt; tree[i].weight; &#125; for(int i=0;i&lt;m;i++)&#123; int id,k,kid; cin&gt;&gt;id&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; cin&gt;&gt;kid; tree[id].kids.push_back(kid); &#125; &#125; vector&lt;int&gt; temp; dfs(0,0,temp); sort(ans.begin(),ans.end(),greater&lt;vector&lt;int&gt;&gt;()); for(auto v:ans) &#123; cout&lt;&lt;v[0]; for(int i=1;i&lt;v.size();i++)&#123; cout&lt;&lt;" "&lt;&lt;v[i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1052 Linked List Sorting （25 分)]]></title>
    <url>%2Fpost%2Fc24aec4a.html</url>
    <content type="text"><![CDATA[1052 Linked List Sorting （25 分)A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer keyand a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification:Each input file contains one test case. For each case, the first line contains a positive N (&lt;105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1. Then N lines follow, each describes a node in the format: 1Address Key Next where Address is the address of the node in memory, Key is an integer in [−105,105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification:For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input:1234565 0000111111 100 -100001 0 2222233333 100000 1111112345 -1 3333322222 1000 12345 Sample Output:1234565 1234512345 -1 0000100001 0 1111111111 100 2222222222 1000 3333333333 100000 -1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个链表，要求对链表进行排序 分析这题主要坑在于有些点不在链表中。因此用一个map&lt;int,node&gt;存放所有的结点，key为addr。然后从头结点开始，遍历，找出链表中的结点加入vector&lt;node&gt;。然后只需调用sort函数排序即可。 注意处理head为-1的情况，直接输出”0 -1”，否则会有一个测试点段错误。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;struct node &#123; int addr; int key; int next; node(int addr, int key, int next) : addr(addr), key(key), next(next) &#123;&#125; node() &#123;&#125;&#125;;bool cmp(node n1, node n2) &#123; return n1.key &lt; n2.key;&#125;map&lt;int, node&gt; linklist;vector&lt;node&gt; sorted;int main() &#123; int n, head; int addr, key, next; cin &gt;&gt; n &gt;&gt; head; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; addr &gt;&gt; key &gt;&gt; next; node nod(addr, key, next); linklist[addr] = nod; &#125; while (head != -1) &#123; sorted.push_back(linklist[head]); head = linklist[head].next; &#125; if (sorted.size() == 0) &#123; cout &lt;&lt; "0 -1" &lt;&lt; endl; return 0; &#125; sort(sorted.begin(), sorted.end(), cmp); printf("%d %05d\n", sorted.size(), sorted[0].addr); int i; for (i = 0; i &lt; sorted.size() - 1; i++) &#123; printf("%05d %d %05d\n", sorted[i].addr, sorted[i].key, sorted[i + 1].addr); &#125; printf("%05d %d -1\n", sorted[i].addr, sorted[i].key); return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1051 Pop Sequence （25 分)]]></title>
    <url>%2Fpost%2F2d21f028.html</url>
    <content type="text"><![CDATA[1051 Pop Sequence （25 分)Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification:Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of Nnumbers. All the numbers in a line are separated by a space. Output Specification:For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not. Sample Input:1234565 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2 Sample Output:12345YESNONOYESNO 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个栈的大小M，数字N，1-N按顺序入栈。再给出一组数字，问是否存在相应的出栈序列。 分析利用vec存放出栈序列，stack作为栈。每次比较栈顶元素是否与vec当前元素相等，不相等则入栈，判断stack中大小是否超过M，超过输出NO。相等则stack出栈并前进vec。vec遍历完后若stack为空则输出YES。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int m,n,k; vector&lt;int&gt; stack; vector&lt;int&gt; vec; cin&gt;&gt;m&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; int flag=0; int a=1; vec.clear(); stack.clear(); vec.resize(n); for(int j=0;j&lt;n;j++) cin&gt;&gt;vec[j]; for(int i=0;i&lt;n;i++) &#123; if(stack.empty()) stack.push_back(a++); while (stack.back() != vec[i]) &#123; stack.push_back(a++); if(stack.size()&gt;m) &#123; cout&lt;&lt;"NO"&lt;&lt;endl; flag=1; break; &#125; &#125; stack.pop_back(); if(flag) break; &#125; if(flag) continue; if(stack.empty()) cout&lt;&lt;"YES"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1049 Counting Ones （30 分)]]></title>
    <url>%2Fpost%2F596c73f1.html</url>
    <content type="text"><![CDATA[1049 Counting Ones （30 分)The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12. Input Specification:Each input file contains one test case which gives the positive N (≤230). Output Specification:For each test case, print the number of 1’s in one line. Sample Input:112 Sample Output:15 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给一个数N，统计从1到N的数中，数字1出现的个数 分析直接暴力，会有两个测试点超时。网上有一种数学方法，比较巧妙。思路如下： 分析N上各个位数字，统计各位上出现1的次数。记当前位数为cur（个位，百位等），当前位上的数字为curn（0-9），分为如下几种情况： curn为0。例如12035，百位为0。那么百位上出现1的数字为100-199,1100-1199,…11100-11199。共计12*100个，即为百位左边数*位数​。 curn为1。例如12135。百位上出现1的数字为100-199,…,11100-11199,12100-12135。即为百位左边数*位数+百位右边数+1​。 curn&gt;=2。例如12235。百位上出现1的数字为100-199,…,12100-12199,即为(百位左边数+1)*位数​。 从个位计算到最高位，将各位上出现1的次数相加即可。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int c = 0; int cur = 1; while (cur &lt;= n) &#123; int left = n / cur / 10; int right = n % cur; int curn = n / cur % 10; if (curn == 0) c += left * cur; else if (curn == 1) &#123; c += left * cur; c += right + 1; &#125; else &#123; c += (left + 1) * cur; &#125; cur *= 10; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 其他这题是《编程之美》上的一个题，如果我写的还不够明白，可以去书中看解析]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恭喜我喜提华中师范大学]]></title>
    <url>%2Fpost%2F672e1514.html</url>
    <content type="text"><![CDATA[去武汉复试，好几天没刷题更新了。好在结果还不错，恭喜我喜提华中师大。大二下学期之后仗着成绩还可以，荒废了许多时间，否则结果不该如此的。我诚心忏悔，幸好还有两年研究生阶段可以弥补，我必从头做人。希望能在研究生阶段找个好导师，继续深造。争取每天更新博客，笔耕不辍，记录学习历程，毕业进大厂！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1045 Favorite Color Stripe （30 分)]]></title>
    <url>%2Fpost%2F3d690383.html</url>
    <content type="text"><![CDATA[1045 Favorite Color Stripe （30 分)Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (≤200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (≤104) which is the length of the given stripe, followed by Lcolors on the stripe. All the numbers in a line a separated by a space. Output Specification:For each test case, simply print in a line the maximum length of Eva’s favorite stripe. Sample Input:12365 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6 Sample Output:17 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出喜欢的颜色顺序，从一条彩带中按序剪出喜欢的颜色，注意可以重复。其实就是可以重复的最长子序列问题。 分析类似于LCS，LCS中，s1[i]==s2[j]时，更新的方式为dp[i-1][j-1]+1，但是这里是可以重复的，因此改造为dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])当s1[i]==s2[j]时，dp[i][j]++。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int n,l,t; int dp[205][10005]; cin&gt;&gt;t&gt;&gt;n; vector&lt;int&gt; c(n+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;c[i]; cin&gt;&gt;l; vector&lt;int&gt; s(l+1); for(int i=1;i&lt;=l;i++) cin&gt;&gt;s[i]; for(int i=0;i&lt;n;i++) dp[i][0]=0; for(int i=0;i&lt;l;i++) dp[0][i]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=l;j++)&#123; dp[i][j]=max(max(dp[i-1][j-1],dp[i][j-1]),dp[i-1][j]); if(c[i]==s[j]) dp[i][j]++; &#125; &#125; cout&lt;&lt;dp[n][l]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1044 Shopping in Mars （25 分)]]></title>
    <url>%2Fpost%2Fcd24808f.html</url>
    <content type="text"><![CDATA[1044 Shopping in Mars （25 分)Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15). Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15). Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15). Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤105), the total number of diamonds on the chain, and M (≤108), the amount that the customer has to pay. Then the next line contains N positive numbers D1⋯D**N (D**i≤103 for all i=1,⋯,N) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification:For each test case, print i-j in a line for each pair of i ≤ j such that Di + … + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i. If there is no solution, output i-j for pairs of i ≤ j such that Di + … + Dj &gt;M with (Di + … + Dj −M) minimized. Again all the solutions must be printed in increasing order of i. It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1:1216 153 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13 Sample Output 1:12341-54-67-811-11 Sample Input 2:125 132 4 5 7 9 Sample Output 2:122-44-5 作者: CHEN, Yue 单位: 浙江大学 时间限制: 300 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意从给定的一组数据中，求连续数之和等于给定数的区间。如果没有相应的区间，那么输出序列和大于给定数的最小值的区间。 分析暴力易于实现，但是有两个测试点超时。网上有一种o(n)的解法，比较巧妙。思路如下： 维持一个low起点与i终点，读入i处的数。如果low与i之间的和已经超过m，那么前进low，从而减小区间和，判断和是否为m。如果和小于m，显然，i++，继续读入。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int num[100005]; int n,m,minsum=99999999,flag=0; int sum[100005]; map&lt;int,int&gt; mincut; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;num[i]; int low=0; sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]+num[i]; while(low&lt;i&amp;&amp;sum[i]-sum[low]&gt;m)&#123; //记录大于m的最小值 if(sum[i]-sum[low]&lt;minsum)&#123; mincut.clear(); mincut[low+1]=i; minsum=sum[i]-sum[low]; &#125; else if(sum[i]-sum[low]==minsum) mincut[low+1]=i; low++; &#125; if(sum[i]-sum[low]==m) &#123; flag=1; cout &lt;&lt; low + 1 &lt;&lt; "-" &lt;&lt; i &lt;&lt; endl; &#125; &#125; if(!flag)&#123; for(auto it=mincut.begin();it!=mincut.end();it++)&#123; cout&lt;&lt;it-&gt;first&lt;&lt;"-"&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1043 Is It a Binary Search Tree （25 分)]]></title>
    <url>%2Fpost%2F36ed2e5d.html</url>
    <content type="text"><![CDATA[1043 Is It a Binary Search Tree （25 分)A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:1278 6 5 7 10 8 11 Sample Output 1:12YES5 7 6 8 11 10 8 Sample Input 2:1278 10 11 8 6 7 5 Sample Output 2:12YES11 8 10 7 5 6 8 Sample Input 3:1278 6 8 5 10 9 11 Sample Output 3:1NO 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一颗树的前序遍历，求他是否为一颗二叉排序树（或镜像二叉排序树）。如是，则输出该二叉排序树的后序遍历。 分析分成两个部分解决： 判断是否为二叉排序树。isbnry函数判断s到e范围内是否为一颗二叉排序树。根据前序遍历性质，第一个结点为根结点，扫描第一个大于等于根结点的数，此数左边为左子树，右边（包括他自己）为右子树。判断右子树中，是否有小于根结点的数，如有，那必不为二叉排序树。然后，递归判断左右子树是否都为二叉排序树。判断镜像二叉树ismbnry与此类似，只不过大小关系相反。 输出后序遍历。参考Find postorder traversal of BST from preorder traversal，大意是通过控制一个区间(minval,maxval)，判断当前结点是否位于此区间内。是的话说明它是相应树的子结点。转化为了普通的树求后序方法。同样需要两个版本，输出常规的和镜像的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;vector&lt;int&gt; pre;vector&lt;int&gt; post;//左闭右开bool isbnry(int s, int e) &#123; if ((e - s) &lt;= 2) return true; int t = pre[s]; int m; for (m = s + 1; m &lt; e; m++) &#123; if (pre[m] &gt;= t) break; &#125; for (int i = m; i &lt; e; i++) &#123; if (pre[i] &lt; t) return false; &#125; return isbnry(s + 1, m - 1) &amp;&amp; isbnry(m, e);&#125;bool ismbnry(int s, int e) &#123; if ((e - s) &lt;= 2) return true; int t = pre[s]; int m; for (m = s + 1; m &lt; e; m++) &#123; if (pre[m] &lt; t) break; &#125; for (int i = m; i &lt; e; i++) &#123; if (pre[i] &gt;= t) return false; &#125; return ismbnry(s + 1, m - 1) &amp;&amp; ismbnry(m, e);&#125;void findPostOrderUtil(vector&lt;int&gt; pre, int n, int minval, int maxval, int &amp;preIndex) &#123; if (preIndex == n) return; if (pre[preIndex] &lt; minval || pre[preIndex] &gt; maxval) &#123; return; &#125; int val = pre[preIndex]; preIndex++; findPostOrderUtil(pre, n, minval, val, preIndex); findPostOrderUtil(pre, n, val, maxval, preIndex); post.push_back(val);&#125;void findmPostOrderUtil(vector&lt;int&gt; pre, int n, int minval, int maxval, int &amp;preIndex) &#123; if (preIndex == n) return; if (pre[preIndex] &lt; minval || pre[preIndex] &gt; maxval) &#123; return; &#125; int val = pre[preIndex]; preIndex++; findmPostOrderUtil(pre, n, val, maxval, preIndex); findmPostOrderUtil(pre, n, minval, val, preIndex); post.push_back(val);&#125;void findPostOrder(vector&lt;int&gt; pre, int n) &#123; int preIndex = 0; findPostOrderUtil(pre, n, -1, 99999999, preIndex);&#125;void findmPostOrder(vector&lt;int&gt; pre, int n) &#123; int preIndex = 0; findmPostOrderUtil(pre, n, -1, 99999999, preIndex);&#125;int main() &#123; int n; cin &gt;&gt; n; pre.resize(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; if (ismbnry(0, n) || isbnry(0, n)) &#123; cout &lt;&lt; "YES" &lt;&lt; endl; if (isbnry(0, n)) findPostOrder(pre, n); else findmPostOrder(pre, n); cout &lt;&lt; post[0]; for (int i = 1; i &lt; n; i++) cout &lt;&lt; " " &lt;&lt; post[i]; &#125; else cout &lt;&lt; "NO"; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1042 Shuffling Machine （20 分)]]></title>
    <url>%2Fpost%2Fb128dd07.html</url>
    <content type="text"><![CDATA[1042 Shuffling Machine （20 分)Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: 12345S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input:12236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output:1S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意一个赌场使用机器洗牌，给出洗的轮次n以及顺序，求洗完的结果。如给出4, 2, 5, 3, 1，则把第1张牌放到第4个位置，第2张牌放到第2个位置，第3张牌放到第5个位置，依次类推。 分析用vector&lt;string&gt; cards记录牌，vector&lt;int&gt; order记录第i个位置上放第几张牌，vector&lt;int&gt; shuf记录洗牌规则。循环卡牌堆，利用x暂存i，再令x=shuf[x]，循环n次，结束后第x位置上即为第i张牌。以题中例子来说： 原始牌 S3 H5 C1 D13 J2 洗一轮 J2 H5 D13 J2 C1 洗二轮 C1 H5 S3 J2 D13 shuf 4 2 5 3 1 index 1 2 3 4 5 看第二轮结果，shuf[1]=4,shuf[4]=3,第一张牌为cards[3]=C1。第二张牌始终为2。shuf[3]=5,shuf[5]=1,第三张牌为cards[1]=S3，依次类推。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int n,i; vector&lt;string&gt; cards(55); vector&lt;int&gt; shuf(55); vector&lt;int&gt; order(55); char c[4]=&#123;'S','H','C','D'&#125;; for(int i=0;i&lt;4;i++) for(int j=1;j&lt;=13;j++) cards[j+i*13]=c[i]+to_string(j); cards[53]="J1"; cards[54]="J2"; cin&gt;&gt;n; for(int i=1;i&lt;=54;i++) cin&gt;&gt;shuf[i]; for(int i=1;i&lt;=54;i++)&#123; int t=n; int x=i; while(t--) x=shuf[x]; order[x]=i; &#125; cout&lt;&lt;cards[order[1]]; for(int i=2;i&lt;=54;i++) cout&lt;&lt;" "&lt;&lt;cards[order[i]]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1040 Longest Symmetric String （25 分)]]></title>
    <url>%2Fpost%2F8e715109.html</url>
    <content type="text"><![CDATA[1040 Longest Symmetric String （25 分)Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11. Input Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification:For each test case, simply print the maximum length in a line. Sample Input:1Is PAT&amp;TAP symmetric? Sample Output:111 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一字符串，求最大对称串的长度 分析这题暴力是可以过的。i从头开始枚举，j从尾开始枚举。当s[i]==s[j]时，判断i,j之间的子串是否对称，记录下最大长度即可 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;bool issymm(string s)&#123; string ss=s; reverse(ss.begin(),ss.end()); return ss==s;&#125;int main() &#123; string s; getline(cin,s); int l=s.length(); int max=-1; for(int i=0;i&lt;l;i++)&#123; int flag=0; for(int j=l-1;j&gt;=i;j--)&#123; if(s[j]==s[i]) if(issymm(s.substr(i,j-i+1))) &#123; if(j-i+1&gt;max) &#123; max = j - i + 1; flag=1; &#125; &#125; if(flag) break; &#125; &#125; cout&lt;&lt;max;&#125; 五、其他这题还有个动态规划的解法，非常巧妙。参考柳婼のblog]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1038 Recover the Smallest Number （30 分)]]></title>
    <url>%2Fpost%2F7c027c3d.html</url>
    <content type="text"><![CDATA[1038 Recover the Smallest Number （30 分)Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87. Input Specification:Each input file contains one test case. Each case gives a positive integer N (≤104) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space. Output Specification:For each test case, print the smallest number in one line. Notice that the first digit must not be zero. Sample Input:15 32 321 3214 0229 87 Sample Output:122932132143287 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意拼接一串数字，使之最小。 分析一开始想的是类似桶排序，比较数字各位的大小，选小的放在前面。但是有点难实现。后来看到了使用cmp函数的解法，非常巧妙。有a，b两个字符串，比较a+b和b+a的大小，再利用sort函数就可以了。最后注意去除字符串开头的0。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;bool cmp(string s1,string s2)&#123; return s1+s2&lt;s2+s1;&#125;int main() &#123; int n; cin&gt;&gt;n; vector&lt;string&gt; v; string s; for(int i=0;i&lt;n;i++) &#123; cin &gt;&gt; s; v.push_back(s); &#125; sort(v.begin(),v.end(),cmp); string res=""; for(string s:v) res+=s; int i; for(i=0;i&lt;res.length();i++) if(res[i]!='0') break; if(i==res.length()) cout&lt;&lt;"0"&lt;&lt;endl; else&#123; for(;i&lt;res.length();i++) cout&lt;&lt;res[i]; &#125;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1037 Magic Coupon （25 分)]]></title>
    <url>%2Fpost%2Fd41e8f2.html</url>
    <content type="text"><![CDATA[1037 Magic Coupon （25 分)The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N‘s! For example, given a set of coupons { 1 2 4 −1 }, and a set of product values { 7 6 −2 −3 } (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop. Each coupon and each product may be selected at most once. Your task is to get as much money back as possible. Input Specification:Each input file contains one test case. For each case, the first line contains the number of coupons N**C, followed by a line with N**C coupon integers. Then the next line contains the number of products N**P, followed by a line with N**P product values. Here 1≤N**C,N**P≤105, and it is guaranteed that all the numbers will not exceed 230. Output Specification:For each test case, simply print in a line the maximum amount of money you can get back. Sample Input:123441 2 4 -147 6 -2 -3 Sample Output:143 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意有一组coupon，和一组bonus，其中各取一个数字相乘，求乘积和的最大值。贪心法即可，两个vector排序，前面均为负的相乘，后面均为正的相乘，一正一负的很显然不取。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int nc,np; vector&lt;long int&gt;coupon; vector&lt;long int&gt;bonus; cin&gt;&gt;nc; long int t; long int res=0; for(int i=0;i&lt;nc;i++)&#123; cin&gt;&gt;t; coupon.push_back(t); &#125; cin&gt;&gt;np; for(int i=0;i&lt;np;i++) &#123; cin &gt;&gt; t; bonus.push_back(t); &#125; sort(coupon.begin(),coupon.end()); sort(bonus.begin(),bonus.end()); for(int i=0,j=0;i&lt;coupon.size()&amp;&amp;j&lt;bonus.size();i++,j++)&#123; if(coupon[i]&lt;0&amp;&amp;bonus[j]&lt;0) res+=coupon[i]*bonus[j]; else break; &#125; for(int i=coupon.size()-1,j=bonus.size()-1;i&gt;=0,j&gt;=0;i--,j--)&#123; if(coupon[i]&gt;0&amp;&amp;bonus[j]&gt;0) res+=coupon[i]*bonus[j]; else break; &#125; cout&lt;&lt;res;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1033 To Fill or Not to Fill （25 分)]]></title>
    <url>%2Fpost%2F13a46793.html</url>
    <content type="text"><![CDATA[1033 To Fill or Not to Fill （25 分)With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. Input Specification:Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cma**x (≤ 100), the maximum capacity of the tank; D (≤30000), the distance between Hangzhou and the destination city; Dav**g (≤20), the average distance per unit gas that the car can run; and N (≤ 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: P**i, the unit gas price, and D**i (≤D), the distance between this station and Hangzhou, for i=1,⋯,N. All the numbers in a line are separated by a space. Output Specification:For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print The maximum travel distance = X where X is the maximum possible distance the car can run, accurate up to 2 decimal places. Sample Input 1:12345678950 1300 12 86.00 12507.00 6007.00 1507.10 07.20 2007.50 4007.30 10006.85 300 Sample Output 1:1749.17 Sample Input 2:12350 1300 12 27.10 07.00 600 Sample Output 2:1The maximum travel distance &#x3D; 1200.00 作者: ZHANG, Guochuan 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意从杭州要去一个地方，给出沿途cmax邮箱容量，D距离，Davg油耗，N沿途加油站数。接下来N行为N个加油站，给出油价及距离。问从杭州到目的地，最低的油价是多少。如果不能到达，输出能开到的最远距离。 分析一开始考虑的是动态规划，想了一会没想出来，还是参考了柳婼のblog，使用贪心算法即可，在写一些自己的理解吧。 出发时车是没油的，如果0的位置没有加油站，那么是开不动的，直接输出。 利用now记录车辆当前所在位置。每次考虑从now出发汽车能开到最远距离内的加油站。此处分为两种情况： 此范围内有比当前位置油价更便宜的加油站。那么就在当前加油站加油，加至距离正好到该加油站即可。注意这个加油站只需要是沿途第一个更便宜的就行，不需要是整个范围内最便宜的。因为开过去就能加更便宜的油。 此范围内没有更便宜的加油站。那么在当前加油站加满，并且将车开至范围内最便宜的加油站。 在终点处添加一个加油站，油价设为0。这样终点处的权重就会是最高的。 总而言之，就是考虑汽车能开到的最远距离内，哪里便宜就在哪里加油。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;struct station &#123; double price; int dis;&#125;;bool cmp(station s1, station s2) &#123; return s1.dis &lt; s2.dis;&#125;int main() &#123; int cmax, d, davg, n, inf = 9999999; //now-汽车当前位置，left-剩余油可开里程，maxtogo-能开最远距离 double now, left, maxtogo; cin &gt;&gt; cmax &gt;&gt; d &gt;&gt; davg &gt;&gt; n; double cost = 0, curprice; vector&lt;station&gt; stas(n + 1); stas[0].price = 0; stas[0].dis = d; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; stas[i].price &gt;&gt; stas[i].dis; &#125; sort(stas.begin(), stas.end(), cmp); if (stas[0].dis != 0) &#123; cout &lt;&lt; "The maximum travel distance = 0.00"; return 0; &#125; else &#123; now = 0; left = 0; curprice = stas[0].price; &#125; while (now &lt; d) &#123; maxtogo = now + davg * cmax; double minprice = inf; int flag = 0; double nextsta = 0; for (int i = 1; i &lt;= n &amp;&amp; maxtogo &gt;= stas[i].dis; i++) &#123; if (stas[i].dis &lt;= now)continue; //存在比当前更便宜的加油站，直接开过去 if (curprice &gt; stas[i].price) &#123; cost += (stas[i].dis - now - left) / davg * curprice; left = 0; now = stas[i].dis; curprice = stas[i].price; flag = 1; break; &#125; //记录沿途较便宜加油站 if (stas[i].price &lt; minprice) &#123; minprice = stas[i].price; //记录最便宜加油站位置 nextsta = stas[i].dis; &#125; &#125; //开至较便宜加油站 if (flag == 0 &amp;&amp; minprice != inf) &#123; cost += curprice * (cmax - left / davg); left = cmax * davg - (nextsta - now); curprice = minprice; now = nextsta; &#125; //无法开到任何一个加油站 if (flag == 0 &amp;&amp; minprice == inf) &#123; now += cmax * davg; printf("The maximum travel distance = %.2f", now); return 0; &#125; &#125; printf("%.2f", cost); return 0;&#125; 其他此代码在PAT上AC，但是在牛客网上测试数据非常奇葩，同一个位置有好几个不同价格的加油站，需要略加改造。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1032 Sharing （25 分)]]></title>
    <url>%2Fpost%2F11ea8a3.html</url>
    <content type="text"><![CDATA[1032 Sharing （25 分)To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1. Figure 1 You are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1). Input Specification:Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (≤105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: 1Address Data Next whereAddress is the position of the node, Data is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and Next is the position of the next node. Output Specification:For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead. Sample Input 1:1234567891011111 22222 967890 i 0000200010 a 1234500003 g -112345 D 6789000002 n 0000322222 B 2345611111 L 0000123456 e 6789000001 o 00010 Sample Output 1:167890 Sample Input 2:1234500001 00002 400001 a 1000110001 s -100002 a 1000210002 t -1 Sample Output 2:1-1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意有两个英语单词以链表形式存储，若后缀相同则公用空间。输出相同后缀的起点位置，若不存在则输出-1。 分析链表公共子结点问题。这里给的单词没有用，使用map&lt;int,int&gt;来代表一个结点，key为地址，value为next。首先遍历两个单词，得出长度l1,l2。让长度较长的单词前进abs(l1-l2)​步，然后同步前进。若遇到相同的结点，则此结点即为第一个公共结点。注意输出地址时必须使用0填充，否则测试点4错误。（一开始调了好久） 四、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; map&lt;int,int&gt; m; int s1,s2,n; int adr,nxt,l1=0,l2=0; char c; scanf("%d %d %d",&amp;s1,&amp;s2,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d %c %d",&amp;adr,&amp;c,&amp;nxt); m[adr]=nxt; &#125; int t1=s1,t2=s2; int x; while(t1!=-1)&#123; l1++; t1=m[t1]; &#125; while(t2!=-1)&#123; l2++; t2=m[t2]; &#125; if(l1&gt;l2)&#123; x=l1-l2; while(x--&gt;0) s1=m[s1]; &#125; else &#123; x=l2-l1; while(x--&gt;0) s2=m[s2]; &#125; while(s1!=-1&amp;&amp;s1!=s2) &#123; s1=m[s1]; s2=m[s2]; &#125; if(s1==-1) cout&lt;&lt;"-1"; else printf("%05d",s1); return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1031 Hello World for U （20 分)]]></title>
    <url>%2Fpost%2F948d4760.html</url>
    <content type="text"><![CDATA[1031 Hello World for U （20 分)Given any string of N (≥5) characters, you are asked to form the characters into the shape of U. For example, helloworld can be printed as: 1234h de ll rlowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible — that is, it must be satisfied that n1=n3=max { k | k≤n2 for all 3≤n2≤N } with n1+n2+n3−2=N. Input Specification:Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification:For each test case, print the input string in the shape of U as specified in the description. Sample Input:1helloworld! Sample Output:1234h !e dl llowor 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 分析将一个字符串按照u型输出。这里关键是确定n1,n2,n3的大小。注意n1=n3=max { k | k≤n2 for all 3≤n2≤N }，k是小于等于n2的使k=n1=n3的最大数，也就是n2&gt;=n1=n3。那么，当总长度+2被3整除时，n1,n2,n3相等。若有余数，则加到n2上面。使用二维数组，初始化为空格，按u型填充即可。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; string s; char c[30][30]; cin&gt;&gt;s; int l=s.length(); int n1,n2,n3; n1=n3=(l+2)/3; n2=n1+(l+2)%3; int k=0; fill(c[0],c[0]+30*30,' '); for(int i=0;i&lt;n1-1;i++) c[i][0]=s[k++]; for(int i=0;i&lt;n2;i++) c[n1-1][i]=s[k++]; for(int i=n1-2;i&gt;=0;i--) c[i][n2-1]=s[k++]; for(int i=0;i&lt;n1;i++) &#123; for (int j = 0; j &lt; n2; j++) cout &lt;&lt; c[i][j]; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1030 Travel Plan （30 分)]]></title>
    <url>%2Fpost%2Fcb81b10c.html</url>
    <content type="text"><![CDATA[1030 Travel Plan （30 分)A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: 1City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 Sample Output:10 2 3 3 40 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意图的问题。城市之间有高速公路连接，给出高速的距离及费用，求指定两城市间最短路径，如有多条，则选择花费最小的那条。 分析类似PAT.1003 Emergency，只不过那题选择征集到救援队最大的路径，这题选择花费最小的路径。从起点使用dijkstra算法即可。使用dis，cost数组记录到各城市的最短距离及最小花费。需要输出路径，使用pre[i]记录i的前驱结点。输出时利用栈即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int e[510][510];int v[510][510];int visit[510]=&#123;&#125;;int dis[510];int cost[510];int pre[510];int inf=999999999;int main() &#123; int n,m,s,d,c1,c2,co,di,minc=0,mind; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d; fill(e[0],e[0]+510*510,0); for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;di&gt;&gt;co; e[c1][c2]=e[c2][c1]=di; v[c1][c2]=v[c2][c1]=co; &#125; fill(visit,visit+510,0); fill(dis,dis+510,inf); dis[s]=0; cost[s]=0; pre[s]=s; for(int i=0;i&lt;n;i++)&#123; int u=-1; mind=inf; for(int j=0;j&lt;n;j++)&#123; if(!visit[j]&amp;&amp;dis[j]!=inf)&#123; if(dis[j]&lt;mind)&#123; u=j; mind=dis[j]; &#125; &#125; &#125; if(u==-1)break; visit[u]=1; for(int j=0;j&lt;n;j++)&#123; if(!visit[j]&amp;&amp;e[u][j]!=0)&#123; if(dis[j]&gt;dis[u]+e[u][j])&#123; dis[j]=dis[u]+e[u][j]; pre[j]=u; cost[j]=cost[u]+v[u][j]; &#125;else if(dis[j]==dis[u]+e[u][j])&#123; if(cost[j]&gt;cost[u]+v[u][j])&#123; cost[j]=cost[u]+v[u][j]; pre[j]=u; &#125; &#125; &#125; &#125; &#125; vector&lt;int&gt; temp; int i=d; while(i!=s)&#123; temp.push_back(i); i=pre[i]; &#125; cout&lt;&lt;s; while(!temp.empty())&#123; cout&lt;&lt;" "&lt;&lt;temp.back(); temp.pop_back(); &#125; cout&lt;&lt;" "&lt;&lt;dis[d]; cout&lt;&lt;" "&lt;&lt;cost[d]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dijkstra</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1029 Median （25 分)]]></title>
    <url>%2Fpost%2Fae9a4ce4.html</url>
    <content type="text"><![CDATA[1029 Median （25 分)Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13. Given two increasing sequences of integers, you are asked to find their median. Input Specification:Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (≤2×105) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int. Output Specification:For each test case you should output the median of the two given sequences in a line. Sample Input:124 11 12 13 145 9 10 15 16 17 Sample Output:113 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 1.5 MB 代码长度限制: 16 KB 题目大意给出两个递增的数组，返回两个数组并集的中位数。 分析类似Median of Two Sorted Arrays，一开始把Leetcode代码搬过来，发现内存超限。PAT这边更关注空间复杂度，Leetcode则更关注时间复杂度。这里参考柳婼 の blog的代码，但是一开始没有理解。后来想了一下，在此对其更进一步的解释： 下标从1开始，不论$(n+m)​$奇偶，中位数mid为第$(n+m+1)/2​$个数 只开一个数组存放数据，在线处理第二个数组，这样就不会超内存 使用i指向第一个数组，count计数，代表比temp小的数的数量。读入第二个数组中的数记为temp。 temp与k[i]比较，若temp较大，则增大i。此处循环，直到k[i]&gt;temp。每循环一次，都说明k[i]比temp小，count++。若count==mid，说明到k[i]为止（包括k[i]），共有$mid$个数比temp小。即temp应放在$mid+1$的位置上，k[i]即为$mid$位置上的数。 上面循环结束后，$k[i]&gt;temp$，temp应放在k[i-1]与k[i]之间的某个位置上，count++，若==mid，则temp即为$mid​$位置上数。 若仍未找到，则中位数必在第一个数组中。（此时第二个数组中数据位置都已确定，出现这种情况必然是因为还没有找到第$mid$大的数。因为第二个数组已经读取完了，剩下的数必然在第一个数组中）。此时k[i]左边有$count$个数，当$count==mid-1$时，k[i]在$mid$位置上，输出k[i] 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;int main() &#123; int k[200005]; int n,m,temp,i,count; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;k[i]); &#125; k[n + 1] = 0x7fffffff; scanf("%d",&amp;m); int mid=(n+m+1)/2; i=1; count=0; for(int j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;temp); while(k[i]&lt;temp)&#123; count++; if(count==mid) printf("%d",k[i]); i++; &#125; count++; if(count==mid) printf("%d",temp); &#125; while(i&lt;=n)&#123; if(count==mid-1) printf("%d",k[i]); count++; i++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>需复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1026 Table Tennis （30 分)]]></title>
    <url>%2Fpost%2F224a3db4.html</url>
    <content type="text"><![CDATA[1026 Table Tennis （30 分)A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours. Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day. One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the priviledge to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (≤10000) - the total number of pairs of players. Then N lines follow, each contains 2 times and a VIP tag: HH:MM:SS - the arriving time, P - the playing time in minutes of a pair of players, and tag - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players’ info, there are 2 positive integers: K (≤100) - the number of tables, and M (&lt; K) - the number of VIP tables. The last line contains M table numbers. Output Specification:For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed. Sample Input:123456789101112920:52:00 10 008:00:00 20 008:02:00 30 020:51:00 10 008:10:00 5 008:12:00 10 120:50:00 10 008:01:30 15 120:53:00 10 13 12 Sample Output:12345678908:00:00 08:00:00 008:01:30 08:01:30 008:02:00 08:02:00 008:12:00 08:16:30 508:10:00 08:20:00 1020:50:00 20:50:00 020:51:00 20:51:00 020:52:00 20:52:00 03 3 2 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意一个乒乓球馆有n个球台，当有顾客到达时，会被分配到编号最小的可用球台。如果所有球台都不可用，则需要排队等待。输出顾客到达时间，服务时间，以及等待的时间。最后输出每张球桌服务的顾客数。注意如果顾客被服务的时间晚于21点，是不输出的。 坑点： 球馆有若干张vip球台，当vip球台可用时，优先给队伍中的vip顾客使用。若队伍中无vip顾客，则vip球台可以给普通顾客使用。当有多张球台同时可以使用时，vip顾客被安排至vip球台。 分析无需算法知识，由于vip的存在，逻辑较繁琐 程序逻辑如下： 1.使用cus结构体，纪录顾客信息（到达时间，打球时间，是否vip，服务时间，是否被服务过了） 2.使用table数组，标记球桌的可用时间，初始化为8点钟。使用vip数组，标记是否vip球桌 3.被服务顾客小于n时，循环： ​ 每次循环球桌，找到第一个空闲的球桌。接着循环顾客，找到队首顾客。接着分类讨论 ​ 1.如果球桌是vip桌，则分配给队伍中第一个vip。 ​ 2.非vip桌，继续分第一个顾客是否vip。 ​ 2.1顾客是vip，且同时有vip桌可用，为其分配vip桌。 ​ 2.2队首不是vip，则分配给第一个空闲桌即可。 4.根据被服务时间排序，输出。这里注意桌号从1开始记的，一开始没注意，从0开始，顾客信息是对的，但是每桌顾客数出错，排查了好久，发现桌号是1开始。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;struct cus&#123; int arr; int play; int vip; int serv; int servd;&#125;;bool cmp(cus c1,cus c2)&#123; return c1.arr&lt;c2.arr;&#125;bool cmpbyserv(cus c1,cus c2)&#123; return c1.serv&lt;c2.serv;&#125;int main() &#123; int n,table[110]=&#123;&#125;,isvip[110]=&#123;&#125;,t,v,ts,servd=0,tableserv[110]=&#123;&#125;; cin&gt;&gt;n; vector&lt;cus&gt; que(n); for(int i=0;i&lt;n;i++)&#123; int hh,mm,ss; scanf("%d:%d:%d",&amp;hh,&amp;mm,&amp;ss); int t=hh*3600+mm*60+ss; if(t&gt;21*3600) continue; que[i].arr=t; cin&gt;&gt;que[i].play&gt;&gt;que[i].vip; if(que[i].play&gt;120) que[i].play=120; que[i].play*=60; &#125; cin&gt;&gt;ts&gt;&gt;v; for(int i=1;i&lt;=v;i++)&#123; cin&gt;&gt;t; isvip[t]=1; &#125; fill(table,table+110,8*3600); sort(que.begin(),que.end(),cmp); n=que.size(); while(servd!=n)&#123; int i,v; int choice=0; int maxt=9999999999; //第一个空闲桌 for(int i=1;i&lt;=ts;i++) &#123; if (table[i] &lt; maxt) &#123; choice = i; maxt = table[i]; &#125; &#125; for(i=0;i&lt;n;i++) if(que[i].servd==0) break; if(isvip[choice])&#123; //vip桌，分配给第一个排队的VIP for(v=0;v&lt;n;v++) &#123; if (que[v].servd == 0 &amp;&amp; que[v].vip == 1&amp;&amp;que[v].arr&lt;table[choice]) break; &#125; if(v!=n) i=v; &#125; else&#123;//非vip桌 for(v=0;v&lt;n;v++) if(que[v].servd==0) break; //第一个人是vip if(que[v].vip==1)&#123; for(int i=1;i&lt;=ts;i++) if(table[i]&lt;=que[v].arr&amp;&amp;isvip[i])&#123; choice=i; break; &#125; if(v!=n) i=v; &#125; &#125; servd++; que[i].servd=1; que[i].serv=max(que[i].arr,table[choice]); if(que[i].serv&lt;21*3600) &#123; table[choice] = que[i].serv + que[i].play; tableserv[choice]++; &#125; &#125; sort(que.begin(),que.end(),cmpbyserv); for(auto c:que)&#123; if(c.serv&lt;21*3600) &#123; int hh, mm, ss; hh = c.arr / 3600; mm = (c.arr - hh * 3600) / 60; ss = c.arr - hh * 3600 - mm * 60; printf("%02d:%02d:%02d ", hh, mm, ss); hh = c.serv / 3600; mm = (c.serv - hh * 3600) / 60; ss = c.serv - hh * 3600 - mm * 60; printf("%02d:%02d:%02d ", hh, mm, ss); double x=(c.serv - c.arr) ; cout &lt;&lt; int(x/60.0+0.5)&lt;&lt; endl; &#125; &#125; cout&lt;&lt;tableserv[1]; for(int i=2;i&lt;=ts;i++) cout&lt;&lt;" "&lt;&lt;tableserv[i]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1024 Palindromic Number （25 分)]]></title>
    <url>%2Fpost%2F7fd12b2f.html</url>
    <content type="text"><![CDATA[1024 Palindromic Number （25 分)A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484. Given any positive integer N, you are supposed to find its paired palindromic number and the number of steps taken to find it. Input Specification:Each input file contains one test case. Each case consists of two positive numbers N and K, where N (≤1010) is the initial numer and K (≤100) is the maximum number of steps. The numbers are separated by a space. Output Specification:For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K steps, just output the number obtained at the Kth step and K instead. Sample Input 1:167 3 Sample Output 1:124842 Sample Input 2:169 3 Sample Output 2:1213533 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个数，判断是否为回文数。如果不是，将其翻转+原数，得到一个新数，判断是否是回文数，如此循环。问N步之内是否可以得到回文数。 分析因数据可能很大，采用string实现大整数加法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include&lt;sstream&gt;using namespace std;bool ispal(string s1)&#123; string s2=s1; reverse(s2.begin(),s2.end()); return s1==s2?true: false;&#125;string flip(string s1)&#123; string s2=s1; reverse(s2.begin(),s2.end()); int l=s1.length(); int flag=0; for(int i=l-1;i&gt;=0;i--)&#123; int t1=s1[i]-'0'; int t2=s2[i]-'0'; int t3=t1+t2+flag; if(t3&gt;=10)&#123; flag=1; t3=t3%10; &#125; else flag=0; s1[i]=t3+'0'; &#125; if(flag==1) s1="1"+s1; return s1;&#125;int main() &#123; string n; int k,i; cin&gt;&gt;n&gt;&gt;k; for(i=0;i&lt;k;i++)&#123; if(ispal(n))&#123; cout&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;i; return 0; &#125; else&#123; n=flip(n); &#125; &#125; cout&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;i; return 0;&#125; 五、其他使用long int可过一部分测试点。 当输入196，100时，数据极大，必须使用string。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>大整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1018 Public Bike Management （30 分)]]></title>
    <url>%2Fpost%2F386c5734.html</url>
    <content type="text"><![CDATA[1018 Public Bike Management （30 分)There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city. The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well. When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen. The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at S3, we have 2 different shortest paths: PBMC -&gt; S1 -&gt; S3. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S1 and then take 5 bikes to S3, so that both stations will be in perfect conditions. PBMC -&gt; S2 -&gt; S3. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen. Input Specification:Each input file contains one test case. For each case, the first line contains 4 numbers: Cma**x (≤100), always an even number, is the maximum capacity of each station; N (≤500), the total number of stations; S**p, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers C**i (i=1,⋯,N) where each C**i is the current number of bikes at S**i respectively. Then M lines follow, each contains 3 numbers: S**i, S**j, and Tij which describe the time Tij taken to move betwen stations S**i and S**j. All the numbers in a line are separated by a space. Output Specification:For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−&gt;S1−&gt;⋯−&gt;S**p. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of S**p is adjusted to perfect. Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique. Sample Input:123456710 3 3 56 7 00 1 10 2 10 3 31 3 12 3 1 Sample Output:13 0-&gt;2-&gt;3 0 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意杭州有多个自行车站点，以及一个管理站。当站点的自行车数量是最大容量的1/2是，该站点是“平衡“的。给出问题站，管理站需要以最短的路径到达问题站，并把沿途的站点都设置为平衡的。如果有多条路径，则选择需要从站点带出自行车最少的路径，如果仍有多条，选择带回自行车最少的路径。输出带出的自行车数、路径、带回的自行车数 分析dijkstra+dfs。首先使用dijkstra计算管理站到问题站点的最短路径，使用vector&lt;int&gt;数组纪录各个站点的前序站点。然后从问题站开始dfs回出发站，计算沿途需要调整的自行车数。这里的逻辑具体为： 1.使用back纪录带回的自行车数。当一个站点的权重为正，说明有多余自行车需带回，加至back中。 2.如果权重为负，需要补充自行车，首先从back中补充，若不够则需从管理站带出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int inf = 99999999;int cmax, n, sp, m;int minNeed = inf, minBack = inf;int e[510][510], dis[510], weight[510];bool visit[510];vector&lt;int&gt; pre[510], path, temppath;void dfs(int v) &#123; temppath.push_back(v); if(v == 0) &#123; int need = 0, back = 0; for(int i = temppath.size() - 1; i &gt;= 0; i--) &#123; int id = temppath[i]; if(weight[id] &gt; 0) &#123; back += weight[id]; &#125; else &#123; if(back &gt; (0 - weight[id])) &#123; back += weight[id]; &#125; else &#123; need += ((0 - weight[id]) - back); back = 0; &#125; &#125; &#125; if(need &lt; minNeed) &#123; minNeed = need; minBack = back; path = temppath; &#125; else if(need == minNeed &amp;&amp; back &lt; minBack) &#123; minBack = back; path = temppath; &#125; temppath.pop_back(); return ; &#125; for(int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v][i]); temppath.pop_back();&#125;int main() &#123; fill(e[0],e[0]+510*510,inf); fill(dis, dis + 510, inf); cin&gt;&gt;cmax&gt;&gt;n&gt;&gt;sp&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; weight[i]; weight[i]=weight[i]-cmax/2; visit[i]= false; &#125; for(int i=0;i&lt;m;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cin&gt;&gt;e[a][b]; e[b][a]=e[a][b]; &#125; dis[0]=0; for(int i = 0; i &lt;= n; i++) &#123; int u = -1, minn = inf; for(int j = 0; j &lt;= n; j++) &#123; if(visit[j] == false &amp;&amp; dis[j] &lt; minn) &#123; u = j; minn = dis[j]; &#125; &#125; if(u == -1) break; visit[u] = true; for(int v = 0; v &lt;= n; v++) &#123; if(visit[v] == false &amp;&amp; e[u][v] != inf) &#123; if(dis[v] &gt; dis[u] + e[u][v]) &#123; dis[v] = dis[u] + e[u][v]; pre[v].clear(); pre[v].push_back(u); &#125;else if(dis[v] == dis[u] + e[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125; dfs(sp); printf("%d 0", minNeed); for(int i = path.size() - 2; i &gt;= 0; i--) printf("-&gt;%d", path[i]); printf(" %d", minBack);&#125; 其他这里必须使用dijkstra+dfs。仅一次dijkstra无法得到结果，因为路径上的需调整自行车数不满足最优子结构。必须先选出路径，然后dfs比较。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dijkstra</tag>
        <tag>图</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1021 Deepest Root （25 分)]]></title>
    <url>%2Fpost%2Fa5ed9d38.html</url>
    <content type="text"><![CDATA[1021 Deepest Root （25 分)A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤104) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers. Output Specification:For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph. Sample Input 1:1234551 21 31 42 5 Sample Output 1:123345 Sample Input 2:1234551 31 42 53 4 Sample Output 2:1Error: 2 components 作者: CHEN, Yue 单位: 浙江大学 时间限制: 2000 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意一个连通无环图可以看作一棵树，问哪些结点作为根时，此树的深度最大。如果图不连通，输出连通分量数。 分析先从一个点开始dfs，计算连通分量数，并记录最大深度的结点入temp。如果为1，则从深度最大点中一点开始dfs，得到深度最大点res，加上原来temp中点，即为所求点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n,a,b;int c=0;int visit[10010]=&#123;&#125;;vector&lt;vector&lt;int&gt;&gt; e;vector&lt;int&gt; temp;set&lt;int&gt; res;int maxd=-1;void dfs(int i,int d)&#123; visit[i]=1; if(d&gt;maxd)&#123; temp.clear(); temp.push_back(i); maxd=d; &#125; else if(d==maxd)&#123; temp.push_back(i); &#125; for(int j=0;j&lt;e[i].size();j++)&#123; if(!visit[e[i][j]]) dfs(e[i][j],d+1); &#125; return;&#125;int main() &#123; int s1; cin&gt;&gt;n; e.resize(n+1); for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;a&gt;&gt;b; e[a].push_back(b); e[b].push_back(a); &#125; for(int i=1;i&lt;=n;i++) &#123; if(!visit[i]) &#123; dfs(i, 0); c++; &#125; &#125; fill(visit,visit+10010,0); if(c==1) &#123; if(temp.size()!=0) s1=temp[0]; for(int i=0;i&lt;temp.size();i++) res.insert(temp[i]); fill(visit,visit+10010,0); maxd=-1; temp.clear(); dfs(s1,0); for(int i=0;i&lt;temp.size();i++) res.insert(temp[i]); for(auto i:res) cout&lt;&lt;i&lt;&lt;endl; &#125; else cout&lt;&lt;"Error: "&lt;&lt;c&lt;&lt;" components";&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1017 Queueing at Bank （25 分)]]></title>
    <url>%2Fpost%2F419d51d4.html</url>
    <content type="text"><![CDATA[1017 Queueing at Bank （25 分)Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤104) - the total number of customers, and K (≤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input:123456787 307:55:00 1617:00:01 207:59:59 1508:01:00 6008:00:00 3008:00:02 208:03:00 10 Sample Output:18.2 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意一家银行有k个窗口，与1014不同的是黄线内只能站一人。单个的顾客不能占用窗口超过一小时，给出窗口数，顾客到达时间以及处理时间，求所有用户的平均等待时间。银行早上8点开门，提早到的顾客必须等待，晚于17点到的顾客不会被服务，也不计入计算。 分析利用一个window数组纪录窗口可以开始服务的时间，初始化为8点。顾客进入时加上相应的处理时间即可。利用map&lt;int,int&gt;纪录顾客的到达时间以及处理时间，每次选择最早开始服务的窗口，服务最早来的顾客即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int n,k,h,m,s,wait,c=0; cin&gt;&gt;n&gt;&gt;k; double avg=0; map&lt;int,int&gt; cus; int window[110]; for(int i=0;i&lt;k;i++) window[i]=8*3600; int wt[10010]; for(int i=0;i&lt;n;i++)&#123; scanf("%d:%d:%d %d",&amp;h,&amp;m,&amp;s,&amp;wait); int t=h*3600+m*60+s; if(t&gt;17*3600) continue; if(wait&gt;60) wait=60; cus[t]=wait; &#125; double result=0; for(auto it=cus.begin();it!=cus.end();it++)&#123; int choice=0,mint=window[0],arr=it-&gt;first,pro=it-&gt;second; for(int i=1;i&lt;k;i++)&#123; if(mint&gt;window[i])&#123; mint=window[i]; choice=i; &#125; &#125; //顾客来的时间晚于窗口开放时间，不需等待 if(arr&gt;=window[choice])&#123; window[choice]=arr+pro*60; &#125;else &#123;//顾客需等待窗口可用 result+=(window[choice]-arr); window[choice]+=pro*60; &#125; &#125; if(cus.empty())&#123; printf("0.0"); return 0; &#125; printf("%.1f",result/60/cus.size());&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1016 Phone Bills （25 分)]]></title>
    <url>%2Fpost%2Fad207256.html</url>
    <content type="text"><![CDATA[1016 Phone Bills （25 分)A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Input Specification:Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number N (≤1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word on-line or off-line. For each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output Specification:For each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input:12345678910111210 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line Sample Output:12345678910CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出24小时电话费以及通话记录（时间，上下线），求各人的电话费。注意必须是上线之后接着下线才是有效数据。电话费为0的账单不输出。 分析把个人的记录按时间排序，依次处理。只有上线之后紧接着的记录为下线的是有效记录,为其生成一条账单。这里计算电话费的方式比较巧妙，参考了柳婼 の blog 的处理方法。计算从0点开始的至上线及下线时刻的话费，两个相减即为实际话费，避免了繁琐的逻辑。 代码（未AC，差测试点3未通过）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;struct record&#123; string name; int mon; int day; int hour; int mm; int t; string on; record(const string &amp;name, int mon, int day, int hour, int mm, const string &amp;on) : name(name), mon(mon), day(day), hour(hour), mm(mm), on(on) &#123;t=day*1440+hour*60+mm;&#125;&#125;;double feday=0;int fee[24];struct bill&#123; int d1,d2; int h1,h2; int m1,m2; int t; double f;&#125;;bool cmp(record r1,record r2)&#123; if(r1.t&lt;r2.t) return true; return false;&#125;double charge(record r1,record r2)&#123; double f1=(r1.day-1)*feday; double f2=(r2.day-1)*feday; for(int i=0;i&lt;r1.hour;i++) f1+=60*fee[i]; for(int i=0;i&lt;r2.hour;i++) f2+=60*fee[i]; f1+=r1.mm*fee[r1.hour]; f2+=r2.mm*fee[r2.hour]; return (f2-f1)/100;&#125;int main() &#123; string name,on; vector&lt;string&gt; names; int mon,day,hour,mm; map&lt;string,vector&lt;bill&gt;&gt; bills; map&lt;string,vector&lt;record&gt;&gt; maps; for(int i=0;i&lt;24;i++) &#123; cin &gt;&gt; fee[i]; feday+=fee[i]*60; &#125; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;name; scanf("%d:%d:%d:%d",&amp;mon,&amp;day,&amp;hour,&amp;mm); cin&gt;&gt;on; if(find(names.begin(),names.end(),name)==names.end()) names.push_back(name); record r(name,mon,day,hour,mm,on); maps[name].push_back(r); &#125; sort(names.begin(),names.end()); for(string name:names)&#123; vector&lt;record&gt; vecname=maps[name]; sort(vecname.begin(),vecname.end(),cmp); for(auto it=vecname.begin()+1;it!=vecname.end();it++)&#123; if(it-&gt;on=="off-line"&amp;&amp;(it-1)-&gt;on=="on-line")&#123; bill nb; nb.d2=it-&gt;day; nb.d1=(it-1)-&gt;day; nb.h2=it-&gt;hour; nb.h1=(it-1)-&gt;hour; nb.m2=it-&gt;mm; nb.m1=(it-1)-&gt;mm; nb.f=charge(*(it-1),*it); nb.t=it-&gt;t-(it-1)-&gt;t; bills[name].push_back(nb); &#125; &#125; &#125; for(string name:names)&#123; double ff=0; vector&lt;bill&gt; v=bills[name]; for(bill b:v) ff+=b.f; if(ff&gt;=0&amp;&amp;!v.empty()) &#123; cout &lt;&lt; name; printf(" %02d\n", mon); for (bill b:v) printf("%02d:%02d:%02d %02d:%02d:%02d %02d $%.2f\n", b.d1, b.h1, b.m1, b.d2, b.h2, b.m2, b.t, b.f); printf("Total amount: $%.2f\n", ff); &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1019 General Palindromic Number （20 分)]]></title>
    <url>%2Fpost%2F2a33b876.html</url>
    <content type="text"><![CDATA[1019 General Palindromic Number （20 分)A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0 in base b≥2, where it is written in standard notation with k+1 digits a**i as ∑i=0k(aib**i). Here, as usual, 0≤a**i&lt;b for all i and a**k is non-zero. Then N is palindromic if and only if a**i=a**k−i for all i. Zero is written 0 in any base and is also palindromic by definition. Given any positive decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b. Input Specification:Each input file contains one test case. Each case consists of two positive numbers N and b, where 0&lt;N≤109 is the decimal number and 2≤b≤109 is the base. The numbers are separated by a space. Output Specification:For each test case, first print in one line Yes if N is a palindromic number in base b, or No if not. Then in the next line, print N as the number in base bin the form “a**k a**k−1 … a0”. Notice that there must be no extra space at the end of output. Sample Input 1:127 2 Sample Output 1:12Yes1 1 0 1 1 Sample Input 2:1121 5 Sample Output 2:12No4 4 1 鸣谢网友“CCPC拿不到牌不改名”修正数据！ 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个十进制数及进制，要求判断该进制下该数是否为回文数 分析使用一个vector&lt;int&gt;，纪录转换后的各位数字，判断是否回文即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;vector&lt;int&gt; v1;void change(int n,int radix)&#123; if(n==0) &#123; v1.push_back(0); return; &#125; int m=0; while(n&gt;=pow(radix,m))m++; for(int i=m-1;i&gt;=0;i--)&#123; int base=pow(radix,i); int d=n/base; n-=d*base; v1.push_back(d); &#125; return ;&#125;int main() &#123; int n,b,l; bool is=true; cin&gt;&gt;n&gt;&gt;b; change(n,b); l=v1.size(); for(int i=0;i&lt;l/2;i++)&#123; if(v1[i]!=v1[l-1-i]) is=false; &#125; if(is) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; cout&lt;&lt;v1[0]; for(int i=1;i&lt;l;i++) cout&lt;&lt;" "&lt;&lt;v1[i]; &#125; 其他这里存储必须使用vector，而不能使用string。若采用string，因为转换后的数字是采用十进制表示的（例如16进制中的12，计为12而不是c。因为 1.需要转换为字母很烦 2.第二进制数大了之后字母也不够用。 如果采用vector，则12为一个整体，如采用string，则12变为2个数了，显然达不到判断回文的目的。]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1015 Reversible Primes （20 分)]]></title>
    <url>%2Fpost%2F1018a8cc.html</url>
    <content type="text"><![CDATA[1015 Reversible Primes （20 分)A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime. Now given any two positive integers N (&lt;105) and D (1&lt;D≤10), you are supposed to tell if N is a reversible prime with radix D. Input Specification:The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N. Output Specification:For each test case, print in one line Yes if N is a reversible prime with radix D, or No if not. Sample Input:123473 1023 223 10-2 Sample Output:123YesYesNo 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个数n以及进制d，要求判断n以及n在d进制翻转后是否都是素数。 分析读取n，判断是否为素数。如是则转换为相应进制再翻转，转换为10进制判断是否为素数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;string change(int n,int radix)&#123; if(radix==1) return NULL; int m=0; string ans=""; while(n&gt;=pow(radix,m))m++; for(int i=m-1;i&gt;=0;i--)&#123; int base=pow(radix,i); int d=n/base; n-=d*base; ans+=to_string(d); &#125; return ans;&#125;int go_back(string s,int radix)&#123; int n=0; int l=s.length(); for(int i=0;i&lt;l;i++)&#123; int d=s[i]-'0'; n+=d*pow(radix,l-i-1); &#125; return n;&#125;bool isprime(int n)&#123; if(n&lt;=1) return false; int k=sqrt(n); for(int i=2;i&lt;=k;i++)&#123; if(n%i==0) return false; &#125; return true;&#125;int main() &#123; std::ios::sync_with_stdio(false); int n,radix; while(cin&gt;&gt;n&amp;&amp;n&gt;0)&#123; cin&gt;&gt;radix; if(isprime(n))&#123; string s=change(n,radix); reverse(s.begin(),s.end()); //cout&lt;&lt;s&lt;&lt;endl; int ans=go_back(s,radix); //cout&lt;&lt;ans&lt;&lt;endl; if(isprime(ans)) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; &#125; else cout&lt;&lt;"No"&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1014 Waiting in Line （30 分)]]></title>
    <url>%2Fpost%2F46e936eb.html</url>
    <content type="text"><![CDATA[1014 Waiting in Line （30 分)Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M customers. Hence when all the N lines are full, all the customers after (and including) the (N**M+1)st one will have to wait in a line behind the yellow line. Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. Customeri will take T**i minutes to have his/her transaction processed. The first N customers are assumed to be served at 8:00am. Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 custmers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, custome**r1 is served at windo**w1 while custome**r2 is served at windo**w2. Custome**r3 will wait in front of windo**w1 and custome**r4 will wait in front of windo**w2. Custome**r5 will wait behind the yellow line. At 08:01, custome**r1 is done and custome**r5 enters the line in front of windo**w1 since that line seems shorter now. Custome**r2 will leave at 08:02, custome**r4 at 08:06, custome**r3 at 08:07, and finally custome**r5 at 08:10. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers: N (≤20, number of windows), M (≤10, the maximum capacity of each line inside the yellow line), K (≤1000, number of customers), and Q (≤1000, number of customer queries). The next line contains K positive integers, which are the processing time of the K customers. The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K. Output Specification:For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorryinstead. Sample Input:1232 2 7 51 2 6 4 3 534 23 4 5 6 7 Sample Output:1234508:0708:0608:1017:00Sorry 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意一家银行有n个窗口，每个窗口有一个黄线，黄线之内可以排m位顾客。顾客总是会选择最短的（不是最早结束的队伍）且编号最小的队伍。给出窗口数，黄线内可排队数，顾客数，顾客到达的时间以及处理时间，要求输出顾客结束服务的时间。注意银行在下午5点关门，这个时间之后顾客没有开始被服务，则需输出sorry。 分析利用结构体模拟队列，记录该队列结束服务的时间以及队伍长度及排队顾客。每次选择最短的队伍，让顾客入队。若队长为m，说明所有队伍已满，选择最早结束的队伍出队，出队时队首顾客结束时间即为队列原结束时间加上其处理时间。最后将所有队伍中的顾客都出队，记录顾客结束时间。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;struct line&#123; int endtime=0; deque&lt;int&gt; q=&#123;&#125;;&#125;;int main() &#123; //std::ios::sync_with_stdio(false); int choice; int n, m, k, q, out, cur; int pro[1010] = &#123;&#125;, fin[1010] = &#123;&#125;; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; pro[i]; line lines[n]; for (int i = 1; i &lt;= k; i++) &#123; int minl = m + 1; int mint = 9999999; for (int j = 0; j &lt; n; j++) &#123; line l = lines[j]; int ll = l.q.size(); if (minl &gt; ll) &#123; choice = j; minl = l.q.size(); &#125; &#125; if (minl == m) &#123; for (int j = 0; j &lt; n; j++) &#123; line l = lines[j]; if (mint &gt; l.endtime + pro[l.q.front()]) &#123; mint = l.endtime + pro[l.q.front()]; choice = j; &#125; &#125; &#125; if (lines[choice].q.size() == m) &#123; out = lines[choice].q.front(); lines[choice].q.pop_front(); fin[out] = lines[choice].endtime + pro[out]; lines[choice].endtime += pro[out]; &#125; lines[choice].q.push_back(i); &#125; for (int i = 0; i &lt; n; i++) &#123; while (!lines[i].q.empty()) &#123; int out = lines[i].q.front(); fin[out] = lines[i].endtime + pro[out]; lines[i].endtime += pro[out]; lines[i].q.pop_front(); &#125; &#125; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; cur; int hh = 8 + fin[cur] / 60; int mm = fin[cur] % 60; if (fin[cur] &lt;= 540 || (fin[cur] - pro[cur]) &lt; 540) printf("%02d:%02d\n", hh, mm); else printf("Sorry\n"); &#125;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1013 Battle Over Cities （25 分)]]></title>
    <url>%2Fpost%2F4f2634bb.html</url>
    <content type="text"><![CDATA[1013 Battle Over Cities （25 分)It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly. For example, if we have 3 cities and 2 highways connecting cit**y1-cit**y2 and cit**y1-cit**y3. Then if cit**y1 is occupied by the enemy, we must have 1 highway repaired, that is the highway cit**y2-cit**y3. Input Specification:Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern. Output Specification:For each of the K cities, output in a line the number of highways need to be repaired if that city is lost. Sample Input:12343 2 31 21 31 2 3 Sample Output:123100 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意有n座城市，其中一座被敌军攻占，需修多少路可以将剩余城市连接起来。 分析利用dfs求图的连通分量数即可。被攻占的城市visit初始化为1。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n;bool visit[1010]=&#123;&#125;;int graph[1010][1010]=&#123;&#125;;void dfs(int node) &#123; visit[node] = true; for(int i = 1; i &lt;= n; i++) &#123; if(visit[i] == false &amp;&amp; graph[node][i] == 1) dfs(i); &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); int m,k,c1,c2,t,cnt=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;c1&gt;&gt;c2; graph[c1][c2]=graph[c2][c1]=1; &#125; for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;t; cnt=0; fill(visit,visit+1010,0); visit[t]=1; for(int j=1;j&lt;=n;j++)&#123; if(visit[j]==0)&#123; dfs(j); cnt++; &#125; &#125; cout&lt;&lt;cnt-1&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>dfs</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1010 Radix （25 分)]]></title>
    <url>%2Fpost%2F56e2a354.html</url>
    <content type="text"><![CDATA[1010 Radix （25 分)Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Input Specification:Each input file contains one test case. Each case occupies a line which contains 4 positive integers: 1N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2. Output Specification:For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix. Sample Input 1:16 110 1 10 Sample Output 1:12 Sample Input 2:11 ab 1 2 Sample Output 2:1Impossible 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出n1,n2,tag,radix，问是否存在某一进制，使其中一个数在该进制下与tag代表的那个数在radix进制下相等。如果存在多个进制符合要求，那么输出最小的那个。 分析进制转换问题，但是这里寻找进制必须使用二分法，否则会超时。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;long long cal(string s1, long long radix)&#123; int l=s1.length(); long long num=0; int temp; for(int i=0;i&lt;l;i++)&#123; if(s1[i]&lt;='9'&amp;&amp;s1[i]&gt;='0') temp=(s1[i] - '0'); else if(s1[i]&gt;='a'&amp;&amp;s1[i]&lt;='z') &#123; temp=(s1[i] - 'a' + 10); &#125; num += temp * pow(radix, l - i - 1); &#125; return num;&#125;long long find_radix(string s1,long long num)&#123; char ch=*max_element(s1.begin(),s1.end()); long long low=(isdigit(ch)?ch-'0':ch-'a'+10)+1; long long high=max(num,low); long long t; while(low&lt;=high)&#123; long long mid=low+(high-low)/2; t=cal(s1,mid); if(t==num) return mid; else if(t&gt;num||t&lt;0) high=mid-1; else low=mid+1; &#125; return -1;&#125;int main() &#123; string s[3]; int tag,last; long long radix; cin&gt;&gt;s[1]&gt;&gt;s[2]&gt;&gt;tag&gt;&gt;radix; long long num[3]=&#123;&#125;; num[tag]=cal(s[tag],radix); int other=(tag==1?2:1); long long low,high; radix=find_radix(s[other],num[tag]); if(radix!=-1) cout&lt;&lt;radix; else cout&lt;&lt;"Impossible";&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1009 Product of Polynomials （25 分)]]></title>
    <url>%2Fpost%2F2598ae52.html</url>
    <content type="text"><![CDATA[1009 Product of Polynomials （25 分)This time, you are supposed to find A×B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 a**N1 N2 a**N2 … N**K aNK where K is the number of nonzero terms in the polynomial, N**i and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10, 0≤N**K&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 3 3.6 2 6.0 1 1.6 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意输入指数和系数代表两个多项式，要求输出相乘之后的结果 分析使用结构体po代表一项，利用vector存储po代表一个多项式。先缓存第一个，然后在线处理第二个，将每一项相乘的结果存入res，合并指数相同的项即可。注意系数为0的项不输出。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;struct po&#123; int n; double an; po(int n, double an) : n(n), an(an) &#123;&#125;&#125;;bool cmp(po p1,po p2)&#123; if(p1.n&gt;p2.n) return true; return false;&#125;int main() &#123; int k; int n,c=0; double an; cin&gt;&gt;k; vector&lt;po&gt; temp; vector&lt;po&gt; res; for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;n&gt;&gt;an; temp.push_back(po(n,an)); &#125; cin&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;n&gt;&gt;an; for(auto it=temp.begin();it!=temp.end();it++)&#123; int f=0; po p(n+it-&gt;n,an*it-&gt;an); for(auto itt=res.begin();itt!=res.end();itt++)&#123; if(itt-&gt;n==p.n) &#123; itt-&gt;an += p.an; f=1; &#125; &#125; if(f) continue; res.push_back(p); &#125; &#125; sort(res.begin(),res.end(),cmp); for(po p:res) &#123; if(p.an!=0) c++; &#125; cout&lt;&lt;c; for(po p:res)&#123; if(p.an!=0) // cout&lt;&lt;" "&lt;&lt;p.n&lt;&lt;" "&lt;&lt;p.an; printf(" %d %.1f",p.n,p.an); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1007 Maximum Subsequence Sum （25 分)]]></title>
    <url>%2Fpost%2F5865b9ca.html</url>
    <content type="text"><![CDATA[1007 Maximum Subsequence Sum （25 分)Given a sequence of K integers { N1, N2, …, N**K }. A continuous subsequence is defined to be { N**i, N**i+1, …, N**j } where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains Knumbers, separated by a space. Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input:1210-10 1 2 3 4 -5 -23 3 7 -21 Sample Output:110 1 4 作者: CHEN, Yue 单位: 浙江大学 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意最大子序列和问题，输出最大和以及相应区间的下标 分析这个是经典问题了，参见《数据结构与算法分析》，略加改造记录区间下标即可 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int k; cin&gt;&gt;k; int num[10010]; for(int i=0;i&lt;k;i++) cin&gt;&gt;num[i]; int start=0,end=0,maxsum=-99999999,thissum=0,tempstart=num[0]; for(int i=0;i&lt;k;i++)&#123; thissum+=num[i]; if(thissum&gt;maxsum) &#123; maxsum = thissum; end=num[i]; start=tempstart; &#125; if(thissum&lt;=0) &#123; thissum = 0; tempstart=num[i+1]; &#125; &#125; if(maxsum&lt;0)&#123; maxsum=0; start=num[0]; end=num[k-1]; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;start&lt;&lt;" "&lt;&lt;end; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>最大子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004 Counting Leaves （30 分)]]></title>
    <url>%2Fpost%2F350f669a.html</url>
    <content type="text"><![CDATA[1004 Counting Leaves （30 分)A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. Input Specification:Each input file contains one test case. Each case starts with a line containing 0&lt;N&lt;100, the number of nodes in a tree, and M (&lt;N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID‘s of its children. For the sake of simplicity, let us fix the root ID to be 01. The input ends with N being 0. That case must NOT be processed. Output Specification:For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line. Sample Input:122 101 1 02 Sample Output:10 1 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出n,m代表树的节点数以及非叶结点树，接下来输入m行，每行格式id k id[1] id[2]..代表id结点的k个儿子。要求层序输出各层无儿子结点的数量。 分析利用vector&lt;int&gt;数组存储各结点的儿子号，利用lay数组记录结点所在的层数，利用bfs输出结果 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int n,m,cur,k,t,maxlay=-1; int lay[110]=&#123;&#125;,res[110]=&#123;&#125;; cin&gt;&gt;n&gt;&gt;m; if(n==0) return 0; vector&lt;int&gt; vec[110]; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;cur&gt;&gt;k; for(int j=0;j&lt;k;j++)&#123; cin&gt;&gt;t; vec[cur].push_back(t); &#125; &#125; lay[1]=0; deque&lt;int&gt; que; que.push_back(1); while(!que.empty())&#123; cur=que.front(); que.pop_front(); //记录树的深度 maxlay=max(maxlay,lay[cur]); if(vec[cur].empty())&#123;//该结点无儿子 res[lay[cur]]++; &#125; else for(int a:vec[cur])&#123;//将该结点的儿子入队，儿子的层数=父亲层数+1 que.push_back(a); lay[a]=lay[cur]+1; &#125; &#125; cout&lt;&lt;res[0]; for(int i=1;i&lt;=maxlay;i++) cout&lt;&lt;" "&lt;&lt;res[i]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003 Emergency （25 分)]]></title>
    <url>%2Fpost%2Fc97238be.html</url>
    <content type="text"><![CDATA[1003 Emergency （25 分)As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:12 4 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出一个图，以及各结点上的救援队数量。需要从一个点以最短路径到达另一个点，输出最短路径数，以及路上可以征集到的最大的救援队数量。 分析利用dijkstra算法，计算最短路径的条数，同时记录路上收集的救援队数量 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int n,m,c1,c2; int inf=INT32_MAX; cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2; int e[510][510]; int weight[510],visitied[510],dis[510],num[510],w[510]; fill(e[0],e[0]+510*510,inf); for(int i=0;i&lt;n;i++)&#123; visitied[i]=num[i]=0; dis[i]=inf; &#125; for(int i=0;i&lt;n;i++) cin&gt;&gt;weight[i]; for(int i=0;i&lt;m;i++)&#123; int from,to; cin&gt;&gt;from&gt;&gt;to; cin&gt;&gt;e[from][to]; e[to][from]=e[from][to]; &#125; dis[c1]=0; w[c1]=weight[c1]; num[c1]=1; for(int i=0;i&lt;n;i++)&#123; int u=-1,minn=inf; for(int j=0;j&lt;n;j++)&#123; if(!visitied[j]&amp;&amp;dis[j]&lt;minn) &#123; u=j; minn=dis[j]; &#125; &#125; if(u==-1) break; visitied[u]=1; for(int j=0;j&lt;n;j++)&#123; if(!visitied[j]&amp;&amp;e[u][j]!=inf) &#123; if (dis[j] &gt; dis[u] + e[u][j]) &#123;//经u路径更短 dis[j] = dis[u] + e[u][j]; num[j]=num[u]; w[j]=w[u]+weight[j]; &#125; else if(dis[u]+e[u][j]==dis[j])&#123;//经u中转至j，最短路径相同 num[j]+=num[u]; if(w[j]&lt;w[u]+weight[j]) w[j]=w[u]+weight[j]; &#125; &#125; &#125; &#125; cout&lt;&lt;num[c2]&lt;&lt;" "&lt;&lt;w[c2]; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>dijkstra</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002 A+B for Polynomials （25 分)]]></title>
    <url>%2Fpost%2F48285522.html</url>
    <content type="text"><![CDATA[1002 A+B for Polynomials （25 分)This time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 a**N1 N2 a**N2 … N**K aNK where K is the number of nonzero terms in the polynomial, N**i and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤N**K&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意给出多项式（指数，系数），求多项式的和 分析利用结构体po存储一项，vector&lt;po&gt;存储一个多项式，相加后排序输出即可。系数为0的项不输出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class po&#123;public: int n; double an; po(double n, double an) : n(n), an(an) &#123;&#125;&#125;;int cmp(po a,po b)&#123; if(a.n&gt;b.n) return true; return false;&#125;int main() &#123; int k1,k2,n; double an; cin&gt;&gt;k1; vector&lt;po&gt; p; for(int i=0;i&lt;k1;i++)&#123; cin&gt;&gt;n&gt;&gt;an; po newp(n,an); p.push_back(newp); &#125; cin&gt;&gt;k2; for(int i=0;i&lt;k2;i++)&#123; int f=0; cin&gt;&gt;n&gt;&gt;an; for(auto it=p.begin();it!=p.end();it++)&#123; if(it-&gt;n==n) &#123; it-&gt;an += an; f=1; break; &#125; &#125; if(!f)&#123; po newp(n,an); p.push_back(newp); &#125; &#125; sort(p.begin(),p.end(),cmp); int l=0; for(auto po:p) if(po.an!=0) l++; cout&lt;&lt;l; for(po val:p)&#123; if(val.an!=0) printf(" %d %.1f",val.n,val.an); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001 A+B Format （20 分)]]></title>
    <url>%2Fpost%2Fb2d1f2e4.html</url>
    <content type="text"><![CDATA[1001 A+B Format （20 分)Calculate a+b and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −106≤a,b≤106. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 作者: CHEN, Yue 单位: 浙江大学 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 题目大意计算两个数的和，以逗号分隔后输出 分析计算和，在相应位置输出逗号即可 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int c=a+b; if(c&lt;0) &#123; cout &lt;&lt; "-"; c=-c; &#125; string s=to_string(c); int l=s.length(); for(int i=0;i&lt;l;i++)&#123; cout&lt;&lt;s[i]; if(i+1!=l&amp;&amp;(i+1)%3==l%3) cout&lt;&lt;","; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
</search>
